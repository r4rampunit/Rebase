# ... (previous code remains the same)

# Combine HBAP and NonHBAP data
lic_df = pd.concat([lic_hbap_data, lic_non_hbap_data])
rwa_df = pd.concat([rwa_hbap_data, rwa_non_hbap_data])

# Function to safely filter DataFrame
def safe_filter(df, column, values):
    if column in df.columns and values:
        return df[df[column].isin(values)]
    return df

# Apply filters
filters = {
    'Organisational_unit_level_1': Organisational_unit_level_1_selected,
    'Organisational_unit_level_2': Organisational_unit_level_2_selected,
    'Organisational_unit_level_3': Organisational_unit_level_3_selected,
    'Country_of_Exposure': Country_of_Exposure_selected,
    'Asset_class': Asset_class_selected,
    'Product_Type': Product_Type_selected,
    'Basel_Approach': Basel_Approach_selected,
}

for key, value in filters.items():
    lic_df = safe_filter(lic_df, key, value)
    rwa_df = safe_filter(rwa_df, key, value)

# Process ST_scenario_selected
if ST_scenario_selected:
    st_scenario_list = [item.split('-') for item in ST_scenario_selected]
    st_list = [item[0] for item in st_scenario_list]
    scenario_list = [item[1] for item in st_scenario_list]

    lic_df = safe_filter(lic_df, 'ST', st_list)
    lic_df = safe_filter(lic_df, 'scenario', scenario_list)
    rwa_df = safe_filter(rwa_df, 'ST', st_list)
    rwa_df = safe_filter(rwa_df, 'scenario', scenario_list)

# ... (rest of the code remains the same)





import json
import pandas as pd
import os
from django.http import JsonResponse
from django.conf import settings

def mi_chart(request):
    if request.method == 'POST':
        selected_items = json.loads(request.POST.get('selectedItems', '{}'))
        selected_folder = request.GET.get("folder")
        selected_subfolder = request.GET.get("subfolder")

        if not selected_folder or not selected_subfolder:
            return JsonResponse({'error': 'Folder and subfolder must be selected'}, status=400)

        # Extract selected filters
        Organisational_unit_level_1_selected = selected_items.get('Organisational_unit_level_1', [])
        Organisational_unit_level_2_selected = selected_items.get('Organisational_unit_level_2', [])
        Organisational_unit_level_3_selected = selected_items.get('Organisational_unit_level_3', [])
        Country_of_Exposure_selected = selected_items.get('Country_of_Exposure', [])
        Asset_class_selected = selected_items.get('Asset_class', [])
        Product_Type_selected = selected_items.get('Product_Type', [])
        Basel_Approach_selected = selected_items.get('Basel_Approach', [])
        ST_scenario_selected = selected_items.get('ST_scenario', [])

        # Define projection periods for each column
        projection_periods = {
            'T1': [1, 2, 3, 4],
            'T2': [5, 6, 7, 8],
            'T3': [9, 10, 11, 12],
            'T4': [13, 14, 15, 16],
            'T5': [17, 18, 19, 20]
        }

        # Initialize result DataFrame
        row_names = ['Gross Balance ($ MM)', 'Net Balance ($ MM)', 'Net Balance Proportion S1', 
                     'Net Balance Proportion S2', 'Net Balance Proportion S3', 'ECL ($ MM)', 
                     'ECL Original ($ MM)', 'ECL Rate', 'Loss at WO ($ MM)', 'Loss at WO Original ($ MM)', 
                     'LIC ($ MM)', 'LIC Original ($ MM)', 'LIC overlay ($ MM)', 'LIC Rate', 
                     'Coverage ratio', 'PD', 'LGD', 'EAD ($ MM)', 'RWA ($ MM)', 'RWA Original ($ MM)', 
                     'RWA Overlay ($ MM)', 'RWA Density', 'EL($ MM)', 'EL Overlay ($ MM)', 'EL Density']
        column_names = ['T1', 'T2', 'T3', 'T4', 'T5']
        table_df = pd.DataFrame(index=row_names, columns=column_names)

        # Read Excel files
        folder_path = os.path.join(settings.FOLDER_PATH, selected_folder, selected_subfolder)
        excel_files = [f for f in os.listdir(folder_path) if f.endswith('.xlsx')]

        lic_hbap_data = pd.DataFrame()
        lic_non_hbap_data = pd.DataFrame()
        rwa_hbap_data = pd.DataFrame()
        rwa_non_hbap_data = pd.DataFrame()

        for excel_file in excel_files:
            file_path = os.path.join(folder_path, excel_file)
            if "LIC" in excel_file and "HBAP" in excel_file:
                lic_hbap_data = pd.concat([lic_hbap_data, pd.read_excel(file_path, sheet_name="LPACT_OL_YTD_QTR_Final")])
            elif "LIC" in excel_file and "NonHBAP" in excel_file:
                lic_non_hbap_data = pd.concat([lic_non_hbap_data, pd.read_excel(file_path, sheet_name="LPACT_OL_YTD_QTR_Final")])
            elif "MI" in excel_file and "HBAP" in excel_file:
                rwa_hbap_data = pd.concat([rwa_hbap_data, pd.read_excel(file_path, sheet_name="Temp_RRM_Final_OL")])
            elif "MI" in excel_file and "NonHBAP" in excel_file:
                rwa_non_hbap_data = pd.concat([rwa_non_hbap_data, pd.read_excel(file_path, sheet_name="Temp_RRM_Final_OL")])

        # Combine HBAP and NonHBAP data
        lic_df = pd.concat([lic_hbap_data, lic_non_hbap_data])
        rwa_df = pd.concat([rwa_hbap_data, rwa_non_hbap_data])

        # Apply filters
        filters = {
            'Organisational_unit_level_1': Organisational_unit_level_1_selected,
            'Organisational_unit_level_2': Organisational_unit_level_2_selected,
            'Organisational_unit_level_3': Organisational_unit_level_3_selected,
            'Country_of_Exposure': Country_of_Exposure_selected,
            'Asset_class': Asset_class_selected,
            'Product_Type': Product_Type_selected,
            'Basel_Approach': Basel_Approach_selected,
        }

        for key, value in filters.items():
            if value:
                lic_df = lic_df[lic_df[key].isin(value)]
                rwa_df = rwa_df[rwa_df[key].isin(value)]

        # Process ST_scenario_selected
        st_scenario_list = [item.split('-') for item in ST_scenario_selected]
        st_list = [item[0] for item in st_scenario_list]
        scenario_list = [item[1] for item in st_scenario_list]

        lic_df = lic_df[lic_df['ST'].isin(st_list) & lic_df['scenario'].isin(scenario_list)]
        rwa_df = rwa_df[rwa_df['ST'].isin(st_list) & rwa_df['scenario'].isin(scenario_list)]

        for col, periods in projection_periods.items():
            # Filter LIC data for the current period
            period_lic_data = lic_df[lic_df['Projection_Period'].isin(periods)]

            # Aggregate LIC data
            net_balance = period_lic_data['Balance'].sum() / 1000000
            provisions = period_lic_data['Provisions'].sum() / 1000000
            provisions_orig = period_lic_data['Provisions_orig'].sum() / 1000000
            loss_at_wo = period_lic_data['Loss_at_WO'].sum() / 1000000
            loss_at_wo_orig = period_lic_data['Loss_at_WO_orig'].sum() / 1000000
            lic = period_lic_data['LIC'].sum() / 1000000
            lic_orig = period_lic_data['LIC_orig'].sum() / 1000000

            # Calculate proportions
            stage_proportions = period_lic_data.groupby('IFRS9_Stage')['Balance'].sum() / period_lic_data['Balance'].sum()

            # Populate result DataFrame
            table_df.loc['Net Balance ($ MM)', col] = round(net_balance, 2)
            for stage, proportion in stage_proportions.items():
                table_df.loc[f"Net Balance Proportion S{stage}", col] = f"{round(proportion * 100, 2)}%"

            table_df.loc['ECL ($ MM)', col] = round(provisions, 2)
            table_df.loc['ECL Original ($ MM)', col] = round(provisions_orig, 2)
            table_df.loc['ECL Rate', col] = f"{round((provisions / net_balance) * 100, 2)}%"
            table_df.loc['Loss at WO ($ MM)', col] = round(loss_at_wo, 2)
            table_df.loc['Loss at WO Original ($ MM)', col] = round(loss_at_wo_orig, 2)
            table_df.loc['LIC ($ MM)', col] = round(lic, 2)
            table_df.loc['LIC Original ($ MM)', col] = round(lic_orig, 2)
            table_df.loc['LIC overlay ($ MM)', col] = round(lic - lic_orig, 2)
            table_df.loc['LIC Rate', col] = f"{round((lic / net_balance) * 100, 2)}%"

            # Filter RWA data for the current period (assuming Projection_Period 0 for RWA data)
            period_rwa_data = rwa_df[rwa_df['Projection_Period'] == 0]

            # Aggregate RWA data
            ead = period_rwa_data['Exposure_for_RWA'].sum() / 1000000
            rwa = period_rwa_data['RWA'].sum() / 1000000
            rwa_orig = period_rwa_data['RWA_Orig'].sum() / 1000000
            el = period_rwa_data['Expected_Loss_Regulatory'].sum() / 1000000
            el_orig = period_rwa_data['Expected_Loss_Regulatory_Orig'].sum() / 1000000

            # Populate result DataFrame with RWA data
            table_df.loc['EAD ($ MM)', col] = round(ead, 2)
            table_df.loc['RWA ($ MM)', col] = round(rwa, 2)
            table_df.loc['RWA Original ($ MM)', col] = round(rwa_orig, 2)
            table_df.loc['RWA Overlay ($ MM)', col] = round(rwa - rwa_orig, 2)
            table_df.loc['RWA Density', col] = f"{round((rwa / ead) * 100, 2)}%" if ead else "0%"
            table_df.loc['EL($ MM)', col] = round(el, 2)
            table_df.loc['EL Overlay ($ MM)', col] = round(el - el_orig, 2)
            table_df.loc['EL Density', col] = f"{round((el / ead) * 100, 2)}%" if ead else "0%"

        # Convert DataFrame to HTML
        table_html = table_df.to_html(classes="table table-striped table-bordered", index=True)
        
        return JsonResponse({'table_html': table_html})

    # Handle GET request or other cases
    return JsonResponse({'error': 'Invalid request method'}, status=400)




import json
import pandas as pd
import os
from django.http import JsonResponse
from django.conf import settings

def mi_chart(request):
    if request.method == 'POST':
        selected_items = json.loads(request.POST.get('selectedItems', '{}'))
        selected_folder = request.GET.get("folder")
        selected_subfolder = request.GET.get("subfolder")

        if not selected_folder or not selected_subfolder:
            return JsonResponse({'error': 'Folder and subfolder must be selected'}, status=400)

        # Extract selected filters
        filters = {
            'Organisational_unit_level_1': selected_items.get('Organisational_unit_level_1', []),
            'Organisational_unit_level_2': selected_items.get('Organisational_unit_level_2', []),
            'Organisational_unit_level_3': selected_items.get('Organisational_unit_level_3', []),
            'Country_of_Exposure': selected_items.get('Country_of_Exposure', []),
            'Asset_class': selected_items.get('Asset_class', []),
            'Product_Type': selected_items.get('Product_Type', []),
            'Basel_Approach': selected_items.get('Basel_Approach', []),
            'ST_scenario': selected_items.get('ST_scenario', [])
        }

        # Extract ST and scenario from ST_scenario
        st_scenario_list = [item.split('-') for item in filters['ST_scenario']]
        st_list = [item[0] for item in st_scenario_list]
        scenario_list = [item[1] for item in st_scenario_list]

        # Define projection periods for each column
        projection_periods = {
            'T1': [1, 2, 3, 4],
            'T2': [5, 6, 7, 8],
            'T3': [9, 10, 11, 12],
            'T4': [13, 14, 15, 16],
            'T5': [17, 18, 19, 20]
        }

        # Initialize result DataFrame
        result_df = pd.DataFrame(index=[
            'Net Balance ($ MM)', 'Net Balance Proportion S1', 'Net Balance Proportion S2',
            'Net Balance Proportion S3', 'ECL ($ MM)', 'ECL Original ($ MM)', 'ECL Rate',
            'Loss at WO ($ MM)', 'Loss at WO Original ($ MM)', 'LIC ($ MM)',
            'LIC Original ($ MM)', 'LIC overlay ($ MM)', 'LIC Rate', 'Coverage ratio',
            'PD', 'LGD', 'EAD ($ MM)', 'RWA ($ MM)', 'RWA Original ($ MM)',
            'RWA Overlay ($ MM)', 'RWA Density', 'EL($ MM)', 'EL Overlay ($ MM)', 'EL Density'
        ], columns=['T1', 'T2', 'T3', 'T4', 'T5'])

        # Read Excel files
        folder_path = os.path.join(settings.FOLDER_PATH, selected_folder, selected_subfolder)
        excel_files = [f for f in os.listdir(folder_path) if f.endswith('.xlsx')]

        lic_data = pd.DataFrame()
        rwa_data = pd.DataFrame()

        for excel_file in excel_files:
            file_path = os.path.join(folder_path, excel_file)
            if "LIC" in excel_file and "HBAP" in excel_file:
                lic_data = pd.concat([lic_data, pd.read_excel(file_path, sheet_name="LPACT_OL_YTD_QTR_Final")])
            elif "LIC" in excel_file and "NonHBAP" in excel_file:
                lic_data = pd.concat([lic_data, pd.read_excel(file_path, sheet_name="LPACT_OL_YTD_QTR_Final")])
            elif "MI" in excel_file and "HBAP" in excel_file:
                rwa_data = pd.concat([rwa_data, pd.read_excel(file_path, sheet_name="Temp_RRM_Final_OL")])
            elif "MI" in excel_file and "NonHBAP" in excel_file:
                rwa_data = pd.concat([rwa_data, pd.read_excel(file_path, sheet_name="Temp_RRM_Final_OL")])

        # Apply filters to lic_data and rwa_data
        for key, value in filters.items():
            if value:
                lic_data = lic_data[lic_data[key].isin(value)]
                rwa_data = rwa_data[rwa_data[key].isin(value)]

        for col, periods in projection_periods.items():
            # Filter LIC data for the current period
            period_lic_data = lic_data[lic_data['Projection_Period'].isin(periods)]

            # Aggregate LIC data
            lic_aggregates = period_lic_data.agg({
                'Balance': 'sum',
                'Provisions': 'sum',
                'Provisions_orig': 'sum',
                'Loss_at_WO': 'sum',
                'Loss_at_WO_orig': 'sum',
                'LIC': 'sum',
                'LIC_orig': 'sum'
            }) / 1000000  # Convert to millions

            # Calculate proportions
            stage_proportions = period_lic_data.groupby('IFRS9_Stage')['Balance'].sum() / lic_aggregates['Balance']

            # Populate result DataFrame
            result_df.loc['Net Balance ($ MM)', col] = round(lic_aggregates['Balance'], 2)
            for stage, proportion in stage_proportions.items():
                result_df.loc[f"Net Balance Proportion S{stage}", col] = f"{round(proportion * 100, 2)}%"

            result_df.loc['ECL ($ MM)', col] = round(lic_aggregates['Provisions'], 2)
            result_df.loc['ECL Original ($ MM)', col] = round(lic_aggregates['Provisions_orig'], 2)
            result_df.loc['ECL Rate', col] = f"{round((lic_aggregates['Provisions'] / lic_aggregates['Balance']) * 100, 2)}%"
            result_df.loc['Loss at WO ($ MM)', col] = round(lic_aggregates['Loss_at_WO'], 2)
            result_df.loc['Loss at WO Original ($ MM)', col] = round(lic_aggregates['Loss_at_WO_orig'], 2)
            result_df.loc['LIC ($ MM)', col] = round(lic_aggregates['LIC'], 2)
            result_df.loc['LIC Original ($ MM)', col] = round(lic_aggregates['LIC_orig'], 2)
            result_df.loc['LIC overlay ($ MM)', col] = round(lic_aggregates['LIC'] - lic_aggregates['LIC_orig'], 2)
            result_df.loc['LIC Rate', col] = f"{round((lic_aggregates['LIC'] / lic_aggregates['Balance']) * 100, 2)}%"

            # Filter RWA data for the current period (assuming Projection_Period 0 for RWA data)
            period_rwa_data = rwa_data[rwa_data['Projection_Period'] == 0]

            # Aggregate RWA data
            rwa_aggregates = period_rwa_data.agg({
                'Exposure_for_RWA': 'sum',
                'RWA': 'sum',
                'RWA_Orig': 'sum',
                'Expected_Loss_Regulatory': 'sum',
                'Expected_Loss_Regulatory_Orig': 'sum'
            }) / 1000000  # Convert to millions

            # Populate result DataFrame with RWA data
            result_df.loc['EAD ($ MM)', col] = round(rwa_aggregates['Exposure_for_RWA'], 2)
            result_df.loc['RWA ($ MM)', col] = round(rwa_aggregates['RWA'], 2)
            result_df.loc['RWA Original ($ MM)', col] = round(rwa_aggregates['RWA_Orig'], 2)
            result_df.loc['RWA Overlay ($ MM)', col] = round(rwa_aggregates['RWA'] - rwa_aggregates['RWA_Orig'], 2)
            result_df.loc['RWA Density', col] = f"{round((rwa_aggregates['RWA'] / rwa_aggregates['Exposure_for_RWA']) * 100, 2)}%" if rwa_aggregates['Exposure_for_RWA'] else "0%"
            result_df.loc['EL($ MM)', col] = round(rwa_aggregates['Expected_Loss_Regulatory'], 2)
            result_df.loc['EL Overlay ($ MM)', col] = round(rwa_aggregates['Expected_Loss_Regulatory'] - rwa_aggregates['Expected_Loss_Regulatory_Orig'], 2)
            result_df.loc['EL Density', col] = f"{round((rwa_aggregates['Expected_Loss_Regulatory'] / rwa_aggregates['Exposure_for_RWA']) * 100, 2)}%" if rwa_aggregates['Exposure_for_RWA'] else "0%"

        # Convert DataFrame to HTML
        table_html = result_df.to_html(classes="table table-striped table-bordered", index=True)
        
        return JsonResponse({'table_html': table_html})

    # Handle GET request or other cases
    return JsonResponse({'error': 'Invalid request method'}, status=400)





import json
import pandas as pd
from django.http import JsonResponse
from django.db.models import Sum, F, Case, When, Value, FloatField
from .models import LICData, RWAData  # Assuming you have these models

def mi_chart(request):
    if request.method == 'POST':
        selected_items = json.loads(request.POST.get('selectedItems', '{}'))
        
        # Extract selected filters
        filters = {
            'Organisational_unit_level_1': selected_items.get('Organisational_unit_level_1', []),
            'Organisational_unit_level_2': selected_items.get('Organisational_unit_level_2', []),
            'Organisational_unit_level_3': selected_items.get('Organisational_unit_level_3', []),
            'Country_of_Exposure': selected_items.get('Country_of_Exposure', []),
            'Asset_class': selected_items.get('Asset_class', []),
            'Product_Type': selected_items.get('Product_Type', []),
            'Basel_Approach': selected_items.get('Basel_Approach', []),
            'ST_scenario': selected_items.get('ST_scenario', [])
        }

        # Extract ST and scenario from ST_scenario
        st_scenario_list = [item.split('-') for item in filters['ST_scenario']]
        st_list = [item[0] for item in st_scenario_list]
        scenario_list = [item[1] for item in st_scenario_list]

        # Define projection periods for each column
        projection_periods = {
            'T1': [1, 2, 3, 4],
            'T2': [5, 6, 7, 8],
            'T3': [9, 10, 11, 12],
            'T4': [13, 14, 15, 16],
            'T5': [17, 18, 19, 20]
        }

        # Initialize result DataFrame
        result_df = pd.DataFrame(index=[
            'Net Balance ($ MM)', 'Net Balance Proportion S1', 'Net Balance Proportion S2',
            'Net Balance Proportion S3', 'ECL ($ MM)', 'ECL Original ($ MM)', 'ECL Rate',
            'Loss at WO ($ MM)', 'Loss at WO Original ($ MM)', 'LIC ($ MM)',
            'LIC Original ($ MM)', 'LIC overlay ($ MM)', 'LIC Rate', 'Coverage ratio',
            'PD', 'LGD', 'EAD ($ MM)', 'RWA ($ MM)', 'RWA Original ($ MM)',
            'RWA Overlay ($ MM)', 'RWA Density', 'EL($ MM)', 'EL Overlay ($ MM)', 'EL Density'
        ], columns=['T1', 'T2', 'T3', 'T4', 'T5'])

        for col, periods in projection_periods.items():
            # Filter LIC data
            lic_data = LICData.objects.filter(
                Organisational_unit_level_1__in=filters['Organisational_unit_level_1'],
                Organisational_unit_level_2__in=filters['Organisational_unit_level_2'],
                Organisational_unit_level_3__in=filters['Organisational_unit_level_3'],
                Country_of_Exposure__in=filters['Country_of_Exposure'],
                Asset_class__in=filters['Asset_class'],
                Product_Type__in=filters['Product_Type'],
                Basel_Approach__in=filters['Basel_Approach'],
                ST__in=st_list,
                scenario__in=scenario_list,
                Projection_Period__in=periods
            )

            # Aggregate LIC data
            lic_aggregates = lic_data.aggregate(
                net_balance=Sum('Balance') / 1000000,
                provisions=Sum('Provisions') / 1000000,
                provisions_orig=Sum('Provisions_orig') / 1000000,
                loss_at_wo=Sum('Loss_at_WO') / 1000000,
                loss_at_wo_orig=Sum('Loss_at_WO_orig') / 1000000,
                lic=Sum('LIC') / 1000000,
                lic_orig=Sum('LIC_orig') / 1000000
            )

            # Calculate proportions
            stage_proportions = lic_data.values('IFRS9_Stage').annotate(
                proportion=Sum('Balance') / lic_aggregates['net_balance']
            ).order_by('IFRS9_Stage')

            # Populate result DataFrame
            result_df.loc['Net Balance ($ MM)', col] = round(lic_aggregates['net_balance'], 2)
            for stage in stage_proportions:
                result_df.loc[f"Net Balance Proportion S{stage['IFRS9_Stage']}", col] = f"{round(stage['proportion'] * 100, 2)}%"

            result_df.loc['ECL ($ MM)', col] = round(lic_aggregates['provisions'], 2)
            result_df.loc['ECL Original ($ MM)', col] = round(lic_aggregates['provisions_orig'], 2)
            result_df.loc['ECL Rate', col] = f"{round((lic_aggregates['provisions'] / lic_aggregates['net_balance']) * 100, 2)}%"
            result_df.loc['Loss at WO ($ MM)', col] = round(lic_aggregates['loss_at_wo'], 2)
            result_df.loc['Loss at WO Original ($ MM)', col] = round(lic_aggregates['loss_at_wo_orig'], 2)
            result_df.loc['LIC ($ MM)', col] = round(lic_aggregates['lic'], 2)
            result_df.loc['LIC Original ($ MM)', col] = round(lic_aggregates['lic_orig'], 2)
            result_df.loc['LIC overlay ($ MM)', col] = round(lic_aggregates['lic'] - lic_aggregates['lic_orig'], 2)
            result_df.loc['LIC Rate', col] = f"{round((lic_aggregates['lic'] / lic_aggregates['net_balance']) * 100, 2)}%"

            # Filter RWA data
            rwa_data = RWAData.objects.filter(
                Organisational_unit_level_1__in=filters['Organisational_unit_level_1'],
                Organisational_unit_level_2__in=filters['Organisational_unit_level_2'],
                Organisational_unit_level_3__in=filters['Organisational_unit_level_3'],
                Country_of_Exposure__in=filters['Country_of_Exposure'],
                Asset_class__in=filters['Asset_class'],
                Product_Type__in=filters['Product_Type'],
                Basel_Approach__in=filters['Basel_Approach'],
                ST__in=st_list,
                scenario__in=scenario_list,
                Projection_Period=0
            )

            # Aggregate RWA data
            rwa_aggregates = rwa_data.aggregate(
                ead=Sum('Exposure_for_RWA') / 1000000,
                rwa=Sum('RWA') / 1000000,
                rwa_orig=Sum('RWA_Orig') / 1000000,
                el=Sum('Expected_Loss_Regulatory') / 1000000,
                el_orig=Sum('Expected_Loss_Regulatory_Orig') / 1000000
            )

            # Populate result DataFrame with RWA data
            result_df.loc['EAD ($ MM)', col] = round(rwa_aggregates['ead'], 2)
            result_df.loc['RWA ($ MM)', col] = round(rwa_aggregates['rwa'], 2)
            result_df.loc['RWA Original ($ MM)', col] = round(rwa_aggregates['rwa_orig'], 2)
            result_df.loc['RWA Overlay ($ MM)', col] = round(rwa_aggregates['rwa'] - rwa_aggregates['rwa_orig'], 2)
            result_df.loc['RWA Density', col] = f"{round((rwa_aggregates['rwa'] / rwa_aggregates['ead']) * 100, 2)}%" if rwa_aggregates['ead'] else "0%"
            result_df.loc['EL($ MM)', col] = round(rwa_aggregates['el'], 2)
            result_df.loc['EL Overlay ($ MM)', col] = round(rwa_aggregates['el'] - rwa_aggregates['el_orig'], 2)
            result_df.loc['EL Density', col] = f"{round((rwa_aggregates['el'] / rwa_aggregates['ead']) * 100, 2)}%" if rwa_aggregates['ead'] else "0%"

        # Convert DataFrame to HTML
        table_html = result_df.to_html(classes="table table-striped table-bordered", index=True)
        
        return JsonResponse({'table_html': table_html})

    # Handle GET request or other cases
    return JsonResponse({'error': 'Invalid request method'}, status=400)



from django.http import JsonResponse
from django.shortcuts import render

def mi_chart(request):
    folders = get_folders()
    selected_folder = request.GET.get("folder", None)
    selected_subfolder = request.GET.get("subfolder", None)
    subfolders = get_subfolders(selected_folder) if selected_folder else []

    if request.headers.get('x-requested-with') == 'XMLHttpRequest':
        selected_items = request.GET.get('selectedItems', {})
        # Print the selected items for testing purposes
        print(selected_items)
        return JsonResponse({'status': 'success', 'selectedItems': selected_items})

    if selected_folder and selected_subfolder:
        dataframes = read_excel_files(selected_folder, selected_subfolder)
    else:
        dataframes = []

    context = {
        'folders': folders,
        'subfolders': subfolders,
        'dataframes': dataframes,
    }

    return render(request, 'mi_templates/mi_chart.html', context)







function updateSelectedItems() {
  var allSelected = true;
  var selectedItems = {};

  $('.multiselect').each(function() {
    var dropdownName = $(this).attr('name');
    var selected = $(this).select2('data');
    if (selected.length == 0) {
      allSelected = false;
    }
    selectedItems[dropdownName] = selected.map(item => item.text);
  });

  if (allSelected) {
    var html = '<h3>Selected Items:</h3>';
    for (var dropdown in selectedItems) {
      html += '<p><strong>' + dropdown + ':</strong> ' + selectedItems[dropdown].join(', ') + '</p>';
    }
    $('#selectedItems').html(html).show();

    // Send selected items to the server via AJAX
    $.ajax({
      url: window.location.href,
      method: 'POST',
      data: {
        selectedItems: JSON.stringify(selectedItems),
        csrfmiddlewaretoken: getCookie('csrftoken')  // Add this line
      },
      success: function(response) {
        console.log('Selected items sent to server successfully.');
        // Update the table with the new data
        $('#tableContainer').html(response);
      },
      error: function(xhr, status, error) {
        console.error('Error sending selected items to server:', error);
      }
    });
  } else {
    $('#selectedItems').hide();
  }
}


function getCookie(name) {
  let cookieValue = null;
  if (document.cookie && document.cookie !== '') {
    const cookies = document.cookie.split(';');
    for (let i = 0; i < cookies.length; i++) {
      const cookie = cookies[i].trim();
      if (cookie.substring(0, name.length + 1) === (name + '=')) {
        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
        break;
      }
    }
  }
  return cookieValue;
}




from django.http import HttpResponse
from django.views.decorators.csrf import csrf_exempt
import json

@csrf_exempt
def mi_chart(request):
    if request.method == 'POST':
        selected_items = json.loads(request.POST.get('selectedItems', '{}'))

        # Process the selected items
        # For example, you can filter your data based on the selections

        # Generate the new table HTML
        table_html = generate_table_html(selected_items)  # You need to implement this function

        return HttpResponse(table_html)
    else:
        # Your existing code for GET requests
        ...






<body>
  <img src="/static/img/HSBC_hex.png" alt="Logo" class="logo">
  <center>
    <h1>Multiple Multiselect Dropdowns</h1>
    <hr/>
    <div class="dropdowns-container">
      <div class="dropdowns-wrapper">
        <div class="dropdown-wrapper">
          <select class="multiselect" name="trees" multiple>
            <option value="Oak">Oak</option>
            <option value="Pine">Pine</option>
            <option value="Maple">Maple</option>
            <option value="Birch">Birch</option>
            <option value="Elm">Elm</option>
          </select>
        </div>
        <div class="dropdown-wrapper">
          <select class="multiselect" name="animals" multiple>
            <option value="Lion">Lion</option>
            <option value="Elephant">Elephant</option>
            <option value="Giraffe">Giraffe</option>
            <option value="Tiger">Tiger</option>
            <option value="Bear">Bear</option>
          </select>
        </div>
        <div class="dropdown-wrapper">
          <select class="multiselect" name="flowers" multiple>
            <option value="Rose">Rose</option>
            <option value="Tulip">Tulip</option>
            <option value="Daisy">Daisy</option>
            <option value="Sunflower">Sunflower</option>
            <option value="Lily">Lily</option>
          </select>
        </div>
        <div class="dropdown-wrapper">
          <select class="multiselect" name="rivers" multiple>
            <option value="Amazon">Amazon</option>
            <option value="Nile">Nile</option>
            <option value="Yangtze">Yangtze</option>
            <option value="Mississippi">Mississippi</option>
            <option value="Danube">Danube</option>
          </select>
        </div>
        <div class="dropdown-wrapper">
          <select class="multiselect" name="countries" multiple>
            <option value="USA">USA</option>
            <option value="China">China</option>
            <option value="India">India</option>
            <option value="Brazil">Brazil</option>
            <option value="Russia">Russia</option>
          </select>
        </div>
      </div>
    </div>
    <div id="tableContainer"></div>
    {% csrf_token %}
  </center>
</body>




$(document).ready(function() {
  $(".multiselect").select2({
    placeholder: 'Select one or more options',
    closeOnSelect: false,
    allowClear: true,
    tags: true
  });

  function updateSelectedItems() {
    var selectedItems = {};
    $('.multiselect').each(function() {
      var dropdownName = $(this).attr('name');
      var selected = $(this).select2('data');
      selectedItems[dropdownName] = selected.map(item => item.text);
    });

    // Send selected items to the server via AJAX
    $.ajax({
      url: '/mi_chart/',  // Update this URL to match your Django URL configuration
      method: 'POST',
      data: {
        selectedItems: JSON.stringify(selectedItems),
        csrfmiddlewaretoken: getCookie('csrftoken')
      },
      success: function(response) {
        $('#tableContainer').html(response);
      },
      error: function(xhr, status, error) {
        console.error('Error sending selected items to server:', error);
      }
    });
  }

  $('.multiselect').on('change', updateSelectedItems);

  // Initial call to populate the table
  updateSelectedItems();
});

function getCookie(name) {
  let cookieValue = null;
  if (document.cookie && document.cookie !== '') {
    const cookies = document.cookie.split(';');
    for (let i = 0; i < cookies.length; i++) {
      const cookie = cookies[i].trim();
      if (cookie.substring(0, name.length + 1) === (name + '=')) {
        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
        break;
      }
    }
  }
  return cookieValue;
}




from django.http import HttpResponse
from django.views.decorators.csrf import csrf_exempt
import json

@csrf_exempt
def mi_chart(request):
    if request.method == 'POST':
        selected_items = json.loads(request.POST.get('selectedItems', '{}'))

        # Generate the table HTML
        html = "<table border='1'>"
        html += "<tr><th>Category</th><th>Selected Items</th></tr>"

        for category, items in selected_items.items():
            html += f"<tr><td>{category.capitalize()}</td><td>{', '.join(items)}</td></tr>"

        html += "</table>"

        return HttpResponse(html)
    else:
        return HttpResponse("This view only accepts POST requests.")





















from django.http import HttpResponse
from django.shortcuts import render
from django.views.decorators.csrf import csrf_exempt
import json

@csrf_exempt
def mi_chart(request):
    if request.method == 'POST':
        selected_items = json.loads(request.POST.get('selectedItems', '{}'))

        # Generate the table HTML
        html = generate_table_html(selected_items)

        return HttpResponse(html)
    else:
        # For GET requests, render the initial page with an empty table
        initial_data = {
            'trees': [],
            'animals': [],
            'flowers': [],
            'rivers': [],
            'countries': []
        }
        initial_table = generate_table_html(initial_data)
        context = {
            'initial_table': initial_table
        }
        return render(request, 'your_template_name.html', context)

def generate_table_html(selected_items):
    html = "<table border='1'>"
    html += "<tr><th>Category</th><th>Selected Items</th></tr>"

    for category, items in selected_items.items():
        html += f"<tr><td>{category.capitalize()}</td><td>{', '.join(items)}</td></tr>"

    html += "</table>"
    return html
















<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiple Multiselect Dropdowns</title>
    <!-- Include necessary CSS and JS files here -->
</head>
<body>
    <img src="/static/img/HSBC_hex.png" alt="Logo" class="logo">
    <center>
        <h1>Multiple Multiselect Dropdowns</h1>
        <hr/>
        <div class="dropdowns-container">
            <div class="dropdowns-wrapper">
                <div class="dropdown-wrapper">
                    <select class="multiselect" name="trees" multiple>
                        <option value="Oak">Oak</option>
                        <option value="Pine">Pine</option>
                        <option value="Maple">Maple</option>
                        <option value="Birch">Birch</option>
                        <option value="Elm">Elm</option>
                    </select>
                </div>
                <div class="dropdown-wrapper">
                    <select class="multiselect" name="animals" multiple>
                        <option value="Lion">Lion</option>
                        <option value="Elephant">Elephant</option>
                        <option value="Giraffe">Giraffe</option>
                        <option value="Tiger">Tiger</option>
                        <option value="Bear">Bear</option>
                    </select>
                </div>
                <div class="dropdown-wrapper">
                    <select class="multiselect" name="flowers" multiple>
                        <option value="Rose">Rose</option>
                        <option value="Tulip">Tulip</option>
                        <option value="Daisy">Daisy</option>
                        <option value="Sunflower">Sunflower</option>
                        <option value="Lily">Lily</option>
                    </select>
                </div>
                <div class="dropdown-wrapper">
                    <select class="multiselect" name="rivers" multiple>
                        <option value="Amazon">Amazon</option>
                        <option value="Nile">Nile</option>
                        <option value="Yangtze">Yangtze</option>
                        <option value="Mississippi">Mississippi</option>
                        <option value="Danube">Danube</option>
                    </select>
                </div>
                <div class="dropdown-wrapper">
                    <select class="multiselect" name="countries" multiple>
                        <option value="USA">USA</option>
                        <option value="China">China</option>
                        <option value="India">India</option>
                        <option value="Brazil">Brazil</option>
                        <option value="Russia">Russia</option>
                    </select>
                </div>
            </div>
        </div>
        <div id="tableContainer">
            {{ initial_table|safe }}
        </div>
        {% csrf_token %}
    </center>
    <!-- Include your JavaScript code here -->
</body>
</html>





















import pandas as pd
import matplotlib.pyplot as plt
import io
import base64
from django.http import HttpResponse
from django.shortcuts import render
from django.views.decorators.csrf import csrf_exempt
import json

# Create the DataFrame
data = {
    'trees': ['Oak', 'Pine', 'Maple', 'Birch', 'Elm', 'Redwood', 'Cedar', 'Spruce', 'Fir', 'Willow'],
    'animals': ['Lion', 'Elephant', 'Giraffe', 'Tiger', 'Bear', 'Wolf', 'Deer', 'Fox', 'Leopard', 'Rhino'],
    'flowers': ['Rose', 'Tulip', 'Daisy', 'Sunflower', 'Lily', 'Orchid', 'Carnation', 'Daffodil', 'Iris', 'Peony'],
    'rivers': ['Amazon', 'Nile', 'Yangtze', 'Mississippi', 'Danube', 'Congo', 'Mekong', 'Rhine', 'Volga', 'Thames'],
    'countries': ['USA', 'China', 'India', 'Brazil', 'Russia', 'Japan', 'Germany', 'UK', 'France', 'Canada']
}

df = pd.DataFrame(data)

@csrf_exempt
def mi_chart(request):
    if request.method == 'POST':
        selected_items = json.loads(request.POST.get('selectedItems', '{}'))

        # Filter the DataFrame
        filtered_df = df.copy()
        for category, items in selected_items.items():
            if items:
                filtered_df = filtered_df[filtered_df[category].isin(items)]

        # Generate the table HTML
        table_html = filtered_df.to_html(classes='table table-striped')

        # Generate plots
        plots_html = generate_plots(filtered_df)

        response_html = f"{table_html}<br>{plots_html}"
        return HttpResponse(response_html)
    else:
        # For GET requests, render the initial page with the full DataFrame
        initial_table = df.to_html(classes='table table-striped')
        initial_plots = generate_plots(df)
        context = {
            'initial_table': initial_table,
            'initial_plots': initial_plots,
            'categories': list(df.columns)
        }
        return render(request, 'your_template_name.html', context)

def generate_plots(df):
    plots_html = ""

    # Plot 1: Bar chart of counts for each category
    plt.figure(figsize=(10, 6))
    df.count().plot(kind='bar')
    plt.title('Count of Items in Each Category')
    plt.ylabel('Count')
    plots_html += get_plot_html()

    # Plot 2: Pie chart of the first category
    plt.figure(figsize=(8, 8))
    df[df.columns[0]].value_counts().plot(kind='pie', autopct='%1.1f%%')
    plt.title(f'Distribution of {df.columns[0]}')
    plots_html += get_plot_html()

    return plots_html

def get_plot_html():
    buffer = io.BytesIO()
    plt.savefig(buffer, format='png')
    buffer.seek(0)
    image_png = buffer.getvalue()
    buffer.close()
    graphic = base64.b64encode(image_png)
    graphic = graphic.decode('utf-8')
    return f'<img src="data:image/png;base64,{graphic}"/>'





<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiple Multiselect Dropdowns</title>
    <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>
    <style>
        .dropdown-wrapper { margin-bottom: 10px; }
    </style>
</head>
<body>
    <img src="/static/img/HSBC_hex.png" alt="Logo" class="logo">
    <center>
        <h1>Multiple Multiselect Dropdowns</h1>
        <hr/>
        <div class="dropdowns-container">
            <div class="dropdowns-wrapper">
                {% for category in categories %}
                <div class="dropdown-wrapper">
                    <select class="multiselect" name="{{ category }}" multiple>
                        {% for option in df[category] %}
                        <option value="{{ option }}">{{ option }}</option>
                        {% endfor %}
                    </select>
                </div>
                {% endfor %}
            </div>
        </div>
        <div id="tableContainer">
            {{ initial_table|safe }}
        </div>
        <div id="plotsContainer">
            {{ initial_plots|safe }}
        </div>
        {% csrf_token %}
    </center>
    <script>
        $(document).ready(function() {
            $(".multiselect").select2({
                placeholder: 'Select one or more options',
                closeOnSelect: false,
                allowClear: true,
                tags: true
            });

            function updateSelectedItems() {
                var selectedItems = {};
                $('.multiselect').each(function() {
                    var dropdownName = $(this).attr('name');
                    var selected = $(this).select2('data');
                    selectedItems[dropdownName] = selected.map(item => item.text);
                });

                $.ajax({
                    url: '/mi_chart/',  // Update this URL to match your Django URL configuration
                    method: 'POST',
                    data: {
                        selectedItems: JSON.stringify(selectedItems),
                        csrfmiddlewaretoken: $('input[name=csrfmiddlewaretoken]').val()
                    },
                    success: function(response) {
                        $('#tableContainer').html($(response).filter('#tableContainer').html());
                        $('#plotsContainer').html($(response).filter('#plotsContainer').html());
                    },
                    error: function(xhr, status, error) {
                        console.error('Error sending selected items to server:', error);
                    }
                });
            }

            $('.multiselect').on('change', updateSelectedItems);
        });
    </script>
</body>
</html>
























import pandas as pd
import matplotlib.pyplot as plt
import io
import base64
from django.http import HttpResponse
from django.shortcuts import render
from django.views.decorators.csrf import csrf_exempt
import json

# Create the DataFrame with hard-coded options
data = {
    'trees': ['Oak', 'Pine', 'Maple', 'Birch', 'Elm'],
    'animals': ['Lion', 'Elephant', 'Giraffe', 'Tiger', 'Bear'],
    'flowers': ['Rose', 'Tulip', 'Daisy', 'Sunflower', 'Lily'],
    'rivers': ['Amazon', 'Nile', 'Yangtze', 'Mississippi', 'Danube'],
    'countries': ['USA', 'China', 'India', 'Brazil', 'Russia']
}

df = pd.DataFrame(data)

@csrf_exempt
def mi_chart(request):
    if request.method == 'POST':
        selected_items = json.loads(request.POST.get('selectedItems', '{}'))

        # Filter the DataFrame
        filtered_df = df.copy()
        for category, items in selected_items.items():
            if items:
                filtered_df = filtered_df[filtered_df[category].isin(items)]

        # Generate the table HTML
        table_html = filtered_df.to_html(classes='table table-striped')

        # Generate plots
        plots_html = generate_plots(filtered_df)

        response_html = f"<div id='tableContainer'>{table_html}</div><div id='plotsContainer'>{plots_html}</div>"
        return HttpResponse(response_html)
    else:
        # For GET requests, render the initial page with the full DataFrame
        initial_table = df.to_html(classes='table table-striped')
        initial_plots = generate_plots(df)
        context = {
            'initial_table': initial_table,
            'initial_plots': initial_plots
        }
        return render(request, 'your_template_name.html', context)

def generate_plots(df):
    plots_html = ""

    # Plot 1: Bar chart of counts for each category
    plt.figure(figsize=(10, 6))
    df.count().plot(kind='bar')
    plt.title('Count of Items in Each Category')
    plt.ylabel('Count')
    plots_html += get_plot_html()

    # Plot 2: Pie chart of the first category
    plt.figure(figsize=(8, 8))
    df[df.columns[0]].value_counts().plot(kind='pie', autopct='%1.1f%%')
    plt.title(f'Distribution of {df.columns[0]}')
    plots_html += get_plot_html()

    return plots_html

def get_plot_html():
    buffer = io.BytesIO()
    plt.savefig(buffer, format='png')
    buffer.seek(0)
    image_png = buffer.getvalue()
    buffer.close()
    graphic = base64.b64encode(image_png)
    graphic = graphic.decode('utf-8')
    return f'<img src="data:image/png;base64,{graphic}"/>'









<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiple Multiselect Dropdowns</title>
    <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>
    <style>
        .dropdown-wrapper { margin-bottom: 10px; }
    </style>
</head>
<body>
    <img src="/static/img/HSBC_hex.png" alt="Logo" class="logo">
    <center>
        <h1>Multiple Multiselect Dropdowns</h1>
        <hr/>
        <div class="dropdowns-container">
            <div class="dropdowns-wrapper">
                <div class="dropdown-wrapper">
                    <select class="multiselect" name="trees" multiple>
                        <option value="Oak">Oak</option>
                        <option value="Pine">Pine</option>
                        <option value="Maple">Maple</option>
                        <option value="Birch">Birch</option>
                        <option value="Elm">Elm</option>
                    </select>
                </div>
                <div class="dropdown-wrapper">
                    <select class="multiselect" name="animals" multiple>
                        <option value="Lion">Lion</option>
                        <option value="Elephant">Elephant</option>
                        <option value="Giraffe">Giraffe</option>
                        <option value="Tiger">Tiger</option>
                        <option value="Bear">Bear</option>
                    </select>
                </div>
                <div class="dropdown-wrapper">
                    <select class="multiselect" name="flowers" multiple>
                        <option value="Rose">Rose</option>
                        <option value="Tulip">Tulip</option>
                        <option value="Daisy">Daisy</option>
                        <option value="Sunflower">Sunflower</option>
                        <option value="Lily">Lily</option>
                    </select>
                </div>
                <div class="dropdown-wrapper">
                    <select class="multiselect" name="rivers" multiple>
                        <option value="Amazon">Amazon</option>
                        <option value="Nile">Nile</option>
                        <option value="Yangtze">Yangtze</option>
                        <option value="Mississippi">Mississippi</option>
                        <option value="Danube">Danube</option>
                    </select>
                </div>
                <div class="dropdown-wrapper">
                    <select class="multiselect" name="countries" multiple>
                        <option value="USA">USA</option>
                        <option value="China">China</option>
                        <option value="India">India</option>
                        <option value="Brazil">Brazil</option>
                        <option value="Russia">Russia</option>
                    </select>
                </div>
            </div>
        </div>
        <div id="tableContainer">
            {{ initial_table|safe }}
        </div>
        <div id="plotsContainer">
            {{ initial_plots|safe }}
        </div>
        {% csrf_token %}
    </center>
    <script>
        $(document).ready(function() {
            $(".multiselect").select2({
                placeholder: 'Select one or more options',
                closeOnSelect: false,
                allowClear: true
            });

            function updateSelectedItems() {
                var selectedItems = {};
                $('.multiselect').each(function() {
                    var dropdownName = $(this).attr('name');
                    var selected = $(this).select2('data');
                    selectedItems[dropdownName] = selected.map(item => item.text);
                });

                $.ajax({
                    url: '/mi_chart/',  // Update this URL to match your Django URL configuration
                    method: 'POST',
                    data: {
                        selectedItems: JSON.stringify(selectedItems),
                        csrfmiddlewaretoken: $('input[name=csrfmiddlewaretoken]').val()
                    },
                    success: function(response) {
                        $('#tableContainer').html($(response).filter('#tableContainer').html());
                        $('#plotsContainer').html($(response).filter('#plotsContainer').html());
                    },
                    error: function(xhr, status, error) {
                        console.error('Error sending selected items to server:', error);
                    }
                });
            }

            $('.multiselect').on('change', updateSelectedItems);
        });
    </script>
</body>
</html>




















@csrf_exempt
def mi_chart(request):
    response_html = ""  # Initialize response_html at the beginning

    if request.method == 'POST':
        selected_items = json.loads(request.POST.get('selectedItems', '{}'))
        print(selected_items)
        list_of_selected = []
        for category, items in selected_items.items():
            if items:
                print(category)
                list_of_selected.append(items)

        # Assign selected items to variables
        Organisational_unit_level_1_selected = list_of_selected[0]
        Organisational_unit_level_2_selected = list_of_selected[1]
        Organisational_unit_level_3_selected = list_of_selected[2]
        Country_of_Exposure_selected = list_of_selected[3]
        Asset_class_selected = list_of_selected[4]
        Product_Type_selected = list_of_selected[5]
        Basel_Approach_selected = list_of_selected[6]
        ST_scenario_selected = list_of_selected[7]

    folders = get_folders()
    selected_folder = request.GET.get("folder", None)
    selected_subfolder = request.GET.get("subfolder", None)
    subfolders = get_subfolders(selected_folder) if selected_folder else []

    if selected_folder and selected_subfolder:
        folder_path = os.path.join(FOLDER_PATH, selected_folder, selected_subfolder)
        excel_files = [f for f in os.listdir(folder_path) if f.endswith(".xlsx")]

        # Process excel files and perform data operations here
        # ...

        # Create and populate table_df
        table_df = pd.DataFrame()  # Initialize table_df

        # Populate table_df
        # ...

        table_html = table_df.to_html(classes='table table-striped table-bordered', index=False)
        response_html = f"<div id='tableContainer'>{table_html}</div>"

    if response_html:
        return HttpResponse(response_html)
    else:
        context1 = {
            'folders': folders,
            'subfolders': subfolders,
            'selected_folder': selected_folder,
            'selected_subfolder': selected_subfolder,
            'Organisational_unit_level_1_list': Organisational_unit_level_1_list,
            'Organisational_unit_level_2_list': Organisational_unit_level_2_list,
            'Organisational_unit_level_3_list': Organisational_unit_level_3_list,
            'Country_of_Exposure_list': Country_of_Exposure_list,
            'Asset_class_list': Asset_class_list,
            'Product_Type_list': Product_Type_list,
            'Basel_Approach_list': Basel_Approach_list,
            'ST_scenario_combo': ST_scenario_combo
        }
        return render(request, 'mi_templates/mi_chart.html', context1)






The Comprehensive Capital Analysis and Review (CCAR) is an annual exercise conducted by the Federal Reserve to assess whether large banks have sufficient capital to continue operations throughout times of economic and financial stress. Developing a CCAR model using Python involves several components. Here's an overview of the process along with some sample Python code to get you started:

Data Preparation
Scenario Generation
Balance Sheet Projection
Income Statement Projection
Risk-Weighted Assets (RWA) Calculation
Capital Ratio Calculation
Stress Testing
Reporting

Let's go through each step with some Python code examples:

Data Preparation:

pythonCopyimport pandas as pd
import numpy as np

# Load historical data
historical_data = pd.read_csv('historical_data.csv')

# Clean and preprocess data
def preprocess_data(data):
    # Handle missing values
    data = data.fillna(method='ffill')

    # Convert date column to datetime
    data['date'] = pd.to_datetime(data['date'])

    return data

cleaned_data = preprocess_data(historical_data)

Scenario Generation:

pythonCopydef generate_scenarios(base_data, num_scenarios=3):
    scenarios = []
    for i in range(num_scenarios):
        scenario = base_data.copy()
        # Apply random shocks to key economic variables
        scenario['gdp_growth'] *= np.random.uniform(0.8, 1.2)
        scenario['unemployment_rate'] += np.random.uniform(-1, 1)
        scenario['interest_rate'] += np.random.uniform(-0.5, 0.5)
        scenarios.append(scenario)
    return scenarios

base_scenario = cleaned_data[['date', 'gdp_growth', 'unemployment_rate', 'interest_rate']]
stress_scenarios = generate_scenarios(base_scenario)

Balance Sheet Projection:

pythonCopydef project_balance_sheet(initial_balance_sheet, scenario, projection_period):
    projected_balance_sheet = initial_balance_sheet.copy()

    for t in range(projection_period):
        # Project assets based on economic factors
        projected_balance_sheet['total_assets'] *= (1 + scenario['gdp_growth'].iloc[t])

        # Project liabilities
        projected_balance_sheet['total_liabilities'] *= (1 + scenario['interest_rate'].iloc[t] * 0.1)

        # Calculate equity
        projected_balance_sheet['total_equity'] = projected_balance_sheet['total_assets'] - projected_balance_sheet['total_liabilities']

    return projected_balance_sheet

initial_balance_sheet = pd.DataFrame({'total_assets': [1000000], 'total_liabilities': [900000], 'total_equity': [100000]})
projected_balance_sheet = project_balance_sheet(initial_balance_sheet, stress_scenarios[0], projection_period=9)

Income Statement Projection:

pythonCopydef project_income_statement(balance_sheet, scenario, projection_period):
    income_statement = pd.DataFrame(index=range(projection_period))

    for t in range(projection_period):
        # Project net interest income
        income_statement.loc[t, 'net_interest_income'] = balance_sheet['total_assets'].iloc[t] * scenario['interest_rate'].iloc[t] * 0.02

        # Project non-interest income
        income_statement.loc[t, 'non_interest_income'] = balance_sheet['total_assets'].iloc[t] * 0.01

        # Project expenses
        income_statement.loc[t, 'expenses'] = balance_sheet['total_assets'].iloc[t] * 0.015

        # Calculate net income
        income_statement.loc[t, 'net_income'] = income_statement.loc[t, 'net_interest_income'] + income_statement.loc[t, 'non_interest_income'] - income_statement.loc[t, 'expenses']

    return income_statement

projected_income_statement = project_income_statement(projected_balance_sheet, stress_scenarios[0], projection_period=9)

Risk-Weighted Assets (RWA) Calculation:

pythonCopydef calculate_rwa(balance_sheet, scenario):
    # Simplified RWA calculation
    rwa = balance_sheet['total_assets'] * 0.75  # Assuming 75% risk weight on average
    return rwa

rwa = calculate_rwa(projected_balance_sheet, stress_scenarios[0])

Capital Ratio Calculation:

pythonCopydef calculate_capital_ratios(balance_sheet, rwa):
    cet1_ratio = balance_sheet['total_equity'] / rwa
    total_capital_ratio = (balance_sheet['total_equity'] + balance_sheet['total_liabilities'] * 0.02) / rwa  # Assuming 2% of liabilities are eligible as Tier 2 capital
    return pd.DataFrame({'CET1 Ratio': cet1_ratio, 'Total Capital Ratio': total_capital_ratio})

capital_ratios = calculate_capital_ratios(projected_balance_sheet, rwa)

Stress Testing:

pythonCopydef perform_stress_test(initial_balance_sheet, scenarios, projection_period):
    results = []
    for scenario in scenarios:
        balance_sheet = project_balance_sheet(initial_balance_sheet, scenario, projection_period)
        income_statement = project_income_statement(balance_sheet, scenario, projection_period)
        rwa = calculate_rwa(balance_sheet, scenario)
        capital_ratios = calculate_capital_ratios(balance_sheet, rwa)
        results.append({
            'scenario': scenario,
            'balance_sheet': balance_sheet,
            'income_statement': income_statement,
            'rwa': rwa,
            'capital_ratios': capital_ratios
        })
    return results

stress_test_results = perform_stress_test(initial_balance_sheet, stress_scenarios, projection_period=9)

Reporting:

pythonCopyimport matplotlib.pyplot as plt

def generate_report(stress_test_results):
    for i, result in enumerate(stress_test_results):
        plt.figure(figsize=(12, 6))
        plt.plot(result['capital_ratios']['CET1 Ratio'], label='CET1 Ratio')
        plt.plot(result['capital_ratios']['Total Capital Ratio'], label='Total Capital Ratio')
        plt.title(f'Capital Ratios under Scenario {i+1}')
        plt.xlabel('Projection Period')
        plt.ylabel('Ratio')
        plt.legend()
        plt.savefig(f'scenario_{i+1}_capital_ratios.png')
        plt.close()

        # Generate other charts and tables as needed

generate_report(stress_test_results)
This code provides a basic framework for CCAR modeling and stress testing. In practice, you would need to:

Use more sophisticated models for projections and risk calculations.
Incorporate more detailed data and risk factors.
Implement regulatory requirements and guidelines specific to CCAR.
Develop more comprehensive reporting capabilities.
Implement model validation and sensitivity analysis.
Ensure compliance with regulatory standards and documentation requirements.

Remember that CCAR models are complex and require deep understanding of banking regulations, risk management, and financial modeling. This code is a simplified example and should be significantly expanded and refined for actual use in a regulatory context. CopyRetryClaude does not have the ability to run the code it generates yet.Claude can make mistakes. Please double-check responses.
  #monica-writing-entry-btn-root {
    ._monica-theme-d2f2b383 {
      --theme-text-primary: #262626;
      --theme-text-secondary: #404040;
      --theme-text-tertiary: #595959;
      --theme-text-quaternary: #8C8C8C;
      --theme-text-disable: #BDBDBD;
      --theme-text-white-primary: #FFFFFF;
      --theme-text-white-secondary: #FFFFFF;
      --theme-text-link: #1E6FFF;
      --theme-text-link-active: #1E6FFF;
      --theme-text-brand: #6841EA;

      --theme-icon-primary: #222226;
      --theme-icon-secondary: #3D3D43;
      --theme-icon-tertiary: #55555D;
      --theme-icon-quaternary: #868692;
      --theme-icon-disable: #D9D9DD;
      --theme-icon-white-primary: #FFFFFF;
      --theme-icon-white-secondary: #FFFFFF;
      --theme-icon-brand: #6841EA;

      --theme-btn-fill-primary: #6841EA;
      --theme-btn-fill-primary-hover: #9373FF;
      --theme-btn-fill-primary-active: #522BD6;
      --theme-btn-fill-secondary: #ECECEE;
      --theme-btn-fill-secondary-hover: #F5F5F5;
      --theme-btn-fill-secondary-active: #D9D9DD;
      --theme-btn-fill-tertiary: #F0EBFF;
      --theme-btn-fill-tertiary-hover: #DFD5FE;
      --theme-btn-fill-tertiary-active: #B8A3FB;
      --theme-btn-border-primary: #4F59661F;
      --theme-btn-border-secondary: #4F596614;

      --theme-fill-tsp-components-primary: #4F59661F;
      --theme-fill-tsp-components-secondary: #4F596614;
      --theme-fill-tsp-components-tertiary: #4F59660A;
      --theme-fill-btn-primary: #ECECEE;
      --theme-fill-btn-secondary: #F5F5F5;
      --theme-fill-white: #FFFFFF;
      --theme-fill-tsp-blue: #185CEB14;
      --theme-fill-tsp-brand: #6841EA14;
      --theme-fill-tsp-brand-primary: #6841EABF;
      --theme-fill-tsp-brand-secondary: #6841EA73;
      --theme-fill-tsp-brand-tertiary: #6841EA3D;
      --theme-fill-tsp-gray: #4F596652;
      --theme-fill-black-none: #252528;


      --theme-label-tsp-brand-primary: #6841EA1F;
      --theme-label-tsp-brand-secondary: #6841EA14;


      --theme-border-light: #4F596614;
      --theme-border-primary: #4F59661F;
      --theme-border-quaternary: #4F596633;
      --theme-border-active: #6841EA;
      --theme-border-white: #FFFFFF0A;

      --theme-tab-fill: #4F596614;
      --theme-tab-fill-active: #222226;

      --theme-tooltips-fill: #000000D9;

      --theme-bg-white: #FFFFFF;
      --theme-bg-gray-primary: #F5F5F5;
      --theme-bg-gray-secondary: #FAFAFA;
      --theme-bg-mask: #00000073;
      --theme-bg-menu-white: #FFFFFF;
      --theme-bg-menu-gray: #F5F5F5;
      --theme-bg-tsp-gray-primary: #F5F5F5E6;
      --theme-bg-tsp-white-primary: #FFFFFF;
      --theme-bg-gray-nav: #ececee;
      --theme-bg-tsp-white-secondary: #FFFFFF73;

      --theme-function-info: #3BBFFF;
      --theme-function-success: #00AA5B;
      --theme-function-warning: #FFAB00;
      --theme-function-error: #EA3639;
      --theme-function-error-border: #FFA4A3;
      --theme-function-warning-light: #FDFAE9;
      --theme-function-warning-border: #FFE266;

      --theme-shadow-s1: rgba(0, 0, 0, 0.04);
      --theme-shadow-s2: rgba(0, 0, 0, 0.08);
      --theme-shadow-s3: rgba(0, 0, 0, 0.24);

      --theme-box-shadow-s1: 0px 1px 20px 0px var(--theme-shadow-s1);
      --theme-box-shadow-s2: 0px 8px 24px 0px var(--theme-shadow-s2), 0px 0px 1px 0px var(--theme-shadow-s2);
      --theme-box-shadow-s3: 0px 12px 40px -4px var(--theme-shadow-s3), 0px 0px 2px 0px var(--theme-shadow-s2);

    }
    ._monica-theme-d2f2b383._monica-dark {
      --theme-text-primary:  #F3F3F3;
      --theme-text-secondary:  #DBDBDB;
      --theme-text-tertiary:  #AAAAAA;
      --theme-text-quaternary:  #7A7A7A;
      --theme-text-disable:  #4C4C4C;
      --theme-text-white-primary:  #E9EAED;
      --theme-text-white-secondary:  #E9EAED;
      --theme-text-link:  #5E8CFF;
      --theme-text-link-active:  #3767EB;
      --theme-text-brand:  #7F58FD;

      --theme-icon-primary:  #F3F3F4;
      --theme-icon-secondary:  #BFBFC4;
      --theme-icon-tertiary:  #A7A7AE;
      --theme-icon-quaternary:  #77777E;
      --theme-icon-disable:  #4A4A4F;
      --theme-icon-white-primary:  #F3F3F4;
      --theme-icon-white-secondary:  #F3F3F4;
      --theme-icon-brand:  #7F58FD;

      --theme-btn-fill-primary:  #7F58FD;
      --theme-btn-fill-primary-hover:  #8363E9;
      --theme-btn-fill-primary-active:  #5E40BF;
      --theme-btn-fill-secondary:  #56565F3D;
      --theme-btn-fill-secondary-hover:  #56565F52;
      --theme-btn-fill-secondary-active:  #56565F52;
      --theme-btn-fill-tertiary:  #3C2B73;
      --theme-btn-fill-tertiary-hover:  #332560;
      --theme-btn-fill-tertiary-active: #271F42;
      --theme-btn-border-primary:  #A2B1D733;
      --theme-btn-border-secondary:  #A2B1D71F;

      --theme-fill-tsp-components-primary:  #56565F52;
      --theme-fill-tsp-components-secondary:  #56565F33;
      --theme-fill-tsp-components-tertiary:  #56565F1F;
      --theme-fill-btn-primary:  #2d2d2f;
      --theme-fill-btn-secondary:  #252528;
      --theme-fill-white:  #0000003D;
      --theme-fill-tsp-blue:  #5E8CFF1F;
      --theme-fill-tsp-brand:  #765AD01F;
      --theme-fill-tsp-brand-primary:  #765AD0D9;
      --theme-fill-tsp-brand-secondary: #765AD0A6;
      --theme-fill-tsp-brand-tertiary: #765AD073;
      --theme-fill-tsp-gray: #56565FA6;
      --theme-fill-black-none: #2D2D2F;


      --theme-label-tsp-brand-primary:  #765AD03D;
      --theme-label-tsp-brand-secondary:  #765AD01F;


      --theme-border-light:  #56565F33;
      --theme-border-primary:  #56565F52;
      --theme-border-quaternary:  #56565F73;
      --theme-border-active:  #7F58FD;
      --theme-border-white:  #FFFFFF0A;

      --theme-tab-fill: #56565F1F;
      --theme-tab-fill-active:  #77777E;

      --theme-tooltips-fill:  #000000F2;

      --theme-bg-white:  #202020;
      --theme-bg-gray-primary:  #252528;
      --theme-bg-gray-secondary:  #1B1B1D;
      --theme-bg-mask:  #00000073;
      --theme-bg-menu-white:  #282828;
      --theme-bg-menu-gray:  #2D2D2F;
      --theme-bg-tsp-gray-primary: #252528E6;
      --theme-bg-tsp-white-primary:  #25272D;
      --theme-bg-gray-nav: #2D2D2F;
      --theme-bg-tsp-white-secondary: #0000003D;

      --theme-function-info:  #0F76BC;
      --theme-function-success:  #278056;
      --theme-function-warning: #B07807;
      --theme-function-error:  #8E2827;
      --theme-function-error-border: #742525;
      --theme-function-warning-light: #443518;
      --theme-function-warning-border: #634B1B;

      --theme-shadow-s1: rgba(0, 0, 0, 0.24);
      --theme-shadow-s2: rgba(0, 0, 0, 0.32);
      --theme-shadow-s3: rgba(0, 0, 0, 0.45);
    }
}


.monica-writing-entry-btn-wrapper {
  position: absolute;
  right: 9px;
  bottom: 2px;
  pointer-events: all;
  user-select: none;
  -webkit-user-drag: none;
}

.monica-writing-entry-btn {
  position: relative;
  height: 28px;
  transition: all 0.2s ease-in-out;
  border-radius: 28px;
  background: var(--theme-bg-white);
  box-shadow: 0px 1px 4px 0px var(--theme-shadow-s2), 0px 0px 1px 0px var(--theme-shadow-s3);
  overflow: hidden;
}

.monica-writing-clickable-box {
  position: absolute;
  right: 0;
  bottom: 0;
  height: 100%;
  display: flex;
  align-items: center;
  gap: 2px;
}

.monica-writing-clickable-group {
  display: inline-flex;
  align-items: center;
  gap: 2px;
}

.monica-writing-clickable-item {
  cursor: pointer;
  user-select: none;
  -webkit-user-drag: none;
  display: flex;
  flex-direction: row;
  justify-content: center;
  align-items: center;
  box-sizing: border-box;
  height: 24px;
  padding: 3px;
  border-radius: 12px;
  color: var(--theme-icon-disable);
  transition: all 0.2s ease-in-out;
}

.monica-writing-clickable-item-bg:hover {
  background: var(--theme-border-primary);
}

.monica-writing-clickable-item.monica-writing-off:hover {
  color: var(--theme-text-brand);
}

.monica-writing-clickable-item.monica-writing-writing {
  color: var(--theme-text-brand);
}

.monica-writing-clickable-item.monica-writing-open {
  color: var(--theme-text-brand);
  opacity: 0.5;
}

.monica-writing-divider {
  background-color: var(--theme-border-light);
  min-width: 1px;
  height: 12px;
}


.monica-writing-grammar-checking-content {
  min-width: 18px;
  height: 18px;
  display: flex;
  box-sizing: border-box;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  border-radius: 16px 16px 6px 16px;
  color: var(--theme-text-white-primary);
  white-space: nowrap;
}
.monica-writing-grammar-checking-loading {
  background: var(--theme-icon-brand);
}

.monica-writing-tooltip_wrapper {
  z-index: 9999;
}



.monica-writing-grammar-checking-content.monica-writing-grammar-checking-has-result {
  background: var(--theme-function-error);
  padding: 2px;
}

.monica-writing-grammar-checking-content.monica-writing-grammar-checking-result-than-100 {
    border-radius: 16px 8px 3px 16px;
    padding: 2px;
}

.monica-writing-grammar-checking-result {
  color: var(--theme-text-white-primary);
  font-size: 12px;
  font-style: normal;
  font-weight: 600;
  line-height: 16px;
}

.monica-writing-grammar-checking-icon {
  animation: monica-writing-grammar-checking-icon-rotate 1s linear infinite;
}

@keyframes monica-writing-grammar-checking-icon-rotate {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }

}


.monica-writing-caret {
  width: 1.5px;
  background-color: var(--theme-border-active);
  pointer-events: none;
  position: absolute;
  border-radius: 1px;
}
.monica-writing-caret-head {
  background-color: var(--theme-border-active);
  width: 6px;
  height: 6px;
  border-radius: 6px;
  position: absolute;
  left: -2.25px;
}
@media print {
  .monica-writing-entry-btn {
    display: none;
  }
}

.monica-writing-primary-btn {
  box-sizing: border-box;
  padding: 4px 8px;
  font-size: 14px;
  line-height: 24px;
  color: var(--theme-text-white-primary);
  background: var(--theme-btn-fill-primary);
  border-radius: 8px;
  display: flex;
  justify-content: center;
  align-items: center;
  cursor: pointer;
  transition: all 0.2s ease-in-out;
}

.monica-writing-primary-btn:hover {
  background: var(--theme-btn-fill-primary-hover);
}

.monica-writing-primary-btn:active {
  background: var(--theme-btn-fill-primary-active);
}

.monica-writing-text-btn {
  font-size: 14px;
  line-height: 24px;
  color: var(--theme-text-tertiary);
  cursor: pointer;
  transition: all 0.2s ease-in-out;
  padding: 4px 8px;
  border-radius: 8px;
  display: flex;
  justify-content: center;
  align-items: center;
  width: 100%;
}

.monica-writing-text-btn:hover,
.monica-writing-text-btn:active {
  color: var(--theme-fill-tsp-components-secondary);
}

.monica-writing-gc-guide {
  position: absolute;
  right: 0;
  bottom: 30px;
  width: 300px;
  min-height: 100px;
  border-radius: 20px;
  background: var(--theme-bg-white);
  box-shadow: var(--theme-box-shadow-s1);
  padding: 16px;
  display: flex;
  flex-direction: column;
  gap: 12px;
  user-select: unset;
}

.monica-writing-gc-guide-header {
  display: flex;
  justify-content: space-between;
  gap: 12px;
}

.monica-writing-gc-guide-title {
  flex: 1;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 16px;
}

.monica-writing-gc-guide-close {
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  cursor: pointer;
  width: 24px;
  height: 24px;
  border-radius: 8px;
  color: var(--theme-text-quaternary);
}

.monica-writing-gc-guide-close:hover {
  background: var(--theme-fill-tsp-components-secondary);
}

.monica-writing-gc-guide-content {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.monica-writing-gc-guide-msg {
  font-size: 14px;
  line-height: 22px;
  color: var(--theme-text-primary);
}

.monica-writing-gc-guide-img {
  padding: 0 20px;
}

.monica-writing-gc-guide-img img {
  width: 100%;
  height: auto;
}

.monica-writing-gc-guide-footer {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
}

.monica-writing-gc-guide-footer .monica-writing-primary-btn,
.monica-writing-gc-guide-footer .monica-writing-subscribe-btn {
  width: 100%;
}

.monica-writing-gc-setting-guide {
  width: auto;
}

.monica-writing-gc-setting-guide .monica-writing-gc-guide-footer {
  align-items: flex-end;
}

.monica-writing-gc-setting-guide .monica-writing-primary-btn {
  width: auto;
  min-width: 60px;
}

.monica-writing-gc-guide-setting {
  color: var(--theme-text-brand);
  cursor: pointer;
}

.monica-writing-gc-guide-setting:hover {
  opacity: 0.8;
}

1. Overview of CCAR Modeling:

Purpose: CCAR is a regulatory framework introduced by the Federal Reserve to assess, regulate, and supervise large banks to ensure they have robust capital planning processes and adequate capital to withstand economic and financial stress.
Components:
Scenario Analysis: Evaluate the impact of hypothetical adverse economic conditions.
Capital Planning: Determine the necessary capital buffer to remain solvent during stress periods.
Risk Assessment: Identify and quantify various risks, including credit risk, market risk, and operational risk.
2. Python Code for CCAR Modeling:

a. Data Preparation:

Data Collection: Gather historical financial data, macroeconomic indicators, and other relevant data points.
Data Cleaning: Handle missing values, outliers, and inconsistencies.
python
Copy code
import pandas as pd
import numpy as np

# Load data
financial_data = pd.read_csv('financial_data.csv')
macroeconomic_data = pd.read_csv('macroeconomic_data.csv')

# Data cleaning
financial_data.fillna(method='ffill', inplace=True)
macroeconomic_data.fillna(method='bfill', inplace=True)
b. Scenario Analysis:

Define Scenarios: Create baseline, adverse, and severely adverse scenarios based on macroeconomic variables.
Forecasting: Use statistical models to forecast financial metrics under each scenario.
python
Copy code
from statsmodels.tsa.arima_model import ARIMA

# Define scenarios
scenarios = {
    'baseline': [1.5, 2.0, 2.5],  # Example GDP growth rates
    'adverse': [0.5, 1.0, 1.5],
    'severely_adverse': [-1.0, 0.0, 0.5]
}

# Forecast financial metrics
def forecast_metrics(data, scenario):
    model = ARIMA(data, order=(5,1,0))
    model_fit = model.fit(disp=0)
    forecast = model_fit.forecast(steps=len(scenario))
    return forecast[0]

financial_forecasts = {key: forecast_metrics(financial_data['metric'], val) for key, val in scenarios.items()}
c. Capital Planning:

Capital Adequacy: Calculate the capital requirement for each scenario using stress testing results.
Buffer Calculation: Determine additional capital buffers needed to maintain solvency.
python
Copy code
def calculate_capital_requirement(forecasts, risk_weight):
    capital_requirement = forecasts * risk_weight
    return capital_requirement

risk_weight = 0.08  # Example risk weight
capital_requirements = {key: calculate_capital_requirement(val, risk_weight) for key, val in financial_forecasts.items()}
d. Risk Assessment:

Credit Risk: Evaluate the potential for loan defaults.
Market Risk: Assess the impact of market fluctuations on asset values.
Operational Risk: Consider the risk of loss due to failed internal processes or systems.
python
Copy code
def evaluate_credit_risk(financial_data):
    default_prob = financial_data['default_rate'].mean()
    expected_loss = financial_data['loan_amount'] * default_prob
    return expected_loss

def evaluate_market_risk(financial_data, market_scenarios):
    market_loss = []
    for scenario in market_scenarios:
        loss = financial_data['market_value'] * (1 - scenario)
        market_loss.append(loss)
    return np.mean(market_loss)

credit_risk = evaluate_credit_risk(financial_data)
market_risk = evaluate_market_risk(financial_data, scenarios['severely_adverse'])
3. Detailed Discussion Points:

a. Importance of CCAR:

Ensures that banks have sufficient capital to absorb losses during economic downturns.
Promotes robust risk management practices.
Enhances transparency and confidence in the banking system.
b. Data Challenges:

Ensuring data quality and consistency across different sources.
Handling missing or incomplete data.
Aligning historical data with forecasted scenarios.
c. Model Selection:

Choosing appropriate statistical models (e.g., ARIMA, VAR) for forecasting.
Balancing model complexity with interpretability and performance.
Validating and back-testing models to ensure accuracy.
d. Scenario Definition:

Defining realistic and comprehensive stress scenarios.
Incorporating regulatory guidelines and economic forecasts.
Continuously updating scenarios based on emerging risks and trends.
e. Risk Management:

Integrating CCAR results into the bank’s overall risk management framework.
Using CCAR outcomes to inform strategic decisions, such as capital allocation and risk mitigation.
Communicating results to stakeholders, including regulators, investors, and senior management.
f. Regulatory Compliance:

Ensuring adherence to regulatory requirements and guidelines.
Preparing detailed documentation and reports for regulatory submissions.
Engaging with regulators to address any concerns or questions.
By following these steps and considerations, large banks can effectively implement
CCAR modeling using Python to ensure they are well-prepared for potential economic
stresses and maintain adequate capital levels.




<!-- template.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Table with Select2</title>
    <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>
</head>
<body>
    <h1>Data Table with Select2</h1>

    <select id="multiselect" multiple="multiple" style="width: 300px;">
        {% for option in options %}
            <option value="{{ option }}">{{ option }}</option>
        {% endfor %}
    </select>

    <div id="table-container">
        {{ table_html|safe }}
    </div>

    <script>
        $(document).ready(function() {
            $('#multiselect').select2();

            $('#multiselect').on('change', function() {
                var selectedOptions = $(this).val();
                $.ajax({
                    url: '{% url "update_table" %}',
                    method: 'POST',
                    data: {
                        'selected_options': JSON.stringify(selectedOptions),
                        'csrfmiddlewaretoken': '{{ csrf_token }}'
                    },
                    success: function(response) {
                        $('#table-container').html(response.table_html);
                    }
                });
            });
        });
    </script>
</body>
</html>



# views.py
from django.shortcuts import render
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
import pandas as pd
import json

# Sample DataFrame
df = pd.DataFrame({
    'Name': ['Alice', 'Bob', 'Charlie', 'David'],
    'Age': [25, 30, 35, 40],
    'City': ['New York', 'London', 'Paris', 'Tokyo']
})

def index(request):
    options = df['City'].unique().tolist()
    table_html = df.to_html(classes='table table-striped', index=False)
    return render(request, 'template.html', {'options': options, 'table_html': table_html})

@csrf_exempt
def update_table(request):
    if request.method == 'POST':
        selected_options = json.loads(request.POST.get('selected_options', '[]'))

        if selected_options:
            filtered_df = df[df['City'].isin(selected_options)]
        else:
            filtered_df = df

        table_html = filtered_df.to_html(classes='table table-striped', index=False)
        return JsonResponse({'table_html': table_html})

    return JsonResponse({'error': 'Invalid request method'})




from django.shortcuts import render
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
import pandas as pd
import json

# Sample DataFrame
df = pd.DataFrame({
    'Name': ['Alice', 'Bob', 'Charlie', 'David'],
    'Age': [25, 30, 35, 40],
    'City': ['New York', 'London', 'Paris', 'Tokyo']
})

@csrf_exempt
def data_view(request):
    if request.method == 'POST':
        # Handle AJAX request
        selected_options = json.loads(request.POST.get('selected_options', '[]'))

        if selected_options:
            filtered_df = df[df['City'].isin(selected_options)]
        else:
            filtered_df = df

        table_html = filtered_df.to_html(classes='table table-striped', index=False)
        return JsonResponse({'table_html': table_html})

    else:
        # Handle initial page load
        options = df['City'].unique().tolist()
        table_html = df.to_html(classes='table table-striped', index=False)
        context = {
            'options': options,
            'table_html': table_html
        }
        return render(request, 'data_template.html', context)















<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MI Chart</title>
    <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>
</head>
<body>
    <form id="filter-form">
        <select class="select2" multiple name="Product">
            {% for option in list1 %}
                <option value="{{ option }}">{{ option }}</option>
            {% endfor %}
        </select>

        <select class="select2" multiple name="Category">
            {% for option in list2 %}
                <option value="{{ option }}">{{ option }}</option>
            {% endfor %}
        </select>

        <select class="select2" multiple name="Price_Range">
            {% for option in list3 %}
                <option value="{{ option }}">{{ option }}</option>
            {% endfor %}
        </select>

        <select class="select2" multiple name="Stock_Level">
            {% for option in list4 %}
                <option value="{{ option }}">{{ option }}</option>
            {% endfor %}
        </select>

        <select class="select2" multiple name="Rating">
            {% for option in list5 %}
                <option value="{{ option }}">{{ option }}</option>
            {% endfor %}
        </select>

        <select class="select2" multiple name="Supplier">
            {% for option in list6 %}
                <option value="{{ option }}">{{ option }}</option>
            {% endfor %}
        </select>

        <button type="submit">Apply Filters</button>
    </form>

    <div id="table-container">
        {{ table_html|safe }}
    </div>

    <script>
        $(document).ready(function() {
            $('.select2').select2();

            $('#filter-form').on('submit', function(e) {
                e.preventDefault();
                var selectedOptions = {};
                $(this).find('select').each(function() {
                    selectedOptions[$(this).attr('name')] = $(this).val();
                });

                $.ajax({
                    url: '{% url "mi_chart" %}',
                    method: 'POST',
                    data: {
                        selected_options: JSON.stringify(selectedOptions)
                    },
                    success: function(response) {
                        $('#table-container').html(response.table_html);
                    }
                });
            });
        });
    </script>
</body>
</html>



from django.shortcuts import render
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
import pandas as pd
import json

# Sample DataFrame
df = pd.DataFrame({
    'Product': ['Laptop', 'Phone', 'Tablet', 'Desktop', 'Smartwatch'],
    'Category': ['Electronics', 'Electronics', 'Electronics', 'Electronics', 'Wearables'],
    'Price': [1000, 800, 500, 1200, 300],
    'Stock': [50, 100, 75, 30, 150],
    'Rating': [4.5, 4.3, 4.0, 4.2, 3.8],
    'Supplier': ['SupplierA', 'SupplierB', 'SupplierC', 'SupplierA', 'SupplierB']
})

@csrf_exempt
def mi_chart(request):
    # Define options for dropdowns
    list1 = ['Laptop', 'Phone', 'Tablet', 'Desktop', 'Smartwatch']
    list2 = ['Electronics', 'Wearables']
    list3 = ['0-500', '501-1000', '1001+']
    list4 = ['Low (0-50)', 'Medium (51-100)', 'High (101+)']
    list5 = ['3.5-4.0', '4.1-4.5', '4.6+']
    list6 = ['SupplierA', 'SupplierB', 'SupplierC']

    if request.method == 'POST':
        selected_options = json.loads(request.POST.get('selected_options', '{}'))

        filtered_df = df.copy()

        if selected_options.get('Product'):
            filtered_df = filtered_df[filtered_df['Product'].isin(selected_options['Product'])]

        if selected_options.get('Category'):
            filtered_df = filtered_df[filtered_df['Category'].isin(selected_options['Category'])]

        if selected_options.get('Price_Range'):
            price_filters = []
            for range_str in selected_options['Price_Range']:
                if range_str == '0-500':
                    price_filters.append((filtered_df['Price'] >= 0) & (filtered_df['Price'] <= 500))
                elif range_str == '501-1000':
                    price_filters.append((filtered_df['Price'] > 500) & (filtered_df['Price'] <= 1000))
                elif range_str == '1001+':
                    price_filters.append(filtered_df['Price'] > 1000)
            if price_filters:
                filtered_df = filtered_df[pd.concat(price_filters, axis=1).any(axis=1)]

        if selected_options.get('Stock_Level'):
            stock_filters = []
            for level in selected_options['Stock_Level']:
                if level == 'Low (0-50)':
                    stock_filters.append((filtered_df['Stock'] >= 0) & (filtered_df['Stock'] <= 50))
                elif level == 'Medium (51-100)':
                    stock_filters.append((filtered_df['Stock'] > 50) & (filtered_df['Stock'] <= 100))
                elif level == 'High (101+)':
                    stock_filters.append(filtered_df['Stock'] > 100)
            if stock_filters:
                filtered_df = filtered_df[pd.concat(stock_filters, axis=1).any(axis=1)]

        if selected_options.get('Rating'):
            rating_filters = []
            for range_str in selected_options['Rating']:
                if range_str == '3.5-4.0':
                    rating_filters.append((filtered_df['Rating'] >= 3.5) & (filtered_df['Rating'] <= 4.0))
                elif range_str == '4.1-4.5':
                    rating_filters.append((filtered_df['Rating'] > 4.0) & (filtered_df['Rating'] <= 4.5))
                elif range_str == '4.6+':
                    rating_filters.append(filtered_df['Rating'] > 4.5)
            if rating_filters:
                filtered_df = filtered_df[pd.concat(rating_filters, axis=1).any(axis=1)]

        if selected_options.get('Supplier'):
            filtered_df = filtered_df[filtered_df['Supplier'].isin(selected_options['Supplier'])]

        # Transform the DataFrame (example: add a 'Total Value' column)
        filtered_df['Total Value'] = filtered_df['Price'] * filtered_df['Stock']

        # Convert DataFrame to HTML with custom classes
        table_html = filtered_df.to_html(classes='custom-table', index=False)

        return JsonResponse({'table_html': table_html})

    else:
        # Initial page load
        table_html = df.to_html(classes='custom-table', index=False)
        context = {
            'list1': list1,
            'list2': list2,
            'list3': list3,
            'list4': list4,
            'list5': list5,
            'list6': list6,
            'table_html': table_html
        }
        return render(request, 'data_template.html', context)












<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MI Chart</title>
    <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>
</head>
<body>
    <div id="filter-form">
        <select class="select2" multiple name="Product">
            {% for option in list1 %}
                <option value="{{ option }}">{{ option }}</option>
            {% endfor %}
        </select>

        <select class="select2" multiple name="Category">
            {% for option in list2 %}
                <option value="{{ option }}">{{ option }}</option>
            {% endfor %}
        </select>

        <select class="select2" multiple name="Price_Range">
            {% for option in list3 %}
                <option value="{{ option }}">{{ option }}</option>
            {% endfor %}
        </select>

        <select class="select2" multiple name="Stock_Level">
            {% for option in list4 %}
                <option value="{{ option }}">{{ option }}</option>
            {% endfor %}
        </select>

        <select class="select2" multiple name="Rating">
            {% for option in list5 %}
                <option value="{{ option }}">{{ option }}</option>
            {% endfor %}
        </select>

        <select class="select2" multiple name="Supplier">
            {% for option in list6 %}
                <option value="{{ option }}">{{ option }}</option>
            {% endfor %}
        </select>
    </div>

    <div id="table-container">
        {{ table_html|safe }}
    </div>

    <script>
        $(document).ready(function() {
            $('.select2').select2();

            function updateTable() {
                var selectedOptions = {};
                $('#filter-form select').each(function() {
                    selectedOptions[$(this).attr('name')] = $(this).val();
                });

                $.ajax({
                    url: '{% url "mi_chart" %}',
                    method: 'POST',
                    data: {
                        selected_options: JSON.stringify(selectedOptions)
                    },
                    success: function(response) {
                        $('#table-container').html(response.table_html);
                    }
                });
            }

            // Trigger update when any select changes
            $('.select2').on('change', function() {
                updateTable();
            });
        });
    </script>
</body>
</html>










import os
import json
import pandas as pd
from django.http import JsonResponse

def mi_chart(request):
    if request.method == 'POST':
        # Load selected items from the POST request
        selected_items = json.loads(request.POST.get('selectedItems', '{}'))
        list_of_selected = []

        # Populate list_of_selected with items from selected_items
        for category, items in selected_items.items():
            if items:
                list_of_selected.append(items)

        # Extract selected values
        Organisational_unit_level_1_selected = list_of_selected[0]
        Organisational_unit_level_2_selected = list_of_selected[1]
        Organisational_unit_level_3_selected = list_of_selected[2]
        Country_of_Exposure_selected = list_of_selected[3]
        Asset_class_selected = list_of_selected[4]
        Product_Type_selected = list_of_selected[5]
        Basel_Approach_selected = list_of_selected[6]
        ST_scenario_selected = list_of_selected[7]

        # Fetch folders and subfolders
        folders = get_folders()
        selected_folder = request.GET.get("folder", None)
        selected_subfolder = request.GET.get("subfolder", None)
        subfolders = get_subfolders(selected_folder) if selected_folder else []

        if selected_folder and selected_subfolder:
            # Define folder path and get Excel files
            folder_path = os.path.join(FOLDER_PATH, selected_folder, selected_subfolder)
            excel_files = [f for f in os.listdir(folder_path) if f.endswith('.xlsx')]

            # Read Excel files based on filename conditions
            lic_hbap_first_run = lic_hbap_last_run = lpact_hbap_data = None
            lic_non_hbap_first_run = lic_non_hbap_last_run = lpact_non_hbap_data = None
            rwa_hbap_first_run = rwa_hbap_last_run = None
            rwa_non_hbap_first_run = rwa_non_hbap_last_run = None
            lic_views_previous = rwa_views_previous = None

            for excel_file in excel_files:
                file_path = os.path.join(folder_path, excel_file)

                # Read and process various sheets
                if all(string in excel_file for string in ["LIC", "HBAP", "FirstRun"]):
                    lic_hbap_first_run = pd.read_excel(file_path, sheet_name="LPACT_OL_YTD_QTR_Final")
                if all(string in excel_file for string in ["LIC", "HBAP", "LastRun"]):
                    lic_hbap_last_run = pd.read_excel(file_path, sheet_name="LPACT_OL_YTD_QTR_Final")
                if all(string in excel_file for string in ["LPACT", "HBAP"]):
                    lpact_hbap_data = pd.read_excel(file_path, sheet_name="PD series")
                if all(string in excel_file for string in ["LIC", "NonHBAP", "FirstRun"]):
                    lic_non_hbap_first_run = pd.read_excel(file_path, sheet_name="LPACT_OL_YTD_QTR_Final")
                if all(string in excel_file for string in ["LIC", "NonHBAP", "LastRun"]):
                    lic_non_hbap_last_run = pd.read_excel(file_path, sheet_name="LPACT_OL_YTD_QTR_Final")
                if all(string in excel_file for string in ["LPACT", "Non", "HBAP"]):
                    lpact_non_hbap_data = pd.read_excel(file_path, sheet_name="PD series")
                if all(string in excel_file for string in ["MI", "HBAP", "FirstRun"]):
                    rwa_hbap_first_run = pd.read_excel(file_path, sheet_name="Temp_RRM_Final_OL")
                if all(string in excel_file for string in ["MI", "HBAP", "LastRun"]):
                    rwa_hbap_last_run = pd.read_excel(file_path, sheet_name="Temp_RRM_Final_OL")
                if all(string in excel_file for string in ["MI", "Non", "HBAP", "FirstRun"]):
                    rwa_non_hbap_first_run = pd.read_excel(file_path, sheet_name="Temp_RRM_Final_OL")
                if all(string in excel_file for string in ["MI", "Non", "HBAP", "LastRun"]):
                    rwa_non_hbap_last_run = pd.read_excel(file_path, sheet_name="Temp_RRM_Final_OL")
                if all(string in excel_file for string in ["LIC", "Previous"]):
                    lic_views_previous = pd.read_excel(file_path, sheet_name="LIC_raw1")
                if all(string in excel_file for string in ["RWA", "Previous"]):
                    rwa_views_previous = pd.read_excel(file_path, sheet_name="RWA_raw1")

            # Define columns to keep for further processing
            columns_to_keep = [
                "ST", "Credit_Risk_Type", "Organisational_unit_level_1", "Organisational_unit_level_2",
                "Organisational_unit_level_3", "Country_of_Exposure", "Asset_class", "Product_Type", "Security",
                "Basel_Approach", "scenario", "Projection_Period", "Type", "IFRS9_Stage", "Balance", "IFRS9_12M_PD",
                "IFRS9_LGD", "IFRS9_Lifetime_PD", "Cumm_Gross_WO", "Provisions_orig", "Provisions", "Loss_at_WO_orig",
                "Loss_at_WO", "Delta_Provisions", "LIC_Orig", "LIC", "Mapping1"
            ]

            # Process and merge LIC data for HBAP and Non-HBAP
            lic_hbap_merged = process_lic_data(lic_hbap_first_run, lic_hbap_last_run, columns_to_keep)
            lic_non_hbap_merged = process_lic_data(lic_non_hbap_first_run, lic_non_hbap_last_run, columns_to_keep)
            lic_df = pd.concat([lic_hbap_merged, lic_non_hbap_merged, lic_views_previous])

            # Process and merge RWA data for HBAP and Non-HBAP
            rwa_hbap_merged = process_rwa_data(rwa_hbap_first_run, rwa_hbap_last_run, columns_to_keep)
            rwa_non_hbap_merged = process_rwa_data(rwa_non_hbap_first_run, rwa_non_hbap_last_run, columns_to_keep)
            rwa_df = pd.concat([rwa_hbap_merged, rwa_non_hbap_merged, rwa_views_previous])

            # Filter and update DataFrame based on selected values
            lic_df = filter_dataframe(lic_df, Organisational_unit_level_1_selected, Organisational_unit_level_2_selected,
                                      Organisational_unit_level_3_selected, Country_of_Exposure_selected, Asset_class_selected,
                                      Product_Type_selected, Basel_Approach_selected, ST_scenario_selected)

            # Convert DataFrame to HTML
            table_html = lic_df.to_html(classes='table table-striped', index=False, escape=False)

            return JsonResponse({"table_html": table_html})

        return JsonResponse({"message": "No data available for the selected folder/subfolder"}, status=404)

    return JsonResponse({"message": "Invalid request method"}, status=400)

def process_lic_data(first_run_df, last_run_df, columns_to_keep):
    if first_run_df is None or last_run_df is None:
        return pd.DataFrame()

    new_column_names = {
        'Countryofexposure': 'Country_of_Exposure',
        'projection_period': 'Projection_Period',
        'LIC_Orig': 'LIC_orig'
    }
    first_run_df = first_run_df.loc[:, columns_to_keep].rename(columns=new_column_names)
    last_run_df = last_run_df.loc[:, columns_to_keep].rename(columns=new_column_names)
    first_run_df = first_run_df[first_run_df["Type"] != "YTD"]
    last_run_df = last_run_df[last_run_df["Type"] != "YTD"]
    last_run_df["scenario"] = last_run_df["scenario"].replace('Annual cyclical scenario', 'Stress')

    # Merge first and last run data
    lic_key_columns = [
        "Credit_Risk_Type", "Organisational_unit_level_1", "Organisational_unit_level_2",
        "Organisational_unit_level_3", "Country_of_Exposure", "Asset_class",
        "Product_Type", "Security", "Basel_Approach", "scenario", "Projection_Period", "Type", "IFRS9_Stage"
    ]
    lic_first_run_columns = ['Balance', 'LIC_Orig', 'Delta_Provisions']
    lic_last_run_columns = ['Provisions', 'LIC', 'Cumm_Gross_WO', 'Loss_at_WO_orig', 'Loss_at_WO']

    first_run_df_renamed = first_run_df[lic_key_columns + lic_first_run_columns]
    last_run_df_renamed = last_run_df[lic_key_columns + lic_last_run_columns]

    merged_df = pd.merge(first_run_df_renamed, last_run_df_renamed, on=lic_key_columns, how='inner')
    return merged_df

def process_rwa_data(first_run_df, last_run_df, columns_to_keep):
    if first_run_df is None or last_run_df is None:
        return pd.DataFrame()

    new_column_names = {
        'Countryofexposure': 'Country_of_Exposure',
        'projection_period': 'Projection_Period',
        'LIC_Orig': 'LIC_orig'
    }
    first_run_df = first_run_df.loc[:, columns_to_keep].rename(columns=new_column_names)
    last_run_df = last_run_df.loc[:, columns_to_keep].rename(columns=new_column_names)
    last_run_df["scenario"] = last_run_df["scenario"].replace('Annual cyclical scenario', 'Stress')

    # Merge first and last run data
    rwa_key_columns = [
        "Credit_Risk_Type", "Organisational_unit_level_1", "Organisational_unit_level_2",
        "Organisational_unit_level_3", "Country_of_Exposure", "Asset_class",
        "Product_Type", "Security", "Basel_Approach", "scenario", "Projection_Period", "Type", "IFRS9_Stage"
    ]
    rwa_first_run_columns = ['RWA_Orig', 'Balance', 'RWA_Overlay', 'Delta_Provisions']
    rwa_last_run_columns = ['RWA', 'Cumm_Gross_WO', 'Loss_at_WO_orig', 'Loss_at_WO']

    first_run_df_renamed = first_run_df[rwa_key_columns + rwa_first_run_columns]
    last_run_df_renamed = last_run_df[rwa_key_columns + rwa_last_run_columns]

    merged_df = pd.merge(first_run_df_renamed, last_run_df_renamed, on=rwa_key_columns, how='inner')
    return merged_df

def filter_dataframe(df, *selected_values):
    filters = [
        df["Organisational_unit_level_1"].isin(selected_values[0]),
        df["Organisational_unit_level_2"].isin(selected_values[1]),
        df["Organisational_unit_level_3"].isin(selected_values[2]),
        df["Country_of_Exposure"].isin(selected_values[3]),
        df["Asset_class"].isin(selected_values[4]),
        df["Product_Type"].isin(selected_values[5]),
        df["Basel_Approach"].isin(selected_values[6]),
        df["scenario"].isin(selected_values[7])
    ]
    for f in filters:
        df = df[f]
    return df





import os
import json
import pandas as pd
from django.http import JsonResponse
from django.shortcuts import render
from django.views.decorators.csrf import csrf_exempt

@csrf_exempt
def mi_chart(request):
    if request.method == 'POST':
        # Load selected items from the POST request
        selected_items = json.loads(request.POST.get('selectedItems', '{}'))
        list_of_selected = [items for category, items in selected_items.items() if items]

        # Extract selected values
        selected_values = list_of_selected[:8]  # Assuming 8 selection categories

        # Define folder paths
        FOLDER_PATH = "path/to/your/folder"  # Replace with your actual folder path
        selected_folder = request.GET.get("folder", "")
        selected_subfolder = request.GET.get("subfolder", "")
        folder_path = os.path.join(FOLDER_PATH, selected_folder, selected_subfolder)

        if selected_folder and selected_subfolder:
            excel_files = [f for f in os.listdir(folder_path) if f.endswith('.xlsx')]

            # Initialize DataFrames
            lic_dfs = []
            rwa_dfs = []

            columns_to_keep = [
                "ST", "Credit_Risk_Type", "Organisational_unit_level_1", "Organisational_unit_level_2",
                "Organisational_unit_level_3", "Country_of_Exposure", "Asset_class", "Product_Type", "Security",
                "Basel_Approach", "scenario", "Projection_Period", "Type", "IFRS9_Stage", "Balance", "IFRS9_12M_PD",
                "IFRS9_LGD", "IFRS9_Lifetime_PD", "Cumm_Gross_WO", "Provisions_orig", "Provisions", "Loss_at_WO_orig",
                "Loss_at_WO", "Delta_Provisions", "LIC_Orig", "LIC", "Mapping1"
            ]

            for excel_file in excel_files:
                file_path = os.path.join(folder_path, excel_file)

                if "LIC" in excel_file:
                    df = pd.read_excel(file_path, sheet_name="LPACT_OL_YTD_QTR_Final")
                    df = df.loc[:, columns_to_keep].rename(columns={
                        'Countryofexposure': 'Country_of_Exposure',
                        'projection_period': 'Projection_Period',
                        'LIC_Orig': 'LIC_orig'
                    })
                    df = df[df["Type"] != "YTD"]
                    df["scenario"] = df["scenario"].replace('Annual cyclical scenario', 'Stress')
                    lic_dfs.append(df)
                elif "MI" in excel_file:
                    df = pd.read_excel(file_path, sheet_name="Temp_RRM_Final_OL")
                    df = df.loc[:, columns_to_keep].rename(columns={
                        'Countryofexposure': 'Country_of_Exposure',
                        'projection_period': 'Projection_Period',
                        'LIC_Orig': 'LIC_orig'
                    })
                    df["scenario"] = df["scenario"].replace('Annual cyclical scenario', 'Stress')
                    rwa_dfs.append(df)

            # Combine all LIC and RWA DataFrames
            lic_df = pd.concat(lic_dfs, ignore_index=True)
            rwa_df = pd.concat(rwa_dfs, ignore_index=True)

            # Filter DataFrame based on selected values
            for i, column in enumerate([
                "Organisational_unit_level_1", "Organisational_unit_level_2", "Organisational_unit_level_3",
                "Country_of_Exposure", "Asset_class", "Product_Type", "Basel_Approach", "scenario"
            ]):
                if selected_values[i]:
                    lic_df = lic_df[lic_df[column].isin(selected_values[i])]
                    rwa_df = rwa_df[rwa_df[column].isin(selected_values[i])]

            # Convert DataFrame to HTML
            table_html = lic_df.to_html(classes='table table-striped table-bordered', index=False, escape=False)

            return JsonResponse({"table_html": table_html})

        return JsonResponse({"message": "No data available for the selected folder/subfolder"}, status=404)

    else:
        row_names = [
            'Gross Balance ($ MM)', 'Net Balance ($ MM)', 'Net Balance Proportion S1',
            'Net Balance Proportion S2', 'Net Balance Proportion S3', 'ECL ($ MM)',
            'ECL Original ($ MM)', 'ECL Rate', 'Loss at WO ($ MM)',
            'Loss at WO Original ($ MM)', 'LIC ($ MM)', 'LIC Original ($ MM)',
            'LIC overlay ($ MM)', 'LIC Rate', 'Coverage ratio', 'PD', 'LGD',
            'EAD ($ MM)', 'RWA ($ MM)', 'RWA Original ($ MM)', 'RWA Overlay ($ MM)',
            'RWA Density', 'EL($ MM)', 'EL Overlay ($MM)', 'EL Density'
        ]
        column_names = ['T0', 'T1', 'T2', 'T3', 'T4', 'T5']
        table_df = pd.DataFrame(index=row_names, columns=column_names)
        table_html = table_df.to_html(classes='table table-striped table-bordered', index=True)

        # You need to define these lists based on your data
        Organisational_unit_level_1_list = []  # Add your data here
        Organisational_unit_level_2_list = []  # Add your data here
        Organisational_unit_level_3_list = []  # Add your data here
        Country_of_Exposure_list = []  # Add your data here
        Asset_class_list = []  # Add your data here
        Product_Type_list = []  # Add your data here
        Basel_Approach_list = []  # Add your data here
        ST_scenario_combo = []  # Add your data here

        context1 = {
            'Organisational_unit_level_1_list': Organisational_unit_level_1_list,
            'Organisational_unit_level_2_list': Organisational_unit_level_2_list,
            'Organisational_unit_level_3_list': Organisational_unit_level_3_list,
            'Country_of_Exposure_list': Country_of_Exposure_list,
            'Asset_class_list': Asset_class_list,
            'Product_Type_list': Product_Type_list,
            'Basel_Approach_list': Basel_Approach_list,
            'ST_scenario_combo': ST_scenario_combo,
            'table_html': table_html
        }

        return render(request, 'mi_templates/mi_chart.html', context1)

















import json
import os
import pandas as pd

def mi_chart(request):
    if request.method == 'POST':
        selected_items = json.loads(request.POST.get('selectedItems', '{}'))
        print(selected_items)
        list_of_selected = []

        for category, items in selected_items.items():
            if items:
                print(category)
                category1 = items
                list_of_selected.append(category1)

        Organisational_unit_level_1_selected = list_of_selected[0]
        Organisational_unit_level_2_selected = list_of_selected[1]
        Organisational_unit_level_3_selected = list_of_selected[2]
        Country_of_Exposure_selected = list_of_selected[3]
        Asset_class_selected = list_of_selected[4]
        Product_Type_selected = list_of_selected[5]
        Basel_Approach_selected = list_of_selected[6]
        ST_scenario_selected = list_of_selected[7]

        folders = get_folders()
        selected_folder = request.GET.get("folder", None)
        selected_subfolder = request.GET.get("subfolder", None)
        subfolders = get_subfolders(selected_folder) if selected_folder else []

        row_names = ['Gross Balance ($ MM)', 'Net Balance ($ MM)', 'Net Balance Proportion S1', 'Net Balance Proportion S2', 'Net Balance Proportion S3', 'ECL ($ MM)', 'ECL Original ($ MM)', 'ECL Rate', 'Loss at WO ($ MM)', 'Loss at WO Original ($ MM)', 'LIC ($ MM)', 'LIC Original ($ MM)', 'LIC overlay ($ MM)', 'LIC Rate', 'Coverage ratio', 'PD', 'LGD', 'EAD ($ MM)', 'RWA ($ MM)', 'RWA Original ($ MM)', 'RWA Overlay ($ MM)', 'RWA Density', 'EL ($ MM)', 'EL Overlay ($ MM)', 'EL Density']
        column_names = ['T0', 'T1', 'T2', 'T3', 'T4', 'T5']
        table_df1 = pd.DataFrame(index=row_names, columns=column_names)
        table_df = pd.DataFrame(index=row_names)

        if selected_folder and selected_subfolder:
            folder_path = os.path.join(FOLDER_PATH, selected_folder, selected_subfolder)
            excel_files = [f for f in os.listdir(folder_path) if f.endswith('.xlsx')]

            dataframes = {}
            for excel_file in excel_files:
                file_path = os.path.join(folder_path, excel_file)
                sheet_criteria = [
                    (["LIC", "HBAP", "FirstRun"], "lic_hbap_first_run"),
                    (["LIC", "HBAP", "LastRun"], "lic_hbap_last_run"),
                    (["LPACT", "HBAP"], "lpact_hbap_data"),
                    (["LIC", "NonHBAP", "FirstRun"], "lic_non_hbap_first_run"),
                    (["LIC", "NonHBAP", "LastRun"], "lic_non_hbap_last_run"),
                    (["LPACT", "Non", "HBAP"], "lpact_non_hbap_data"),
                    (["MI", "HBAP", "FirstRun"], "rwa_hbap_first_run"),
                    (["MI", "HBAP", "LastRun"], "rwa_hbap_last_run"),
                    (["MI", "Non", "HBAP", "FirstRun"], "rwa_non_hbap_first_run"),
                    (["MI", "Non", "HBAP", "LastRun"], "rwa_non_hbap_last_run"),
                    (["LIC", "Previous"], "lic_views_previous"),
                    (["LIC", "Previous"], "rwa_views_previous")
                ]

                for criteria, var_name in sheet_criteria:
                    if all(string in excel_file for string in criteria):
                        dataframes[var_name] = pd.read_excel(file_path, sheet_name="LPACT_OL_YTD_QTR_Final")

            columns_to_keep = ["ST", "Credit_Risk_Type", "Organisational_unit_level_1", "Organisational_unit_level_2", "Organisational_unit_level_3", "Country_of_Exposure", "Asset_class", "Product_Type", "Security", "Basel_Approach", "scenario", "Projection_Period", "Type", "IFRS9_Stage", "Balance", "IFRS9_12M_PD", "IFRS9_LGD", "IFRS9_Lifetime_PD", "Cumm_Gross_WO", "Provisions_orig", "Provisions", "Loss_at_WO_orig", "Loss_at_WO", "Delta_Provisions", "LIC_Orig", "LIC", "Mapping1"]

            for var_name in ["lic_hbap_first_run", "lic_hbap_last_run", "lic_non_hbap_first_run", "lic_non_hbap_last_run"]:
                if var_name in dataframes:
                    dataframes[var_name] = dataframes[var_name].loc[:, columns_to_keep]

            new_column_names = {'Countryofexposure': 'Country_of_Exposure', 'projection_period': 'Projection_Period', 'LIC_Orig': 'LIC_orig'}
            for var_name in ["lic_hbap_first_run", "lic_hbap_last_run", "lic_non_hbap_first_run", "lic_non_hbap_last_run"]:
                if var_name in dataframes:
                    dataframes[var_name] = dataframes[var_name].rename(columns=new_column_names)

            for var_name in ["lic_hbap_first_run", "lic_hbap_last_run", "lic_non_hbap_first_run", "lic_non_hbap_last_run"]:
                if var_name in dataframes:
                    dataframes[var_name] = dataframes[var_name][dataframes[var_name]["Type"] != "YTD"]

            if "lic_hbap_last_run" in dataframes:
                dataframes["lic_hbap_last_run"]["scenario"] = dataframes["lic_hbap_last_run"]["scenario"].replace('Annual cyclical scenario', 'Stress')
            if "lic_non_hbap_last_run" in dataframes:
                dataframes["lic_non_hbap_last_run"]["scenario"] = dataframes["lic_non_hbap_last_run"]["scenario"].replace('Annual cyclical scenario', 'Stress')

            for var_name in ["lpact_hbap_data", "lpact_non_hbap_data"]:
                if var_name in dataframes:
                    dataframes[var_name]["date"] = dataframes[var_name]["date"].str.replace('T', '')
                    dataframes[var_name]["date"] = pd.to_numeric(dataframes[var_name]["date"])

            lic_key_columns = ["Credit_Risk_Type", "Organisational_unit_level_1", "Organisational_unit_level_2", "Organisational_unit_level_3", "Country_of_Exposure", "Asset_class", "Product_Type", "Security", "Basel_Approach", "scenario", "Projection_Period", "Type", "IFRS9_Stage"]
            lic_first_run_columns = ['Provisions_orig', 'Loss_at_WO_orig', 'LIC_orig']
            columns_to_merge = lic_key_columns + lic_first_run_columns

            if "lic_hbap_last_run" in dataframes and "lic_hbap_first_run" in dataframes:
                lic_hbap_merged_df = pd.merge(dataframes["lic_hbap_last_run"], dataframes["lic_hbap_first_run"][columns_to_merge], on=lic_key_columns, how='left', suffixes=('', '_run_columns'))
                for col in lic_first_run_columns:
                    lic_hbap_merged_df[col] = lic_hbap_merged_df[f'{col}_run_columns']
                    lic_hbap_merged_df.drop(columns=[f'{col}_run_columns'], inplace=True)

            if "lic_non_hbap_last_run" in dataframes and "lic_non_hbap_first_run" in dataframes:
                lic_non_hbap_merged_df = pd.merge(dataframes["lic_non_hbap_last_run"], dataframes["lic_non_hbap_first_run"][columns_to_merge], on=lic_key_columns, how='left', suffixes=('', '_run_columns'))
                for col in lic_first_run_columns:
                    lic_non_hbap_merged_df[col] = lic_non_hbap_merged_df[f'{col}_run_columns']
                    lic_non_hbap_merged_df.drop(columns=[f'{col}_run_columns'], inplace=True)

            lic_df = pd.concat([lic_hbap_merged_df, lic_non_hbap_merged_df], ignore_index=True, sort=False)

            columns_to_keep = ["ST", "Credit_Risk_Type", "Organisational_unit_level_1", "Organisational_unit_level_2", "Organisational_unit_level_3", "Country_of_Exposure", "Asset_class", "Product_Type", "Security", "Basel_Approach", "scenario", "Projection_Period", "Default_Status", "RWA_Orig", "Balance", "Exposure_for_RWA_Orig", "PD_Regulatory", "LGD_Regulatory", "Expected_Loss_Regulatory_Orig", "RWA", "Exposure_for_RWA", "Expected_Loss_Regulatory"]

            rwa_key_columns = ["Credit_Risk_Type", "Organisational_unit_level_1", "Organisational_unit_level_2", "Organisational_unit_level_3", "Country_of_Exposure", "Asset_class", "Product_Type", "Security", "Basel_Approach", "scenario", "Projection_Period", "Default_Status"]

            for var_name in ["rwa_hbap_first_run", "rwa_non_hbap_first_run"]:
                if var_name in dataframes:
                    dataframes[var_name] = dataframes[var_name][dataframes[var_name]["Projection_Period"] != 'T0']

            for var_name in ["rwa_hbap_first_run", "rwa_hbap_last_run", "rwa_non_hbap_first_run", "rwa_non_hbap_last_run"]:
                if var_name in dataframes:
                    dataframes[var_name] = dataframes[var_name].loc[:, columns_to_keep]

            rwa_first_run_columns = ['RWA_Orig', 'Exposure_for_RWA_Orig', 'Expected_Loss_Regulatory_Orig']
            columns_to_merge = rwa_key_columns + rwa_first_run_columns

            if "rwa_hbap_last_run" in dataframes and "rwa_hbap_first_run" in dataframes:
                rwa_hbap_merged_df = pd.merge(dataframes["rwa_hbap_last_run"], dataframes["rwa_hbap_first_run"][columns_to_merge], on=rwa_key_columns, how='left', suffixes=('', '_run_columns'))
                for col in rwa_first_run_columns:
                    rwa_hbap_merged_df[col] = rwa_hbap_merged_df[f'{col}_run_columns']
                    rwa_hbap_merged_df.drop(columns=[f'{col}_run_columns'], inplace=True)

            if "rwa_non_hbap_last_run" in dataframes and "rwa_non_hbap_first_run" in dataframes:
                rwa_non_hbap_merged_df = pd.merge(dataframes["rwa_non_hbap_last_run"], dataframes["rwa_non_hbap_first_run"][columns_to_merge], on=rwa_key_columns, how='left', suffixes=('', '_run_columns'))
                for col in rwa_first_run_columns:
                    rwa_non_hbap_merged_df[col] = rwa_non_hbap_merged_df[f'{col}_run_columns']
                    rwa_non_hbap_merged_df.drop(columns=[f'{col}_run_columns'], inplace=True)

            rwa_df = pd.concat([rwa_hbap_merged_df, rwa_non_hbap_merged_df], ignore_index=True, sort=False)

            projections = {
                "Balance": {"df": lic_df, "row": "Net Balance ($ MM)"},
                "ECL": {"df": lic_df, "row": "ECL ($ MM)"},
                "RWA": {"df": rwa_df, "row": "RWA ($ MM)"},
                "EL": {"df": rwa_df, "row": "EL ($ MM)"},
            }

            for projection, info in projections.items():
                df = info["df"]
                row = info["row"]
                for period in column_names:
                    period_df = df[(df["Projection_Period"] == period) &
                                   (df["Organisational_unit_level_1"].isin(Organisational_unit_level_1_selected)) &
                                   (df["Organisational_unit_level_2"].isin(Organisational_unit_level_2_selected)) &
                                   (df["Organisational_unit_level_3"].isin(Organisational_unit_level_3_selected)) &
                                   (df["Country_of_Exposure"].isin(Country_of_Exposure_selected)) &
                                   (df["Asset_class"].isin(Asset_class_selected)) &
                                   (df["Product_Type"].isin(Product_Type_selected)) &
                                   (df["Basel_Approach"].isin(Basel_Approach_selected)) &
                                   (df["scenario"].isin(ST_scenario_selected))]
                    if not period_df.empty:
                        table_df1.at[row, period] = period_df[projection].sum()

        context = {
            "table_df1": table_df1.to_html(classes="table table-striped")
        }
        return render(request, 'mi_chart.html', context)

    else:
        folders = get_folders()
        selected_folder = request.GET.get("folder", None)
        selected_subfolder = request.GET.get("subfolder", None)
        subfolders = get_subfolders(selected_folder) if selected_folder else []
        context = {
            "folders": folders,
            "selected_folder": selected_folder,
            "selected_subfolder": selected_subfolder,
            "subfolders": subfolders
        }
        return render(request, 'mi_chart.html', context)

































import json
import os
import pandas as pd
from django.http import JsonResponse

def mi_chart(request):
    if request.method == 'POST':
        selected_items = json.loads(request.POST.get('selectedItems', '{}'))
        print(selected_items)
        list_of_selected = [items for category, items in selected_items.items() if items]

        Organisational_unit_level_1_selected = list_of_selected[0]
        Organisational_unit_level_2_selected = list_of_selected[1]
        Organisational_unit_level_3_selected = list_of_selected[2]
        Country_of_Exposure_selected = list_of_selected[3]
        Asset_class_selected = list_of_selected[4]
        Product_Type_selected = list_of_selected[5]
        Basel_Approach_selected = list_of_selected[6]
        ST_scenario_selected = list_of_selected[7]

        folders = get_folders()
        selected_folder = request.GET.get("folder")
        selected_subfolder = request.GET.get("subfolder")
        subfolders = get_subfolders(selected_folder) if selected_folder else []

        row_names = [
            'Gross Balance ($ MM)', 'Net Balance ($ MM)', 'Net Balance Proportion S1',
            'Net Balance Proportion S2', 'Net Balance Proportion S3', 'ECL ($ MM)',
            'ECL Original ($ MM)', 'ECL Rate', 'Loss at WO ($ MM)', 'Loss at WO Original ($ MM)',
            'LIC ($ MM)', 'LIC Original ($ MM)', 'LIC overlay ($ MM)', 'LIC Rate',
            'Coverage ratio', 'PD', 'LGD', 'EAD ($ MM)', 'RWA ($ MM)', 'RWA Original ($ MM)',
            'RWA Overlay ($ MM)', 'RWA Density', 'EL($ MM)', 'EL Overlay ($MM)', 'EL Density'
        ]
        column_names = ['T0', 'T1', 'T2', 'T3', 'T4', 'T5']
        table_df1 = pd.DataFrame(index=row_names, columns=column_names)
        table_df = pd.DataFrame(index=row_names)

        if selected_folder and selected_subfolder:
            folder_path = os.path.join(FOLDER_PATH, selected_folder, selected_subfolder)
            excel_files = [f for f in os.listdir(folder_path) if f.endswith('.xlsx')]

            dataframes = {}
            for excel_file in excel_files:
                file_path = os.path.join(folder_path, excel_file)
                if "LIC" in excel_file and "HBAP" in excel_file:
                    if "FirstRun" in excel_file:
                        dataframes['lic_hbap_first_run'] = pd.read_excel(file_path, sheet_name="LPACT_OL_YTD_QTR_Final")
                    elif "LastRun" in excel_file:
                        dataframes['lic_hbap_last_run'] = pd.read_excel(file_path, sheet_name="LPACT_OL_YTD_QTR_Final")
                elif "LPACT" in excel_file and "HBAP" in excel_file:
                    dataframes['lpact_hbap_data'] = pd.read_excel(file_path, sheet_name="PD series")
                elif "LIC" in excel_file and "NonHBAP" in excel_file:
                    if "FirstRun" in excel_file:
                        dataframes['lic_non_hbap_first_run'] = pd.read_excel(file_path, sheet_name="LPACT_OL_YTD_QTR_Final")
                    elif "LastRun" in excel_file:
                        dataframes['lic_non_hbap_last_run'] = pd.read_excel(file_path, sheet_name="LPACT_OL_YTD_QTR_Final")
                elif "LPACT" in excel_file and "Non" in excel_file and "HBAP" in excel_file:
                    dataframes['lpact_non_hbap_data'] = pd.read_excel(file_path, sheet_name="PD series")
                elif "MI" in excel_file and "HBAP" in excel_file:
                    if "FirstRun" in excel_file:
                        dataframes['rwa_hbap_first_run'] = pd.read_excel(file_path, sheet_name="Temp_RRM_Final_OL")
                    elif "LastRun" in excel_file:
                        dataframes['rwa_hbap_last_run'] = pd.read_excel(file_path, sheet_name="Temp_RRM_Final_OL")
                elif "MI" in excel_file and "Non" in excel_file and "HBAP" in excel_file:
                    if "FirstRun" in excel_file:
                        dataframes['rwa_non_hbap_first_run'] = pd.read_excel(file_path, sheet_name="Temp_RRM_Final_OL")
                    elif "LastRun" in excel_file:
                        dataframes['rwa_non_hbap_last_run'] = pd.read_excel(file_path, sheet_name="Temp_RRM_Final_OL")
                elif "LIC" in excel_file and "Previous" in excel_file:
                    dataframes['lic_views_previous'] = pd.read_excel(file_path, sheet_name="LIC_raw1")
                elif "RWA" in excel_file and "Previous" in excel_file:
                    dataframes['rwa_views_previous'] = pd.read_excel(file_path, sheet_name="RWA_raw1")

            columns_to_keep = [
                "ST", "Credit_Risk_Type", "Organisational_unit_level_1", "Organisational_unit_level_2",
                "Organisational_unit_level_3", "Country_of_Exposure", "Asset_class", "Product_Type",
                "Security", "Basel_Approach", "scenario", "Projection_Period", "Type", "IFRS9_Stage",
                "Balance", "IFRS9_12M_PD", "IFRS9_LGD", "IFRS9_Lifetime_PD", "Cumm_Gross_WO",
                "Provisions_orig", "Provisions", "Loss_at_WO_orig", "Loss_at_WO", "Delta_Provisions",
                "LIC_Orig", "LIC", "Mapping1"
            ]

            for df_name in ['lic_hbap_first_run', 'lic_hbap_last_run', 'lic_non_hbap_first_run', 'lic_non_hbap_last_run']:
                if df_name in dataframes:
                    dataframes[df_name] = dataframes[df_name].loc[:, columns_to_keep]

            new_column_names = {
                'Countryofexposure': 'Country_of_Exposure',
                'projection_period': 'Projection_Period',
                'LIC_Orig': 'LIC_orig'
            }

            for df_name in ['lic_hbap_last_run', 'lic_hbap_first_run', 'lic_non_hbap_last_run', 'lic_non_hbap_first_run']:
                if df_name in dataframes:
                    dataframes[df_name] = dataframes[df_name].rename(columns=new_column_names)
                    dataframes[df_name] = dataframes[df_name][dataframes[df_name]["Type"] != "YTD"]
                    dataframes[df_name]["scenario"] = dataframes[df_name]["scenario"].replace('Annual cyclical scenario', 'Stress')

            for df_name in ['lpact_hbap_data', 'lpact_non_hbap_data']:
                if df_name in dataframes:
                    dataframes[df_name]["date"] = dataframes[df_name]["date"].str.replace('T', '')
                    dataframes[df_name]["date"] = pd.to_numeric(dataframes[df_name]["date"])

            lic_key_columns = [
                "Credit_Risk_Type", "Organisational_unit_level_1", "Organisational_unit_level_2",
                "Organisational_unit_level_3", "Country_of_Exposure", "Asset_class", "Product_Type",
                "Security", "Basel_Approach", "scenario", "Projection_Period", "Type", "IFRS9_Stage"
            ]
            lic_first_run_columns = ['Provisions_orig', 'Loss_at_WO_orig', 'LIC_orig']
            columns_to_merge = lic_key_columns + lic_first_run_columns

            for hbap_type in ['hbap', 'non_hbap']:
                if f'lic_{hbap_type}_last_run' in dataframes and f'lic_{hbap_type}_first_run' in dataframes:
                    merged_df = pd.merge(
                        dataframes[f'lic_{hbap_type}_last_run'],
                        dataframes[f'lic_{hbap_type}_first_run'][columns_to_merge],
                        on=lic_key_columns,
                        how='left',
                        suffixes=('', '_run_columns')
                    )
                    for col in lic_first_run_columns:
                        merged_df[col] = merged_df[f'{col}_run_columns']
                        merged_df.drop(columns=[f'{col}_run_columns'], inplace=True)
                    dataframes[f'lic_{hbap_type}_merged_df'] = merged_df

            if 'lic_non_hbap_last_run' in dataframes and 'lpact_non_hbap_data' in dataframes:
                updated_ifrs12M_df = dataframes['lic_non_hbap_last_run'].merge(
                    dataframes['lpact_non_hbap_data'],
                    how='left',
                    left_on=['Projection_Period', 'Mapping1', 'scenario'],
                    right_on=['date', 'portfolio', 'scenario']
                )

                def update_ifrs12M(row, updated_ifrs12M_df):
                    if row['IFRS9_Stage'] in [1, 2]:
                        match = updated_ifrs12M_df[
                            (updated_ifrs12M_df['date'] == row['Projection_Period']) &
                            (updated_ifrs12M_df['portfolio'] == row['Mapping1']) &
                            (updated_ifrs12M_df['scenario'] == row['scenario'])
                        ]
                        return match['pd'].values[0] if not match.empty else row['IFRS9_12M_PD']
                    elif row['IFRS9_Stage'] == 3:
                        return 1
                    return row['IFRS9_12M_PD']

                dataframes['lic_non_hbap_last_run']['IFRS9_12M_PD'] = dataframes['lic_non_hbap_last_run'].apply(
                    lambda row: update_ifrs12M(row, updated_ifrs12M_df), axis=1
                )

            lic_df = pd.concat([
                dataframes.get('lic_hbap_merged_df', pd.DataFrame()),
                dataframes.get('lic_non_hbap_merged_df', pd.DataFrame())
            ], ignore_index=True, sort=False)

            columns_to_keep = [
                "ST", "Credit_Risk_Type", "Organisational_unit_level_1", "Organisational_unit_level_2",
                "Organisational_unit_level_3", "Country_of_Exposure", "Asset_Class", "Product_Type",
                "security", "Basel_Approach", "Scenario", "Projection_Period", "Default_Status",
                "RWA_Orig", "Balance", "Exposure_for_RWA_Orig", "PD_Regulatory", "LGD_Regulatory",
                "Expected_Loss_Regulatory_Orig", "RWA", "Exposure_for_RWA", "Expected_Loss_Regulatory"
            ]

            for df_name in ['rwa_hbap_first_run', 'rwa_hbap_last_run', 'rwa_non_hbap_first_run', 'rwa_non_hbap_last_run']:
                if df_name in dataframes:
                    dataframes[df_name] = dataframes[df_name].loc[:, columns_to_keep]

            new_column_names = {'Scenario': 'scenario', 'Asset_Class': 'Asset_class'}

            for df_name in ['rwa_hbap_first_run', 'rwa_hbap_last_run', 'rwa_non_hbap_first_run', 'rwa_non_hbap_last_run']:
                if df_name in dataframes:
                    dataframes[df_name] = dataframes[df_name].rename(columns=new_column_names)
                    dataframes[df_name] = dataframes[df_name][~dataframes[df_name]['Projection_Period'].str.startswith('Y')]
                    dataframes[df_name]['Projection_Period'] = dataframes[df_name]['Projection_Period'].str.replace('^Q', '', regex=True)
                    dataframes[df_name]['Projection_Period'] = pd.to_numeric(dataframes[df_name]['Projection_Period'])

            rwa_key_columns = [
                "Credit_Risk_Type", "Organisational_unit_level_1", "Organisational_unit_level_2",
                "Organisational_unit_level_3", "Country_of_Exposure", "Asset_class", "Product_Type",
                "security", "Basel_Approach", "scenario", "Projection_Period", "Default_Status"
            ]
            rwa_first_run_columns = ['RWA_Orig', 'Exposure_for_RWA_Orig', 'Expected_Loss_Regulatory_Orig']
            columns_to_merge = rwa_key_columns + rwa_first_run_columns

            for hbap_type in ['hbap', 'non_hbap']:
                if f'rwa_{hbap_type}_last_run' in dataframes and f'rwa_{hbap_type}_first_run' in dataframes:
                    merged_df = pd.merge(
                        dataframes[f'rwa_{hbap_type}_last_run'],
                        dataframes[f'rwa_{hbap_type}_first_run'][columns_to_merge],
                        on=rwa_key_columns,
                        how='left',
                        suffixes=('', '_run_columns')
                    )
                    for col in rwa_first_run_columns:
                        merged_df[col] = merged_df[f'{col}_run_columns']
                        merged_df.drop(columns=[f'{col}_run_columns'], inplace=True)
                    dataframes[f'rwa_{hbap_type}_merged_df'] = merged_df

            rwa_df = pd.concat([
                dataframes.get('rwa_hbap_merged_df', pd.DataFrame()),
                dataframes.get('rwa_non_hbap_merged_df', pd.DataFrame())
            ], ignore_index=True, sort=False)

            lic_df = pd.concat([lic_df, dataframes.get('lic_views_previous', pd.DataFrame())])
            rwa_df = pd.concat([rwa_df, dataframes.get('rwa_views_previous', pd.DataFrame())])

            lic_df["scenario"] = lic_df["scenario"].replace('Annual cyclical scenario', 'Stress')
            rwa_df["scenario"] = rwa_df["scenario"].replace('Annual cyclical scenario', 'Stress')

            Organisational_unit_level_1_list = lic_df["Organisational_unit_level_1"].unique()
            Organisational_unit_level_2_list = lic_df["Organisational_unit_level_2"].unique()
            Organisational_unit_level_3_list = lic_df["Organisational_unit_level_3"].unique()
            Country_of_Exposure_list = lic_df["Country_of_Exposure"].unique()
            Asset_class_list = lic_df["Asset_class"].unique()
            Product_Type_list = lic_df["Product_Type"].unique()
            Basel_Approach_list = lic_df["Basel_Approach"].unique()
            ST_type = lic_df['ST'].unique()
            scenario_type = lic_df['scenario'].unique()

            ST_scenario_combo = [f"{st}-{scenario}" for st in ST_type for scenario in scenario_type]

            list1 = [st.split('-') for st in ST_scenario_selected]
            print(list1)

            for x in list1:
                scenario = x[1]
                ST = x[0]
                print(ST)

                for col in column_names:
                    if col == "T1":
                        Projection_Period = [4]
                        projection_period_range = [1, 2, 3, 4]
                    elif col == "T2":
                        Projection_Period = [8]
                        projection_period_range = [5, 6, 7, 8]
                    elif col == "T3":
                        Projection_Period = [12]
                        projection_period_range = [9, 10, 11, 12]
                    elif col == "T4":
                        Projection_Period = [16]
                        projection_period_range = [13, 14, 15, 16]
                    elif col == "T5":
                        Projection_Period = [20]
                        projection_period_range = [17, 18, 19, 20]
                    else:
                        Projection_Period = [0]
                        projection_period_range = [0]

                    filter_conditions = (
                        (lic_df["Organisational_unit_level_1"].isin(Organisational_unit_level_1_selected)) &
                        (lic_df["ST"] == ST) &
                        (lic_df["Organisational_unit_level_2"].isin(Organisational_unit_level_2_selected)) &
                        (lic_df["Organisational_unit_level_3"].isin(Organisational_unit_level_3_selected)) &
                        (lic_df["Country_of_Exposure"].isin(Country_of_Exposure_selected)) &
                        (lic_df["Asset_class"].isin(Asset_class_selected)) &
                        (lic_df["Product_Type"].isin(Product_Type_selected)) &
                        (lic_df["Basel_Approach"].isin(Basel_Approach_selected)) &
                        (lic_df["scenario"] == scenario) &
                        (lic_df["Projection_Period"].isin(Projection_Period))
                    )

                    net_balance = lic_df[filter_conditions]["Balance"].sum()
                    table_df1.loc["Net Balance ($ MM)", col] = round(net_balance / 1000000, 2)

                    gross_balance = net_balance + lic_df[filter_conditions]["Cumm_Gross_WO"].sum()
                    table_df1.loc["Gross Balance ($ MM)", col] = round(gross_balance / 1000000, 2)

                    for stage in [1, 2, 3]:
                        stage_balance = lic_df[filter_conditions & (lic_df["IFRS9_Stage"] == stage)]["Balance"].sum()
                        proportion = (stage_balance / net_balance) * 100 if net_balance != 0 else 0
                        table_df1.loc[f"Net Balance Proportion S{stage}", col] = f"{proportion:.2f}%"

                    provisions = lic_df[filter_conditions]["Provisions"].sum()
                    table_df1.loc["ECL ($ MM)", col] = round(provisions / 1000000, 2)

                    provisions_orig = lic_df[filter_conditions]["Provisions_orig"].sum()
                    table_df1.loc["ECL Original ($ MM)", col] = round(provisions_orig / 1000000, 2)

                    ecl_rate = (provisions / net_balance) * 100 if net_balance != 0 else 0
                    table_df1.loc["ECL Rate", col] = f"{ecl_rate:.2f}%"

                    loss_at_wo = lic_df[filter_conditions & (lic_df["Projection_Period"].isin(projection_period_range))]["Loss_at_WO"].sum()
                    table_df1.loc["Loss at WO ($ MM)", col] = round(loss_at_wo / 1000000, 2)

                    loss_at_wo_orig = lic_df[filter_conditions & (lic_df["Projection_Period"].isin(projection_period_range))]["Loss_at_WO_orig"].sum()
                    table_df1.loc["Loss at WO Original ($ MM)", col] = round(loss_at_wo_orig / 1000000, 2)

                    lic = lic_df[filter_conditions & (lic_df["Projection_Period"].isin(projection_period_range))]["LIC"].sum()
                    table_df1.loc["LIC ($ MM)", col] = round(lic / 1000000, 2)

                    lic_orig = lic_df[filter_conditions & (lic_df["Projection_Period"].isin(projection_period_range))]["LIC_orig"].sum()
                    table_df1.loc["LIC Original ($ MM)", col] = round(lic_orig / 1000000, 2)

                    table_df1.loc["LIC overlay ($ MM)", col] = table_df1.loc["LIC ($ MM)", col] - table_df1.loc["LIC Original ($ MM)", col]

                    lic_rate = (lic / net_balance) * 100 if net_balance != 0 else 0
                    table_df1.loc["LIC Rate", col] = f"{lic_rate:.2f}%"

                    # Coverage ratio calculation (if needed)
                    # table_df1.loc["Coverage ratio", col] = ...

                    # PD and LGD calculations (if needed)
                    # table_df1.loc["PD", col] = ...
                    # table_df1.loc["LGD", col] = ...

                    rwa_filter_conditions = (
                        (rwa_df["Organisational_unit_level_1"].isin(Organisational_unit_level_1_selected)) &
                        (rwa_df["ST"] == ST) &
                        (rwa_df["Organisational_unit_level_2"].isin(Organisational_unit_level_2_selected)) &
                        (rwa_df["Organisational_unit_level_3"].isin(Organisational_unit_level_3_selected)) &
                        (rwa_df["Country_of_Exposure"].isin(Country_of_Exposure_selected)) &
                        (rwa_df["Asset_class"].isin(Asset_class_selected)) &
                        (rwa_df["Product_Type"].isin(Product_Type_selected)) &
                        (rwa_df["Basel_Approach"].isin(Basel_Approach_selected)) &
                        (rwa_df["scenario"] == scenario) &
                        (rwa_df["Projection_Period"] == 0)
                    )

                    ead = rwa_df[rwa_filter_conditions]["Exposure_for_RWA"].sum()
                    table_df1.loc["EAD ($ MM)", col] = round(ead / 1000000, 2)

                    rwa = rwa_df[rwa_filter_conditions]["RWA"].sum()
                    table_df1.loc["RWA ($ MM)", col] = round(rwa / 1000000, 2)

                    rwa_orig = rwa_df[rwa_filter_conditions]["RWA_Orig"].sum()
                    table_df1.loc["RWA Original ($ MM)", col] = round(rwa_orig / 1000000, 2)

                    table_df1.loc["RWA Overlay ($ MM)", col] = round(table_df1.loc["RWA ($ MM)", col] - table_df1.loc["RWA Original ($ MM)", col], 2)

                    rwa_density = (rwa / ead) * 100 if ead != 0 else 0
                    table_df1.loc["RWA Density", col] = f"{rwa_density:.2f}%"

                    el = rwa_df[rwa_filter_conditions]["Expected_Loss_Regulatory"].sum()
                    table_df1.loc["EL($ MM)", col] = round(el / 1000000, 2)

                    el_orig = rwa_df[rwa_filter_conditions]["Expected_Loss_Regulatory_Orig"].sum()
                    table_df1.loc["EL Overlay ($MM)", col] = round((el - el_orig) / 1000000, 2)

                    el_density = (el / ead) * 100 if ead != 0 else 0
                    table_df1.loc["EL Density", col] = f"{el_density:.2f}%"

            table_df = pd.concat([table_df, table_df1], axis=1)
            table_html = table_df.to_html(classes="table table-striped table-bordered", index=True)
            return JsonResponse({'table_html': table_html})

    return JsonResponse({'error': 'Invalid request method'})






















import pandas as pd
from datetime import datetime
from openpyxl import load_workbook

def write_description(sheet):
    # Load the mapping file
    workbook_path = r".\Input\Mapping_File - Copy.xlsx"
    mapping_df = pd.read_excel(workbook_path, sheet_name="Data_Edge")

    # Define the constants
    country_list = ['USA']
    curr_year = 2024
    quarters = [
        (curr_year - 1, 3, 31),
        (curr_year - 1, 6, 30),
        (curr_year - 1, 9, 30),
        (curr_year - 1, 12, 31)
    ]

    # Get the col_list once
    col_list = Table_List.loc[Table_List['Country'].isin(country_list), 'MEV'].tolist()

    # Process all frames
    all_results = [process_frame(frame, country_list, col_list, quarters) for frame in All]

    # Combine results
    combined_results = list(zip(*all_results))

    # Iterate through all cells in the sheet
    for row in range(1, sheet.max_row + 1):
        for col in range(1, sheet.max_column + 1):
            if sheet.cell(row=row, column=col).value == 'user_inputs[0]':
                check_and_write(sheet, row, col, combined_results, col_list, country_list, mapping_df)

def process_frame(frame, country_list, col_list, quarters):
    results = []
    for year, month, day in quarters:
        date = datetime(year, month, day)
        filtered = frame[(frame['ISOCODES'].isin(country_list)) & (frame['date'] == date)]
        if not filtered.empty:
            values = filtered[col_list].round(1).values[0]
            results.append(values.tolist())
    return results

def check_and_write(sheet, row, col, combined_results, col_list, country_list, mapping_df):
    for i in range(3, 7):
        cell_value = sheet.cell(row=row+i, column=col).value
        if cell_value not in combined_results[i-3]:
            return

    for trans_variable, isocode in zip(col_list, country_list):
        match = mapping_df[(mapping_df['Trans_variable'] == trans_variable) &
                           (mapping_df['ISOCODES'] == isocode)]
        if not match.empty:
            description = match['Description'].values[0]
            sheet.cell(row=row-1, column=col, value=description)
            return

# Usage example
workbook = load_workbook('your_workbook.xlsx')
sheet = workbook['Your Sheet Name']
write_description(sheet)
workbook.save('your_workbook_updated.xlsx')
















import pandas as pd
from datetime import datetime

def write_description(sheet, user_inputs, country_list):
    curr_year = 2024
    list2, list3, list4, list5 = [], [], [], []

    for frame in All:
        for row in frame.itertuples():
            for Isocode in country_list:
                if row.ISOCODES == Isocode:
                    if row.date == datetime.strptime(f"{curr_year-1}-03-31 00:00:00", "%Y-%m-%d %H:%M:%S"):
                        col_list = Table_List["MEV"].loc[Table_List.Country == Isocode].tolist()
                        for col in col_list:
                            list2.append(round(getattr(row, col), 1))
                    if row.date == datetime.strptime(f"{curr_year-1}-06-30 00:00:00", "%Y-%m-%d %H:%M:%S"):
                        col_list = Table_List["MEV"].loc[Table_List.Country == Isocode].tolist()
                        for col in col_list:
                            list3.append(round(getattr(row, col), 1))
                    if row.date == datetime.strptime(f"{curr_year-1}-09-30 00:00:00", "%Y-%m-%d %H:%M:%S"):
                        col_list = Table_List["MEV"].loc[Table_List.Country == Isocode].tolist()
                        for col in col_list:
                            list4.append(round(getattr(row, col), 1))
                    if row.date == datetime.strptime(f"{curr_year-1}-12-31 00:00:00", "%Y-%m-%d %H:%M:%S"):
                        col_list = Table_List["MEV"].loc[Table_List.Country == Isocode].tolist()
                        for col in col_list:
                            list5.append(round(getattr(row, col), 1))

    # Ensure all lists are the same length by trimming to the length of col_list
    col_length = len(col_list)
    list2 = list2[:col_length]
    list3 = list3[:col_length]
    list4 = list4[:col_length]
    list5 = list5[:col_length]

    # Iterate over each set of elements
    for i in range(col_length):
        combined_list = [list2[i], list3[i], list4[i], list5[i]]

        # Find the location of user_inputs[0] in the sheet
        location = sheet[sheet.apply(lambda row: row.astype(str).str.contains(user_inputs[0]).any(), axis=1)].index[0]

        # Check if combined_list matches the cells 3, 4, 5, and 6 rows below
        match = True
        for j in range(4):
            if sheet.iloc[location + 3 + j, sheet.columns.get_loc(user_inputs[0])] != combined_list[j]:
                match = False
                break

        # If all matched, update the Description column
        if match:
            trans_var = sheet['Trans_variable'][location]
            isocode = sheet['ISOCODES'][location]

            if trans_var in col_list and isocode in country_list:
                sheet.at[location - 1, 'Description'] = sheet.at[location, trans_var]
                break  # Update for the first matching set only

    return sheet

# Example usage:
workbook_path = r".\Input\Mapping_File - Copy.xlsx"
sheet_name = "Data_Edge"
sheet = pd.read_excel(workbook_path, sheet_name=sheet_name)
user_inputs = ["SomeValue"]
country_list = ['USA']

# Assuming All and Table_List are already defined
# All = [...]
# Table_List = pd.DataFrame(...)

updated_sheet = write_description(sheet, user_inputs, country_list)

# Save the updated sheet back to Excel
updated_sheet.to_excel(workbook_path, sheet_name=sheet_name, index=False)


















import pandas as pd
from datetime import datetime

def write_description(sheet):
    # Load the mapping file
    workbook_path = r".\Input\Mapping_File - Copy.xlsx"
    df = pd.read_excel(workbook_path, sheet_name="Data_Edge")

    # Define constants
    country_list = ['USA']
    curr_year = 2024
    quarters = [
        (curr_year - 1, 3, 31),
        (curr_year - 1, 6, 30),
        (curr_year - 1, 9, 30),
        (curr_year - 1, 12, 31)
    ]

    # Get the col_list
    col_list = Table_List.loc[Table_List['Country'].isin(country_list), 'MEV'].tolist()

    # Process all frames
    lists = [[], [], [], []]
    for frame in All:
        for quarter, target_list in zip(quarters, lists):
            date = datetime(*quarter)
            filtered = frame[(frame['ISOCODES'].isin(country_list)) & (frame['date'] == date)]
            if not filtered.empty:
                for col in col_list:
                    target_list.append(round(filtered[col].values[0], 1))

    # Iterate through all cells in the sheet
    for row in range(1, sheet.max_row + 1):
        for col in range(1, sheet.max_column + 1):
            if sheet.cell(row=row, column=col).value == 'user_inputs[0]':
                for i in range(len(col_list)):
                    # Check conditions
                    conditions_met = True
                    for j, target_list in enumerate(lists):
                        if sheet.cell(row=row+j+3, column=col).value != target_list[i]:
                            conditions_met = False
                            break

                    if conditions_met:
                        # Find matching description
                        trans_variable = col_list[i]
                        isocode = country_list[0]  # Assuming only one country in the list
                        match = df[(df['Trans_variable'] == trans_variable) &
                                   (df['ISOCODES'] == isocode)]
                        if not match.empty:
                            description = match['Description'].values[0]
                            sheet.cell(row=row-1, column=col, value=description)
                            break

    return sheet

# Usage example:
# workbook = load_workbook('your_workbook.xlsx')
# sheet = workbook['Your Sheet Name']
# updated_sheet = write_description(sheet)
# workbook.save('your_workbook_updated.xlsx')










from openpyxl.styles import Border, Side

def black_marking(sheet):
    thin_border = Side(style='thin', color='080808')

    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == user_inputs[0]:
                start_row = cell.row + 26
                start_col = cell.column - 1
                end_row = cell.row + 28
                end_col = cell.column

                # Top border
                for col in range(start_col, end_col + 1):
                    sheet.cell(row=start_row, column=col).border = Border(top=thin_border)

                # Bottom border
                for col in range(start_col, end_col + 1):
                    sheet.cell(row=end_row, column=col).border = Border(bottom=thin_border)

                # Left border
                for row in range(start_row, end_row + 1):
                    sheet.cell(row=row, column=start_col).border = Border(left=thin_border)

                # Right border
                for row in range(start_row, end_row + 1):
                    sheet.cell(row=row, column=end_col).border = Border(right=thin_border)

                # Corners
                sheet.cell(row=start_row, column=start_col).border = Border(top=thin_border, left=thin_border)
                sheet.cell(row=start_row, column=end_col).border = Border(top=thin_border, right=thin_border)
                sheet.cell(row=end_row, column=start_col).border = Border(bottom=thin_border, left=thin_border)
                sheet.cell(row=end_row, column=end_col).border = Border(bottom=thin_border, right=thin_border)

    return sheet














from openpyxl.styles import Font

def convert_to_number(sheet):
    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == 'user_inputs[0]':
                target_column = cell.column - 1
                target_rows = [cell.row + offset for offset in [7, 12, 17, 18, 19]]

                for target_row in target_rows:
                    target_cell = sheet.cell(row=target_row, column=target_column)

                    # Convert to number if it's a string that represents a number
                    if isinstance(target_cell.value, str):
                        try:
                            # Try to convert to float first
                            numeric_value = float(target_cell.value)
                            # If it's a whole number, convert to int
                            if numeric_value.is_integer():
                                numeric_value = int(numeric_value)
                            target_cell.value = numeric_value
                        except ValueError:
                            # If conversion fails, leave the value as is
                            pass

                    # Apply bold font with size 9
                    target_cell.font = Font(bold=True, size=9)

    return sheet

# Usage example:
# workbook = load_workbook('your_workbook.xlsx')
# sheet = workbook['Your Sheet Name']
# updated_sheet = convert_to_number(sheet)
# workbook.save('your_workbook_updated.xlsx')






if isinstance(target_cell.value, (int, float)):
    if isinstance(target_cell.value, int) or (isinstance(target_cell.value, float) and target_cell.value.is_integer()):
        target_cell.number_format = '0'
    else:
        target_cell.number_format = '0.00'















from openpyxl.styles import Font

def convert_to_number(sheet):
    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == 'user_inputs[0]':
                target_column = cell.column - 1
                target_rows = [cell.row + offset for offset in [7, 12, 17, 18, 19]]

                for target_row in target_rows:
                    target_cell = sheet.cell(row=target_row, column=target_column)

                    # Store existing cell style
                    existing_style = target_cell._style

                    # Convert to number if it's a string that represents a number
                    if isinstance(target_cell.value, str):
                        try:
                            # Convert to float first
                            numeric_value = float(target_cell.value)
                            # If it's a whole number, convert to int
                            if numeric_value.is_integer():
                                numeric_value = int(numeric_value)
                            target_cell.value = numeric_value
                        except ValueError:
                            # If conversion fails, leave the value as is
                            pass

                    # Apply bold font with size 9, preserving other font properties
                    new_font = Font(bold=True, size=9,
                                    name=target_cell.font.name,
                                    color=target_cell.font.color)
                    target_cell.font = new_font

                    # Format the cell to display without decimal places if it's a whole number
                    if target_cell.value is not None and isinstance(target_cell.value, (int, float)):
                        if isinstance(target_cell.value, int) or (isinstance(target_cell.value, float) and target_cell.value.is_integer()):
                            target_cell.number_format = '0'
                        else:
                            target_cell.number_format = '0.00'

                    # Restore other existing styles
                    target_cell._style = existing_style
                    target_cell.font = new_font

    return sheet

# Usage example:
# workbook = load_workbook('your_workbook.xlsx')
# sheet = workbook['Your Sheet Name']
# updated_sheet = convert_to_number(sheet)
# workbook.save('your_workbook_updated.xlsx')









from openpyxl.styles import PatternFill, Alignment
from openpyxl.utils import get_column_letter

def grey_separation(sheet):
    # Find the cell containing '4% DN'
    target_cell = None
    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == '4% DN':
                target_cell = cell
                break
        if target_cell:
            break

    if not target_cell:
        print("Cell containing '4% DN' not found.")
        return sheet

    # Calculate the column two columns to the right of '4% DN'
    target_column = target_cell.column + 2
    target_column_letter = get_column_letter(target_column)

    # Define the range to merge and fill
    start_cell = f"{target_column_letter}1"
    end_cell = f"{target_column_letter}31"

    # Merge the cells
    sheet.merge_cells(f"{start_cell}:{end_cell}")

    # Get the merged cell
    merged_cell = sheet[start_cell]

    # Apply center alignment
    merged_cell.alignment = Alignment(horizontal='center', vertical='center')

    # Apply light grey fill
    light_grey_fill = PatternFill(start_color='D3D3D3', end_color='D3D3D3', fill_type='solid')
    merged_cell.fill = light_grey_fill

    return sheet

# Usage example:
# workbook = load_workbook('your_workbook.xlsx')
# sheet = workbook['Your Sheet Name']
# updated_sheet = grey_separation(sheet)
# workbook.save('your_workbook_updated.xlsx')









import pandas as pd
from openpyxl.styles import Border, Side
from datetime import datetime

def red_marking(sheet):
    # Define the thick red border style
    thick_red_border = Side(style='thick', color='FF0000')

    # Extract dates from the first column
    date_column = [cell.value for cell in sheet['A'] if cell.value]

    # Convert dates to datetime objects
    datetime_index = pd.to_datetime(date_column, format="%m/%d/%Y", errors='coerce')

    # Get the boundary dates from user inputs
    above_date = pd.to_datetime(user_inputs[17], format='%Y-%m-%d', errors='coerce')
    below_date = pd.to_datetime(user_inputs[18], format='%Y-%m-%d', errors='coerce')

    # Find the rows for the boundary dates
    above_row = None
    below_row = None
    for i, date in enumerate(datetime_index):
        if pd.notnull(date):
            if date >= above_date and above_row is None:
                above_row = i + 1  # +1 because sheet rows are 1-indexed
            if date >= below_date:
                below_row = i + 1
                # Check for empty cells below
                while below_row + 1 <= len(date_column) and sheet.cell(row=below_row + 1, column=1).value is None:
                    below_row += 1
                break

    if above_row and below_row:
        # Find all cells containing user_inputs[0]
        for row in sheet.iter_rows():
            for cell in row:
                if cell.value == user_inputs[0]:
                    start_cell = sheet.cell(row=above_row, column=cell.column + 1)
                    end_cell = sheet.cell(row=below_row, column=cell.column + 1)

                    for box_row in sheet[start_cell.coordinate:end_cell.coordinate]:
                        for box_cell in box_row:
                            if box_cell.row == start_cell.row:
                                box_cell.border = Border(top=thick_red_border, left=thick_red_border, right=thick_red_border)
                            elif box_cell.row == end_cell.row:
                                box_cell.border = Border(bottom=thick_red_border, left=thick_red_border, right=thick_red_border)
                            else:
                                box_cell.border = Border(left=thick_red_border, right=thick_red_border)

    return sheet

# Usage example:
# Assuming user_inputs is defined and contains the necessary values
# workbook = load_workbook('your_workbook.xlsx')
# sheet = workbook['Your Sheet Name']
# updated_sheet = red_marking(sheet)
# workbook.save('your_workbook_updated.xlsx')


















import pandas as pd
from openpyxl.styles import Border, Side
from datetime import datetime

def red_marking(sheet):
    # Define the medium red border style
    medium_red_border = Side(style='medium', color='FF0000')

    # Extract dates from the first column
    date_column = [cell.value for cell in sheet['A'] if cell.value]

    # Convert dates to datetime objects
    datetime_index = pd.to_datetime(date_column, format="%m/%d/%Y", errors='coerce')

    # Get the boundary dates from user inputs
    above_date = pd.to_datetime(user_inputs[17], format='%Y-%m-%d', errors='coerce')
    below_date = pd.to_datetime(user_inputs[18], format='%Y-%m-%d', errors='coerce')

    # Find the rows for the boundary dates
    above_row = None
    below_row = None
    for i, date in enumerate(datetime_index):
        if pd.notnull(date):
            if date == above_date:
                above_row = i + 1 - 4  # 4 cells above the matching date
            if date == below_date:
                below_row = i + 1 - 4  # 4 cells above the matching date
                # Check if there's a date after this one
                if i + 1 < len(datetime_index):
                    below_row += 1  # Extend by 1 if there's a date after
                else:
                    below_row += 2  # Extend by 2 if it's the last date
                break

    if above_row and below_row:
        # Find all cells containing user_inputs[0]
        for row in sheet.iter_rows():
            for cell in row:
                if cell.value == user_inputs[0]:
                    start_cell = sheet.cell(row=above_row, column=cell.column + 1)
                    end_cell = sheet.cell(row=below_row, column=cell.column + 1)

                    for box_row in sheet[start_cell.coordinate:end_cell.coordinate]:
                        for box_cell in box_row:
                            if box_cell.row == start_cell.row:
                                box_cell.border = Border(top=medium_red_border, left=medium_red_border, right=medium_red_border)
                            elif box_cell.row == end_cell.row:
                                box_cell.border = Border(bottom=medium_red_border, left=medium_red_border, right=medium_red_border)
                            else:
                                box_cell.border = Border(left=medium_red_border, right=medium_red_border)

    return sheet

# Usage example:
# Assuming user_inputs is defined and contains the necessary values
# workbook = load_workbook('your_workbook.xlsx')
# sheet = workbook['Your Sheet Name']
# updated_sheet = red_marking(sheet)
# workbook.save('your_workbook_updated.xlsx')











import pandas as pd
from openpyxl.styles import Border, Side
from datetime import datetime

def red_marking(sheet):
    # Define the medium red border style
    medium_red_border = Side(style='medium', color='FF0000')

    # Extract dates from the first column, keeping track of their row numbers
    date_column = []
    date_rows = []
    for i, cell in enumerate(sheet['A'], start=1):
        if isinstance(cell.value, (datetime, str)) and not cell.value.startswith('_'):
            date_column.append(cell.value)
            date_rows.append(i)

    # Convert dates to datetime objects
    datetime_index = pd.to_datetime(date_column, format="%m/%d/%Y", errors='coerce')

    # Get the boundary dates from user inputs
    above_date = pd.to_datetime(user_inputs[17], format='%Y-%m-%d', errors='coerce')
    below_date = pd.to_datetime(user_inputs[18], format='%Y-%m-%d', errors='coerce')

    # Find the rows for the boundary dates
    above_row = None
    below_row = None
    for i, date in enumerate(datetime_index):
        if pd.notnull(date):
            if date == above_date:
                above_row = date_rows[i] - 4  # 4 cells above the matching date
            if date == below_date:
                below_row = date_rows[i]  # Start with the row of the matching date
                # Check if there's a date after this one
                if i + 1 < len(datetime_index):
                    below_row = date_rows[i]  # Use the row of the current date
                else:
                    # If it's the last date, find the next non-empty cell
                    for j in range(date_rows[i] + 1, sheet.max_row + 1):
                        if sheet.cell(row=j, column=1).value:
                            below_row = j - 1
                            break
                    else:
                        below_row = sheet.max_row
                break

    if above_row and below_row:
        # Find all cells containing user_inputs[0]
        for row in sheet.iter_rows():
            for cell in row:
                if cell.value == user_inputs[0]:
                    start_cell = sheet.cell(row=above_row, column=cell.column + 1)
                    end_cell = sheet.cell(row=below_row, column=cell.column + 1)

                    for box_row in sheet[start_cell.coordinate:end_cell.coordinate]:
                        for box_cell in box_row:
                            if box_cell.row == start_cell.row:
                                box_cell.border = Border(top=medium_red_border, left=medium_red_border, right=medium_red_border)
                            elif box_cell.row == end_cell.row:
                                box_cell.border = Border(bottom=medium_red_border, left=medium_red_border, right=medium_red_border)
                            else:
                                box_cell.border = Border(left=medium_red_border, right=medium_red_border)

    return sheet

# Usage example:
# Assuming user_inputs is defined and contains the necessary values
# workbook = load_workbook('your_workbook.xlsx')
# sheet = workbook['Your Sheet Name']
# updated_sheet = red_marking(sheet)
# workbook.save('your_workbook_updated.xlsx')














from openpyxl.styles import Font

def convert_to_number(sheet):
    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == user_inputs[0]:  # Remove quotes around user_inputs[0]
                target_column = cell.column - 1
                target_rows = [cell.row + offset for offset in [7, 12, 17, 18, 19]]

                for target_row in target_rows:
                    target_cell = sheet.cell(row=target_row, column=target_column)

                    # Convert to number if it's a string that represents a year
                    if isinstance(target_cell.value, str):
                        try:
                            # Try to convert to integer
                            numeric_value = int(target_cell.value)
                            # Check if it's a valid year (assuming years between 1900 and 2100)
                            if 1900 <= numeric_value <= 2100:
                                target_cell.value = numeric_value
                        except ValueError:
                            # If conversion fails, leave the value as is
                            pass

                    # Preserve existing font properties
                    existing_font = target_cell.font
                    new_font = Font(
                        name=existing_font.name,
                        size=9,  # Set size to 9
                        bold=True,  # Set bold to True
                        italic=existing_font.italic,
                        vertAlign=existing_font.vertAlign,
                        underline=existing_font.underline,
                        strike=existing_font.strike,
                        color=existing_font.color
                    )
                    target_cell.font = new_font

    return sheet












from openpyxl.styles import Font

def convert_to_number(sheet):
    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == user_inputs[0]:
                target_column = cell.column - 1
                target_rows = [cell.row + offset for offset in [7, 12, 17, 18, 19]]

                for target_row in target_rows:
                    target_cell = sheet.cell(row=target_row, column=target_column)

                    # Convert to number if it's a string that represents a year
                    if isinstance(target_cell.value, (str, float)):
                        try:
                            # Try to convert to integer
                            numeric_value = int(float(target_cell.value))
                            # Check if it's a valid year (assuming years between 1900 and 2100)
                            if 1900 <= numeric_value <= 2100:
                                target_cell.value = numeric_value

                                # Preserve existing font properties, only changing size and bold
                                existing_font = target_cell.font
                                new_font = Font(
                                    name=existing_font.name,
                                    size=9,  # Set size to 9
                                    bold=True,  # Set bold to True
                                    italic=existing_font.italic,
                                    vertAlign=existing_font.vertAlign,
                                    underline=existing_font.underline,
                                    strike=existing_font.strike,
                                    color=existing_font.color
                                )
                                target_cell.font = new_font
                        except ValueError:
                            # If conversion fails, leave the value as is
                            pass

    return sheet















from openpyxl.styles import Font, PatternFill

def convert_to_number(sheet):
    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == user_inputs[0]:
                target_column = cell.column - 1
                target_rows = [cell.row + offset for offset in [7, 12, 17, 18, 19]]

                for target_row in target_rows:
                    target_cell = sheet.cell(row=target_row, column=target_column)

                    # Store the original background color
                    original_fill_type = target_cell.fill.fill_type
                    original_fill_color = target_cell.fill.start_color.rgb if target_cell.fill.start_color else None

                    # Convert to number if it's a string or float that represents a year
                    if isinstance(target_cell.value, (str, float)):
                        try:
                            # Try to convert to integer
                            numeric_value = int(float(target_cell.value))
                            # Check if it's a valid year (assuming years between 1900 and 2100)
                            if 1900 <= numeric_value <= 2100:
                                target_cell.value = numeric_value

                                # Set number format to display as integer
                                target_cell.number_format = '0'

                                # Preserve existing font properties, only changing size and bold
                                existing_font = target_cell.font
                                new_font = Font(
                                    name=existing_font.name,
                                    size=9,  # Set size to 9
                                    bold=True,  # Set bold to True
                                    italic=existing_font.italic,
                                    vertAlign=existing_font.vertAlign,
                                    underline=existing_font.underline,
                                    strike=existing_font.strike,
                                    color=existing_font.color
                                )
                                target_cell.font = new_font
                        except ValueError:
                            # If conversion fails, leave the value as is
                            pass

                    # Restore the original background color
                    if original_fill_type and original_fill_color:
                        target_cell.fill = PatternFill(fill_type=original_fill_type, start_color=original_fill_color)
                    elif original_fill_type:
                        target_cell.fill = PatternFill(fill_type=original_fill_type)

    return sheet









def convert_to_number(sheet):
    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == user_inputs[0]:
                target_column = cell.column - 1
                target_rows = [cell.row + offset for offset in [7, 12, 17, 18, 19]]

                for target_row in target_rows:
                    target_cell = sheet.cell(row=target_row, column=target_column)

                    # Convert to number if it's a string or float that represents a year
                    if isinstance(target_cell.value, (str, float)):
                        try:
                            # Try to convert to integer
                            numeric_value = int(float(target_cell.value))
                            # Check if it's a valid year (assuming years between 1900 and 2100)
                            if 1900 <= numeric_value <= 2100:
                                target_cell.value = numeric_value
                                # Set number format to display as integer without decimals
                                target_cell.number_format = '0'
                        except ValueError:
                            # If conversion fails, leave the value as is
                            pass

    return sheet

















from openpyxl.styles import Font, PatternFill

def convert_to_number(sheet, user_inputs):
    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == user_inputs[0]:
                target_column = cell.column
                target_rows = [cell.row + offset for offset in [7, 12, 17, 18, 19]]

                for target_row in target_rows:
                    target_cell = sheet.cell(row=target_row, column=target_column)

                    # Convert to number if it's a string or float that represents a year
                    if isinstance(target_cell.value, (str, float)):
                        try:
                            # Try to convert to integer
                            numeric_value = int(float(target_cell.value))
                            # Check if it's a valid year (assuming years between 1900 and 2100)
                            if 1900 <= numeric_value <= 2100:
                                target_cell.value = numeric_value

                                # Set number format to display as integer
                                target_cell.number_format = '0'
                        except ValueError:
                            # If conversion fails, leave the value as is
                            pass

    return sheet



from openpyxl.styles import Font, PatternFill

def convert_to_number(sheet, user_inputs):
    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == user_inputs[0]:
                target_column = cell.column
                target_rows = [cell.row + offset for offset in [7, 12, 17, 18, 19]]

                for target_row in target_rows:
                    target_cell = sheet.cell(row=target_row, column=target_column)

                    # Convert to number if it's a string or float that represents a year
                    if isinstance(target_cell.value, (str, float)):
                        try:
                            # Try to convert to integer
                            numeric_value = int(float(target_cell.value))
                            # Check if it's a valid year (assuming years between 1900 and 2100)
                            if 1900 <= numeric_value <= 2100:
                                target_cell.value = numeric_value

                                # Set number format to display as integer
                                target_cell.number_format = '0'
                        except ValueError:
                            # If conversion fails, leave the value as is
                            pass

    return sheet






def convert_to_number(sheet):
    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == user_inputs[0]:
                target_column = cell.column - 1
                target_rows = [cell.row + offset for offset in [7, 12, 17, 18, 19]]

                for target_row in target_rows:
                    target_cell = sheet.cell(row=target_row, column=target_column)

                    # Convert to number if it's a string or float
                    if isinstance(target_cell.value, (str, float)):
                        try:
                            # Convert to integer without validity check
                            numeric_value = int(float(target_cell.value))
                            target_cell.value = numeric_value

                            # Set number format to display as integer
                            target_cell.number_format = '0'
                        except ValueError:
                            # If conversion fails, leave the value as is
                            pass

    return sheet













from openpyxl.utils import column_index_from_string

def convert_to_number(sheet):
    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == user_inputs[0]:
                target_column = column_index_from_string(cell.column_letter) - 1
                target_rows = [cell.row + offset for offset in [7, 12, 17, 18, 19]]

                for target_row in target_rows:
                    target_cell = sheet.cell(row=target_row, column=target_column)

                    # Convert to number if it's a string or float
                    if isinstance(target_cell.value, (str, float)):
                        try:
                            # Convert to integer
                            numeric_value = int(float(target_cell.value))

                            # Use Excel's built-in number format
                            target_cell.value = numeric_value
                            target_cell.number_format = 'General'
                        except ValueError:
                            # If conversion fails, leave the value as is
                            pass

    return sheet











@csrf_exempt
def mi_chart(request):
    if request.method == 'POST':
        selected_items = json.loads(request.POST.get('selectedItems', '{}'))
        print(selected_items)

        list_of_selected = [items for category, items in selected_items.items() if items]

        Organisational_unit_level_1_selected = list_of_selected[0]
        Organisational_unit_level_2_selected = list_of_selected[1]
        Organisational_unit_level_3_selected = list_of_selected[2]
        Country_of_Exposure_selected = list_of_selected[3]
        Asset_class_selected = list_of_selected[4]
        Product_Type_selected = list_of_selected[5]
        Basel_Approach_selected = list_of_selected[6]
        ST_scenario_selected = list_of_selected[7]

        folders = get_folders()
        selected_folder = request.GET.get("folder")
        selected_subfolder = request.GET.get("subfolder")
        subfolders = get_subfolders(selected_folder) if selected_folder else []

        row_names = [
            'Gross Balance ($ MM)', 'Net Balance ($ MM)', 'Net Balance Proportion S1',
            'Net Balance Proportion S2', 'Net Balance Proportion S3', 'ECL ($ MM)',
            'ECL Original ($ MM)', 'ECL Rate', 'Loss at WO ($ MM)', 'Loss at WO Original ($ MM)',
            'LIC ($ MM)', 'LIC Original ($ MM)', 'LIC overlay ($ MM)', 'LIC Rate', 'Coverage ratio',
            'PD', 'LGD', 'EAD ($ MM)', 'RWA ($ MM)', 'RWA Original ($ MM)', 'RWA Overlay ($ MM)',
            'RWA Density', 'EL($ MM)', 'EL Overlay ($ MM)', 'EL Density'
        ]
        column_names = ['T', 'T1', 'T2', 'T3', 'T4', 'T5']

        table_df1 = pd.DataFrame(index=row_names, columns=column_names)
        table_df = pd.DataFrame(index=row_names)

        if selected_folder and selected_subfolder:
            folder_path = os.path.join(FOLDER_PATH, selected_folder, selected_subfolder)
            excel_files = [f for f in os.listdir(folder_path) if f.endswith('.xlsx')]
            dataframes = {}

            for excel_file in excel_files:
                file_path = os.path.join(folder_path, excel_file)
                # ... (rest of the file reading logic)

            # ... (rest of the data processing logic)

            table_df = pd.concat([table_df, table_df1], axis=1)
            table_html = table_df.to_html(classes="table table-striped table-bordered", index=True)

            return JsonResponse({'table_html': table_html})

    folders = get_folders()
    selected_folder = request.GET.get("folder", None)
    selected_subfolder = request.GET.get("subfolder", None)
    subfolders = get_subfolders(selected_folder) if selected_folder else []

    if selected_folder and selected_subfolder:
        folder_path = os.path.join(FOLDER_PATH, selected_folder, selected_subfolder)
        excel_files = [f for f in os.listdir(folder_path) if f.endswith('.xlsx')]

        # ... (rest of the file reading logic)

    row_names = [
        'Gross Balance ($ MM)', 'Net Balance ($ MM)', 'Net Balance Proportion S1',
        'Net Balance Proportion S2', 'Net Balance Proportion S3', 'ECL ($ MM)',
        'ECL Original ($ MM)', 'ECL Rate', 'Loss at WO ($ MM)', 'Loss at WO Original ($ MM)',
        'LIC ($ MM)', 'LIC Original ($ MM)', 'LIC overlay ($ MM)', 'LIC Rate', 'Coverage ratio',
        'PD', 'LGD', 'EAD ($ MM)', 'RWA ($ MM)', 'RWA Original ($ MM)', 'RWA Overlay ($ MM)',
        'RWA Density', 'EL($ MM)', 'EL Overlay ($ MM)', 'EL Density'
    ]
    column_names = ['T', 'T1', 'T2', 'T3', 'T4', 'T5']
    table_df = pd.DataFrame(index=row_names)

    table_html = table_df.to_html(classes="table table-striped table-bordered", index=True)

    context1 = {
        'Organisational_unit_level_1_list': Organisational_unit_level_1_list,
        'Organisational_unit_level_2_list': Organisational_unit_level_2_list,
        'Organisational_unit_level_3_list': Organisational_unit_level_3_list,
        'Country_of_Exposure_list': Country_of_Exposure_list,
        'Asset_class_list': Asset_class_list,
        'Product_Type_list': Product_Type_list,
        'Basel_Approach_list': Basel_Approach_list,
        'ST_scenario_combo': ST_scenario_combo,
        'table_html': table_html
    }

    return render(request, 'mi_templates/mi_chart.html', context1)




// Assuming you're using jQuery for AJAX
$.ajax({
    url: '/mi_chart/',  // Update this to your actual URL
    type: 'POST',
    data: JSON.stringify(selectedItems),
    contentType: 'application/json',
    success: function(response) {
        $('#table-container').html(response.table_html);
    },
    error: function(error) {
        console.log('Error:', error);
    }
});

















from django.shortcuts import render
import pandas as pd
import os
import json
from django.views.decorators.csrf import csrf_exempt

FOLDER_PATH = "path/to/your/folder"

def get_folders():
    # Implement this function to return a list of folders
    pass

def get_subfolders(folder):
    # Implement this function to return a list of subfolders for a given folder
    pass

@csrf_exempt
def mi_chart(request):
    if request.method == 'POST':
        selected_items = json.loads(request.POST.get('selectedItems', '{}'))

        list_of_selected = [items for category, items in selected_items.items() if items]

        Organisational_unit_level_1_selected = list_of_selected[0]
        Organisational_unit_level_2_selected = list_of_selected[1]
        Organisational_unit_level_3_selected = list_of_selected[2]
        Country_of_Exposure_selected = list_of_selected[3]
        Asset_class_selected = list_of_selected[4]
        Product_Type_selected = list_of_selected[5]
        Basel_Approach_selected = list_of_selected[6]
        ST_scenario_selected = list_of_selected[7]

        folders = get_folders()
        selected_folder = request.POST.get("folder")
        selected_subfolder = request.POST.get("subfolder")
        subfolders = get_subfolders(selected_folder) if selected_folder else []

        row_names = [
            'Gross Balance ($ MM)', 'Net Balance ($ MM)', 'Net Balance Proportion S1', 'Net Balance Proportion S2',
            'Net Balance Proportion S3', 'ECL ($ MM)', 'ECL Original ($ MM)', 'ECL Rate', 'Loss at WO ($ MM)',
            'Loss at WO Original ($ MM)', 'LIC ($ MM)', 'LIC Original ($ MM)', 'LIC overlay ($ MM)', 'LIC Rate',
            'Coverage ratio', 'PD', 'LGD', 'EAD ($ MM)', 'RWA ($ MM)', 'RWA Original ($ MM)', 'RWA Overlay ($ MM)',
            'RWA Density', 'EL($ MM)', 'EL Overlay ($ MM)', 'EL Density'
        ]

        column_names = ['T0', 'T1', 'T2', 'T3', 'T4', 'T5']

        table_df = pd.DataFrame(index=row_names, columns=column_names)

        if selected_folder and selected_subfolder:
            folder_path = os.path.join(FOLDER_PATH, selected_folder, selected_subfolder)
            excel_files = [f for f in os.listdir(folder_path) if f.endswith('.xlsx')]

            # Read the Excel files and process the data
            # (Include your existing code for processing the Excel files here)

            # After processing, update the table_df with the calculated values

        table_html = table_df.to_html(classes="table table-striped table-bordered", index=True)

    else:
        folders = get_folders()
        selected_folder = request.GET.get("folder", None)
        selected_subfolder = request.GET.get("subfolder", None)
        subfolders = get_subfolders(selected_folder) if selected_folder else []

        table_df = pd.DataFrame(index=row_names)
        table_html = table_df.to_html(classes="table table-striped table-bordered", index=True)

    # Populate the lists (you need to implement these based on your data)
    Organisational_unit_level_1_list = []  # Populate this list
    Organisational_unit_level_2_list = []  # Populate this list
    Organisational_unit_level_3_list = []  # Populate this list
    Country_of_Exposure_list = []  # Populate this list
    Asset_class_list = []  # Populate this list
    Product_Type_list = []  # Populate this list
    Basel_Approach_list = []  # Populate this list
    ST_scenario_combo = []  # Populate this list

    context = {
        'Organisational_unit_level_1_list': Organisational_unit_level_1_list,
        'Organisational_unit_level_2_list': Organisational_unit_level_2_list,
        'Organisational_unit_level_3_list': Organisational_unit_level_3_list,
        'Country_of_Exposure_list': Country_of_Exposure_list,
        'Asset_class_list': Asset_class_list,
        'Product_Type_list': Product_Type_list,
        'Basel_Approach_list': Basel_Approach_list,
        'ST_scenario_combo': ST_scenario_combo,
        'table_html': table_html,
        'folders': folders,
        'selected_folder': selected_folder,
        'subfolders': subfolders,
        'selected_subfolder': selected_subfolder,
    }

    return render(request, 'mi_templates/mi_chart.html', context)




{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MI Chart</title>
    <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>
</head>
<body>
    <h1>MI Chart</h1>
    <form method="post">
        {% csrf_token %}
        <div>
            <label for="Organisational_unit_level_1">Organisational Unit Level 1:</label>
            <select name="Organisational_unit_level_1" id="Organisational_unit_level_1" multiple>
                {% for item in Organisational_unit_level_1_list %}
                    <option value="{{ item }}">{{ item }}</option>
                {% endfor %}
            </select>
        </div>
        <div>
            <label for="Organisational_unit_level_2">Organisational Unit Level 2:</label>
            <select name="Organisational_unit_level_2" id="Organisational_unit_level_2" multiple>
                {% for item in Organisational_unit_level_2_list %}
                    <option value="{{ item }}">{{ item }}</option>
                {% endfor %}
            </select>
        </div>
        <div>
            <label for="Organisational_unit_level_3">Organisational Unit Level 3:</label>
            <select name="Organisational_unit_level_3" id="Organisational_unit_level_3" multiple>
                {% for item in Organisational_unit_level_3_list %}
                    <option value="{{ item }}">{{ item }}</option>
                {% endfor %}
            </select>
        </div>
        <div>
            <label for="Country_of_Exposure">Country of Exposure:</label>
            <select name="Country_of_Exposure" id="Country_of_Exposure" multiple>
                {% for item in Country_of_Exposure_list %}
                    <option value="{{ item }}">{{ item }}</option>
                {% endfor %}
            </select>
        </div>
        <div>
            <label for="Asset_class">Asset Class:</label>
            <select name="Asset_class" id="Asset_class" multiple>
                {% for item in Asset_class_list %}
                    <option value="{{ item }}">{{ item }}</option>
                {% endfor %}
            </select>
        </div>
        <div>
            <label for="Product_Type">Product Type:</label>
            <select name="Product_Type" id="Product_Type" multiple>
                {% for item in Product_Type_list %}
                    <option value="{{ item }}">{{ item }}</option>
                {% endfor %}
            </select>
        </div>
        <div>
            <label for="Basel_Approach">Basel Approach:</label>
            <select name="Basel_Approach" id="Basel_Approach" multiple>
                {% for item in Basel_Approach_list %}
                    <option value="{{ item }}">{{ item }}</option>
                {% endfor %}
            </select>
        </div>
        <div>
            <label for="ST_scenario">ST Scenario:</label>
            <select name="ST_scenario" id="ST_scenario" multiple>
                {% for item in ST_scenario_combo %}
                    <option value="{{ item }}">{{ item }}</option>
                {% endfor %}
            </select>
        </div>
        <div>
            <label for="folder">Folder:</label>
            <select name="folder" id="folder">
                <option value="">Select a folder</option>
                {% for folder in folders %}
                    <option value="{{ folder }}" {% if folder == selected_folder %}selected{% endif %}>{{ folder }}</option>
                {% endfor %}
            </select>
        </div>
        <div>
            <label for="subfolder">Subfolder:</label>
            <select name="subfolder" id="subfolder">
                <option value="">Select a subfolder</option>
                {% for subfolder in subfolders %}
                    <option value="{{ subfolder }}" {% if subfolder == selected_subfolder %}selected{% endif %}>{{ subfolder }}</option>
                {% endfor %}
            </select>
        </div>
        <button type="submit">Generate Chart</button>
    </form>

    <div id="chart-container">
        {{ table_html|safe }}
    </div>

    <script>
        $(document).ready(function() {
            $('select').select2();

            $('form').on('submit', function(e) {
                e.preventDefault();
                var selectedItems = {};
                $('select[multiple]').each(function() {
                    selectedItems[$(this).attr('name')] = $(this).val();
                });
                $('input[name="selectedItems"]').val(JSON.stringify(selectedItems));
                this.submit();
            });

            $('#folder').on('change', function() {
                var folder = $(this).val();
                if (folder) {
                    window.location.href = '?folder=' + folder;
                }
            });
        });
    </script>
</body>
</html>



from django.shortcuts import render
import pandas as pd
import os
import json
from django.views.decorators.csrf import csrf_exempt

FOLDER_PATH = "path/to/your/folder"

def get_folders():
    # Implement this function to return a list of folders
    pass

def get_subfolders(folder):
    # Implement this function to return a list of subfolders for a given folder
    pass

@csrf_exempt
def mi_chart(request):
    folders = get_folders()
    selected_folder = request.POST.get("folder") or request.GET.get("folder")
    selected_subfolder = request.POST.get("subfolder") or request.GET.get("subfolder")
    subfolders = get_subfolders(selected_folder) if selected_folder else []

    row_names = [
        'Gross Balance ($ MM)', 'Net Balance ($ MM)', 'Net Balance Proportion S1', 'Net Balance Proportion S2',
        'Net Balance Proportion S3', 'ECL ($ MM)', 'ECL Original ($ MM)', 'ECL Rate', 'Loss at WO ($ MM)',
        'Loss at WO Original ($ MM)', 'LIC ($ MM)', 'LIC Original ($ MM)', 'LIC overlay ($ MM)', 'LIC Rate',
        'Coverage ratio', 'PD', 'LGD', 'EAD ($ MM)', 'RWA ($ MM)', 'RWA Original ($ MM)', 'RWA Overlay ($ MM)',
        'RWA Density', 'EL($ MM)', 'EL Overlay ($ MM)', 'EL Density'
    ]
    column_names = ['T0', 'T1', 'T2', 'T3', 'T4', 'T5']
    table_df = pd.DataFrame(index=row_names, columns=column_names)

    if request.method == 'POST':
        selected_items = json.loads(request.POST.get('selectedItems', '{}'))
        list_of_selected = [items for category, items in selected_items.items() if items]

        Organisational_unit_level_1_selected = list_of_selected[0]
        Organisational_unit_level_2_selected = list_of_selected[1]
        Organisational_unit_level_3_selected = list_of_selected[2]
        Country_of_Exposure_selected = list_of_selected[3]
        Asset_class_selected = list_of_selected[4]
        Product_Type_selected = list_of_selected[5]
        Basel_Approach_selected = list_of_selected[6]
        ST_scenario_selected = list_of_selected[7]

        if selected_folder and selected_subfolder:
            folder_path = os.path.join(FOLDER_PATH, selected_folder, selected_subfolder)
            excel_files = [f for f in os.listdir(folder_path) if f.endswith('.xlsx')]
            dataframes = {}

            for excel_file in excel_files:
                file_path = os.path.join(folder_path, excel_file)
                if "LIC" in excel_file and "HBAP" in excel_file:
                    if "FirstRun" in excel_file:
                        dataframes["lic_hbap_first_run"] = pd.read_excel(file_path, sheet_name="LPACT_OL_YTD_QTR_Final")
                    elif "LastRun" in excel_file:
                        dataframes['lic_hbap_last_run'] = pd.read_excel(file_path, sheet_name="LPACT_OL_YTD_QTR_Final")
                elif "LPACT" in excel_file and "HBAP" in excel_file:
                    dataframes['lpact_hbap_data'] = pd.read_excel(file_path, sheet_name="PD-series")
                elif "LIC" in excel_file and "NonHBAP" in excel_file:
                    if "FirstRun" in excel_file:
                        dataframes['lic_non_hbap_first_run'] = pd.read_excel(file_path, sheet_name="LPACT_OL_YTD_QTR_Final")
                    elif "LastRun" in excel_file:
                        dataframes['lic_non_hbap_last_run'] = pd.read_excel(file_path, sheet_name="LPACT_OL_YTD_QTR_Final")
                elif "LPACT" in excel_file and "Non" in excel_file and "HBAP" in excel_file:
                    dataframes['lpact_non_hbap_data'] = pd.read_excel(file_path, sheet_name="PD series")
                elif "MI" in excel_file and "HBAP" in excel_file:
                    if "FirstRun" in excel_file:
                        dataframes['rwa_hbap_first_run'] = pd.read_excel(file_path, sheet_name="Temp_RRM_Final_OL")
                    elif "LastRun" in excel_file:
                        dataframes['rwa_hbap_last_run'] = pd.read_excel(file_path, sheet_name="Temp_RRM_Final_OL")

            # Process the dataframes and update table_df
            # (Include your existing code for processing the dataframes here)

            # After processing, update the table_df with the calculated values

    table_html = table_df.to_html(classes="table table-striped table-bordered", index=True)

    # Populate the lists (you need to implement these based on your data)
    Organisational_unit_level_1_list = []  # Populate this list
    Organisational_unit_level_2_list = []  # Populate this list
    Organisational_unit_level_3_list = []  # Populate this list
    Country_of_Exposure_list = []  # Populate this list
    Asset_class_list = []  # Populate this list
    Product_Type_list = []  # Populate this list
    Basel_Approach_list = []  # Populate this list
    ST_scenario_combo = []  # Populate this list

    context = {
        'Organisational_unit_level_1_list': Organisational_unit_level_1_list,
        'Organisational_unit_level_2_list': Organisational_unit_level_2_list,
        'Organisational_unit_level_3_list': Organisational_unit_level_3_list,
        'Country_of_Exposure_list': Country_of_Exposure_list,
        'Asset_class_list': Asset_class_list,
        'Product_Type_list': Product_Type_list,
        'Basel_Approach_list': Basel_Approach_list,
        'ST_scenario_combo': ST_scenario_combo,
        'table_html': table_html,
        'folders': folders,
        'selected_folder': selected_folder,
        'subfolders': subfolders,
        'selected_subfolder': selected_subfolder,
    }

    return render(request, 'mi_templates/mi_chart.html', context)





{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MI Chart</title>
    <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>
</head>
<body>
    <h1>MI Chart</h1>
    <form method="post">
        {% csrf_token %}
        <div>
            <label for="Organisational_unit_level_1">Organisational Unit Level 1:</label>
            <select name="Organisational_unit_level_1" id="Organisational_unit_level_1" multiple>
                {% for item in Organisational_unit_level_1_list %}
                    <option value="{{ item }}">{{ item }}</option>
                {% endfor %}
            </select>
        </div>
        <div>
            <label for="Organisational_unit_level_2">Organisational Unit Level 2:</label>
            <select name="Organisational_unit_level_2" id="Organisational_unit_level_2" multiple>
                {% for item in Organisational_unit_level_2_list %}
                    <option value="{{ item }}">{{ item }}</option>
                {% endfor %}
            </select>
        </div>
        <div>
            <label for="Organisational_unit_level_3">Organisational Unit Level 3:</label>
            <select name="Organisational_unit_level_3" id="Organisational_unit_level_3" multiple>
                {% for item in Organisational_unit_level_3_list %}
                    <option value="{{ item }}">{{ item }}</option>
                {% endfor %}
            </select>
        </div>
        <div>
            <label for="Country_of_Exposure">Country of Exposure:</label>
            <select name="Country_of_Exposure" id="Country_of_Exposure" multiple>
                {% for item in Country_of_Exposure_list %}
                    <option value="{{ item }}">{{ item }}</option>
                {% endfor %}
            </select>
        </div>
        <div>
            <label for="Asset_class">Asset Class:</label>
            <select name="Asset_class" id="Asset_class" multiple>
                {% for item in Asset_class_list %}
                    <option value="{{ item }}">{{ item }}</option>
                {% endfor %}
            </select>
        </div>
        <div>
            <label for="Product_Type">Product Type:</label>
            <select name="Product_Type" id="Product_Type" multiple>
                {% for item in Product_Type_list %}
                    <option value="{{ item }}">{{ item }}</option>
                {% endfor %}
            </select>
        </div>
        <div>
            <label for="Basel_Approach">Basel Approach:</label>
            <select name="Basel_Approach" id="Basel_Approach" multiple>
                {% for item in Basel_Approach_list %}
                    <option value="{{ item }}">{{ item }}</option>
                {% endfor %}
            </select>
        </div>
        <div>
            <label for="ST_scenario">ST Scenario:</label>
            <select name="ST_scenario" id="ST_scenario" multiple>
                {% for item in ST_scenario_combo %}
                    <option value="{{ item }}">{{ item }}</option>
                {% endfor %}
            </select>
        </div>
        <div>
            <label for="folder">Folder:</label>
            <select name="folder" id="folder">
                <option value="">Select a folder</option>
                {% for folder in folders %}
                    <option value="{{ folder }}" {% if folder == selected_folder %}selected{% endif %}>{{ folder }}</option>
                {% endfor %}
            </select>
        </div>
        <div>
            <label for="subfolder">Subfolder:</label>
            <select name="subfolder" id="subfolder">
                <option value="">Select a subfolder</option>
                {% for subfolder in subfolders %}
                    <option value="{{ subfolder }}" {% if subfolder == selected_subfolder %}selected{% endif %}>{{ subfolder }}</option>
                {% endfor %}
            </select>
        </div>
        <button type="submit">Generate Chart</button>
    </form>

    <div id="chart-container">
        {{ table_html|safe }}
    </div>

    <script>
        $(document).ready(function() {
            $('select').select2();

            $('form').on('submit', function(e) {
                e.preventDefault();
                var selectedItems = {};
                $('select[multiple]').each(function() {
                    selectedItems[$(this).attr('name')] = $(this).val();
                });
                $('<input>').attr({
                    type: 'hidden',
                    name: 'selectedItems',
                    value: JSON.stringify(selectedItems)
                }).appendTo('form');
                this.submit();
            });

            $('#folder').on('change', function() {
                var folder = $(this).val();
                if (folder) {
                    $('form').submit();
                }
            });
        });
    </script>
</body>
</html>





import pandas as pd
import openpyxl

def Weighted_column_required(sheet):
    # Read the Excel file
    workbook_path = r".\Input\Mapping_File Copy.xlsx"
    df = pd.read_excel(workbook_path, sheet_name="Data_Edge")

    # Check the 'Weighted_required' column
    weighted_required = df['Weighted_required'].iloc[0]

    if weighted_required.lower() == 'no':
        # If 'No', delete the 'Weighted' column and the column before it
        workbook = openpyxl.load_workbook(workbook_path)
        ws = workbook[sheet]

        weighted_col = None
        for col in ws.iter_cols():
            if 'Weighted' in str(col[0].value):
                weighted_col = col[0].column
                break

        if weighted_col:
            ws.delete_cols(weighted_col - 1, 2)

        # Save the modified workbook
        workbook.save(workbook_path)
        print("Columns deleted successfully.")
    else:
        print("No changes required.")

# Usage
Weighted_column_required("Data_Edge")






import pandas as pd
import openpyxl

def Weighted_column_required(sheet_name):
    # Read the Excel file
    workbook_path = r".\Input\Mapping_File Copy.xlsx"
    df = pd.read_excel(workbook_path, sheet_name="Data_Edge")

    # Load the workbook and select the specified sheet
    workbook = openpyxl.load_workbook(workbook_path)
    ws = workbook[sheet_name]

    # Iterate through each row in the DataFrame
    for index, row in df.iterrows():
        description = row['Description']
        weighted_required = row['Weighted_required']

        # Find the cell with the description value
        for cell in ws['A']:
            if cell.value == description:
                row_num = cell.row

                # If Weighted_required is 'No', delete the 'Weighted' column and the one before it
                if weighted_required.lower() == 'no':
                    weighted_col = None
                    for col in ws[row_num]:
                        if 'Weighted' in str(col.value):
                            weighted_col = col.column
                            break

                    if weighted_col:
                        ws.delete_cols(weighted_col - 1, 2)
                        print(f"Columns deleted for description: {description}")
                break

    # Save the modified workbook
    workbook.save(workbook_path)
    print("Processing complete.")

# Usage
Weighted_column_required("Sheet1")  # Replace "Sheet1" with your actual sheet name









import pandas as pd
import openpyxl

def Weighted_column_required(sheet):
    # Read the Excel file
    workbook_path = r".\Input\Mapping_File Copy.xlsx"
    df = pd.read_excel(workbook_path, sheet_name="Data_Edge")

    # Iterate through each row in the DataFrame
    for index, row in df.iterrows():
        description = row['Description']
        weighted_required = row['Weighted_required']

        # Find the cell with the description value
        for row_cells in sheet.iter_rows():
            for cell in row_cells:
                if cell.value == description:
                    row_num = cell.row
                    col_num = cell.column

                    # If Weighted_required is 'No', delete specified columns
                    if weighted_required.lower() == 'no':
                        columns_to_delete = [col_num + 3, col_num + 4, col_num + 10, col_num + 11]
                        for col in sorted(columns_to_delete, reverse=True):
                            sheet.delete_cols(col)
                        print(f"Columns deleted for description: {description}")
                    break
            if cell.value == description:
                break

    print("Processing complete.")

# Note: This function should be called with an openpyxl worksheet object
# Example usage:
# workbook = openpyxl.load_workbook(workbook_path)
# sheet = workbook['Sheet1']
# Weighted_column_required(sheet)
# workbook.save(workbook_path)