from openpyxl.formatting.rule import ColorScaleRule
import numpy as np
from openpyxl import load_workbook

def conditional_formatting_IFRS1Q(sheet):
    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == '5yr Avg':
                # Define ranges for max, min, and average values
                max_value_range = sheet.iter_rows(min_row=cell.row + 18, max_row=cell.row + 21, min_col=cell.column + 1, max_col=cell.column + 4)
                min_value_range = sheet.iter_rows(min_row=cell.row + 18, max_row=cell.row + 21, min_col=cell.column + 1, max_col=cell.column + 4)
                avg_value_range = sheet.iter_rows(min_row=cell.row + 2, max_row=cell.row + 5, min_col=cell.column + 2, max_col=cell.column + 2)

                # Extract values from the ranges
                max_values = [c.value for r in max_value_range for c in r if isinstance(c.value, (int, float))]
                min_values = [c.value for r in min_value_range for c in r if isinstance(c.value, (int, float))]
                avg_values = [c.value for r in avg_value_range for c in r if isinstance(c.value, (int, float))]

                # Compute max, min, and average values
                max_value = max(max_values) if max_values else None
                min_value = min(min_values) if min_values else None
                avg_value = np.mean(avg_values) if avg_values else None

                # Skip if any value is not found
                if max_value is None or min_value is None or avg_value is None:
                    continue

                # Define the data range for conditional formatting
                data_range = f'{sheet.cell(row=cell.row + 12, column=cell.column + 1).coordinate}:{sheet.cell(row=cell.row + 11, column=cell.column + 4).coordinate}'

                # Define color scale rule
                min_color = 'FFCCCC'
                mid_color = 'FFFFFF'
                max_color = 'CCFFCC'

                rule = ColorScaleRule(start_type='min', start_value=min_value, start_color=min_color,
                                      mid_type='num', mid_value=avg_value, mid_color=mid_color,
                                      end_type='max', end_value=max_value, end_color=max_color)

                # Apply conditional formatting rule
                sheet.conditional_formatting.add(data_range, rule)

# Example usage
wb = load_workbook('your_workbook.xlsx')
sheet = wb['Sheet1']
conditional_formatting_IFRS1Q(sheet)
wb.save('your_workbook_with_formatting.xlsx')
















from openpyxl import load_workbook
from openpyxl.formatting.rule import ColorScaleRule
import numpy as np

def conditional_formatting_IFRS1Q(sheet):
    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == '5yr Avg':
                max_value_range = sheet.iter_rows(min_row=cell.row + 18, max_row=cell.row + 21, min_col=cell.column + 1, max_col=cell.column + 4)
                min_value_range = sheet.iter_rows(min_row=cell.row + 18, max_row=cell.row + 21, min_col=cell.column + 1, max_col=cell.column + 4)
                avg_value_range = sheet.iter_rows(min_row=cell.row + 2, max_row=cell.row + 5, min_col=cell.column + 2, max_col=cell.column + 2)

                max_values = [c.value for r in max_value_range for c in r if isinstance(c.value, (int, float))]
                min_values = [c.value for r in min_value_range for c in r if isinstance(c.value, (int, float))]
                avg_values = [c.value for r in avg_value_range for c in r if isinstance(c.value, (int, float))]

                max_value = max(max_values) if max_values else None
                min_value = min(min_values) if min_values else None
                avg_value = np.mean(avg_values) if avg_values else None

                if max_value is None or min_value is None or avg_value is None:
                    print(f"Skipping cell at {cell.coordinate} due to missing value.")
                    continue

                data_range = f'{sheet.cell(row=cell.row + 12, column=cell.column + 1).coordinate}:{sheet.cell(row=cell.row + 15, column=cell.column + 4).coordinate}'

                min_color = 'FFCCCC'
                mid_color = 'FFFFFF'
                max_color = 'CCFFCC'

                rule = ColorScaleRule(start_type='num', start_value=min_value, start_color=min_color,
                                      mid_type='num', mid_value=avg_value, mid_color=mid_color,
                                      end_type='num', end_value=max_value, end_color=max_color)

                sheet.conditional_formatting.add(data_range, rule)
                print(f"Applied conditional formatting to range: {data_range}")

# Use context manager to ensure the file is properly closed after processing
file_path = 'your_workbook.xlsx'
output_file_path = 'your_workbook_with_formatting.xlsx'

with load_workbook(file_path) as wb:
    sheet = wb['Sheet1']
    conditional_formatting_IFRS1Q(sheet)
    wb.save(output_file_path)

print(f"Workbook saved successfully to {output_file_path}")










df = pd.DataFrame(data)
iso_dict = {}
for index, row in df.iterrows():
    iso_code = row['ISOCODES']
    check = row['Checks']

    if iso_code not in iso_dict:
        iso_dict[iso_code] = []

    iso_dict[iso_code].append(check)

for iso_code in iso_dict:
    iso_dict[iso_code] = tuple(iso_dict[iso_code])

















change_name(sheet):

This function is responsible for renaming the column headers in the given sheet based on the country code.
It uses a dictionary A that maps country codes to lists of column names.
It iterates over each row and cell in the sheet and checks if the cell value matches the country code.
If a match is found, it replaces the cell value with the corresponding column name from the list associated with that country code.


add_output_columns(sheet):

This function calculates additional columns based on the existing columns in the given sheet.
It reads the data from the sheet into a Pandas DataFrame df.
It calculates year-over-year (YoY) and quarter-over-quarter (QoQ) percentage changes for various columns (e.g., GDP, CPI, PH, PH_DUBAI, PCOM).
It rounds the calculated values to one decimal place and returns the updated DataFrame.


calculate_5year_avg(frame, Isocode, tzero_date, col):

This function calculates the 5-year average for a given column col and country code Isocode.
It finds the row in the DataFrame frame that matches the Isocode and tzero_date.
It then calculates the mean of the next 20 values (representing the 5-year period) for the specified column.
It returns the calculated 5-year average.


calculate_weights(df_table, Isocode):

This function calculates and assigns weights to the rows of the DataFrame df_table based on the country code Isocode.
It reads scenario weights from a mapping file and merges them with the DataFrame based on the country code.
It calculates the weighted sum of the values in specific columns using the scenario weights.
It updates the DataFrame df_table with the calculated weighted values.


construct_and_populate_tables(Isocode, tzero_date, col):

This function constructs and populates a table (DataFrame) with data for a given country code Isocode, time zero date tzero_date, and column col.
It initializes a DataFrame df_table with a predefined column structure.
It iterates over the data frames in the All list and populates the df_table with the corresponding values based on the country code and dates.
It calculates additional columns like the 5-year average and weighted values using helper functions.
It rounds the values in the DataFrame and returns the populated df_table.


format_sheet(sheet):

This function formats the given sheet by applying various formatting rules.
It rounds the numeric values to one decimal place.
It applies a specific font to all cells.
It applies white font color to certain named ranges.
It applies a light gray fill color to certain rows and columns.
It applies bold formatting to specific rows and columns.
It applies conditional formatting based on decimal patterns and fills cells with a light gray color accordingly.
It applies thin borders to all cells.
It applies red and blue fill colors to specific named ranges.



The remaining functions perform tasks like conditional formatting, date writing, handling formatting for specific scenarios (e.g., IFRS1Q_1, IFRS1Q_2, IFRS1Q_3, IFRS_FIRST_Q, IFRS4Q), and more.
The overall logic seems to involve reading data from various sources, performing calculations and transformations, constructing tables (DataFrames) with the processed data, and formatting the tables according to specific rules and requirements. The code appears to be tailored for a specific data processing and reporting workflow.

























from datetime import datetime
from dateutil import relativedelta

zero_date = "2024-03-31"
zero_date = datetime.strptime(zero_date, "%Y-%m-%d")

zero_date_1 = zero_date.replace(year=zero_date.year - 1)
start_date = datetime.strptime(str(zero_date_1), "%Y-%m-%d")

date1 = start_date

date2 = (date1 + relativedelta(months=3)).replace(day=1) - relativedelta(months=1, days=-1)
date3 = (date2 + relativedelta(months=3)).replace(day=1) - relativedelta(months=1, days=-1)
date4 = (date3 + relativedelta(months=3)).replace(day=1) - relativedelta(months=1, days=-1)
date5 = (date4 + relativedelta(months=3)).replace(day=1) - relativedelta(months=1, days=-1)

date6 = (date5 + relativedelta(months=3)).replace(day=1) - relativedelta(months=1, days=-1)
date7 = (date6 + relativedelta(months=3)).replace(day=1) - relativedelta(months=1, days=-1)
date8 = (date7 + relativedelta(months=3)).replace(day=1) - relativedelta(months=1, days=-1)
date9 = (date8 + relativedelta(months=3)).replace(day=1) - relativedelta(months=1, days=-1)
date10 = (date9 + relativedelta(months=3)).replace(day=1) - relativedelta(months=1, days=-1)
date11 = (date10 + relativedelta(months=3)).replace(day=1) - relativedelta(months=1, days=-1)

dates = [
    date1.strftime("%d-%b-%y"), date2.strftime("%d-%b-%y"), date3.strftime("%d-%b-%y"), date4.strftime("%d-%b-%y"),
    date5.strftime("%d-%b-%y"), date6.strftime("%d-%b-%y"), date7.strftime("%d-%b-%y"), date8.strftime("%d-%b-%y"),
    date9.strftime("%d-%b-%y"), date10.strftime("%d-%b-%y"), date11.strftime("%d-%b-%y")
]
































import pandas as pd
from datetime import datetime, timedelta

# Read the data from the Excel file
data = pd.read_excel('mev-nz.xlsx')

# Create a list of unique country ISO codes
countries = data['ISOCODES'].unique().tolist()

# Create a list of column names for the dates
date_cols = [f"{d.strftime('%m/%d/%Y')}" for d in pd.date_range(start='12/31/2022', end='12/31/2052', freq='Q')]

# Create an empty DataFrame with the desired structure
mev_data = pd.DataFrame(index=data['GDP'].unique(), columns=['MEV Key', 'MEV Variable', 'Country ISO Code'] + date_cols + ['Region Mapped'])

# Iterate over each row in the original data
for row in data.itertuples(index=False):
    country = row.ISOCODES
    mev_key = row.GDP
    mev_var = row._fields[3]  # Assuming the variable name is in the 4th column

    # Create a new row in the mev_data DataFrame
    mev_data.loc[mev_key, 'MEV Key'] = mev_key
    mev_data.loc[mev_key, 'MEV Variable'] = mev_var
    mev_data.loc[mev_key, 'Country ISO Code'] = country

    # Get the start date and end date for the variable
    start_date = datetime(year=row.GDP_YR, month=1, day=1)
    end_date = start_date + timedelta(days=365)

    # Populate the values in the date columns
    for date_col in date_cols:
        date = datetime.strptime(date_col, '%m/%d/%Y')
        if start_date <= date < end_date:
            mev_data.loc[mev_key, date_col] = row._fields.index(mev_var)

# Write the data to a new Excel file
mev_data.to_excel('mev_data.xlsx', index=False)




















import pandas as pd
from datetime import datetime, timedelta

# Read the data from the Excel file
data = pd.read_excel('mev-nz.xlsx')

# Create a list of unique country ISO codes
countries = data['ISOCODES'].unique().tolist()

# Create a list of column names for the dates
date_cols = ['12/31/2022', '3/31/2023'] + [f"{d.strftime('%m/%d/%Y')}" for d in pd.date_range(start='6/30/2023', end='12/31/2052', freq='Q')]

# Create an empty DataFrame with the desired structure
mev_data = pd.DataFrame(columns=['MEV Key', 'MEV Variable', 'Country ISO Code'] + date_cols + ['Region Mapped'])

# Iterate over each row in the original data
for row in data.itertuples(index=False):
    country = row.ISOCODES
    mev_key = row.GDP
    mev_var = row._fields[3]  # Assuming the variable name is in the 4th column

    # Ensure GDP_YR can be converted to an integer, if not, skip this row
    try:
        gdp_year = int(row.GDP_YR)
        if gdp_year < 1:
            continue
    except (ValueError, TypeError):
        continue

    # Get the start date and end date for the variable
    start_date = datetime(year=gdp_year, month=1, day=1)
    end_date = start_date + timedelta(days=365)

    # Check if the key exists in mev_data, if not, add it
    if mev_key not in mev_data.index:
        mev_data.loc[mev_key] = [mev_key, mev_var, country] + [None] * (len(date_cols) + 1)

    # Populate the values in the date columns
    for date_col in date_cols:
        date = datetime.strptime(date_col, '%m/%d/%Y')
        if start_date <= date < end_date:
            if pd.isna(mev_data.loc[mev_key, date_col]):
                mev_data.loc[mev_key, date_col] = mev_var
            else:
                mev_data.loc[mev_key, date_col] = f"{mev_data.loc[mev_key, date_col]}, {mev_var}"

# Write the data to a new Excel file
mev_data.to_excel('mev_data.xlsx', index=False)

























import pandas as pd
from datetime import datetime, timedelta

# Read the data from the Excel file
data = pd.read_excel('mev-nz.xlsx')

# Create a list of unique country ISO codes
countries = data['ISOCODES'].unique().tolist()

# Create a list of column names for the dates
date_cols = ['3/31/2021', '6/30/2021', '9/30/2021', '12/31/2021', '3/31/2022', '6/30/2022', '9/30/2022', '12/31/2022', '3/31/2023'] + \
    [f"{d.strftime('%m/%d/%Y')}" for d in pd.date_range(start='6/30/2023', end='12/31/2052', freq='Q')]

# Create an empty DataFrame with the desired structure
mev_data = pd.DataFrame(columns=['MEV Key', 'MEV Variable', 'Country ISO Code', 'Region Mapped'] + date_cols)

# Iterate over each row in the original data
for row in data.itertuples(index=False):
    country = row.ISOCODES
    mev_key = row.GDP
    mev_var = row._fields[3]  # Assuming the variable name is in the 4th column

    # Ensure GDP_YR can be converted to an integer, if not, skip this row
    try:
        gdp_year = int(row.GDP_YR)
        if gdp_year < 1:
            continue
    except (ValueError, TypeError):
        continue

    # Get the start date and end date for the variable
    start_date = datetime(year=gdp_year, month=1, day=1)
    end_date = start_date + timedelta(days=365)

    # Check if the key exists in mev_data, if not, add it
    if mev_key not in mev_data.index:
        mev_data.loc[mev_key] = [mev_key, mev_var, country, None] + [None] * len(date_cols)

    # Populate the values in the date columns
    for date_col in date_cols:
        date = datetime.strptime(date_col, '%m/%d/%Y')
        if start_date <= date < end_date:
            if pd.isna(mev_data.loc[mev_key, date_col]):
                mev_data.loc[mev_key, date_col] = mev_var
            else:
                mev_data.loc[mev_key, date_col] = f"{mev_data.loc[mev_key, date_col]}, {mev_var}"

# Write the data to a new Excel file
mev_data.to_excel('mev_data.xlsx', index=False)















import pandas as pd
from datetime import datetime, timedelta

# Read the data from the Excel file
data = pd.read_excel('mev-nz.xlsx')

# Create a list of unique country ISO codes
countries = data['ISOCODES'].unique().tolist()

# Create a list of column names for the dates
date_cols = ['3/31/2021', '6/30/2021', '9/30/2021', '12/31/2021', '3/31/2022', '6/30/2022', '9/30/2022', '12/31/2022', '3/31/2023'] + [f"{d.strftime('%m/%d/%Y')}" for d in pd.date_range(start='6/30/2023', end='12/31/2052', freq='Q')]

# Create an empty DataFrame with the desired structure
mev_data = pd.DataFrame(columns=['MEV Key', 'MEV Variable', 'Country ISO Code', 'Region Mapped'] + date_cols)

# Iterate over each row in the original data
for _, row in data.iterrows():
    country = row['ISOCODES']
    mev_key = row['GDP']
    mev_var = row.iloc[3]  # Assuming the variable name is in the 4th column

    # Ensure GDP_YR can be converted to an integer, if not, skip this row
    try:
        gdp_year = int(row['GDP_YR'])
        if gdp_year < 1:
            continue
    except (ValueError, TypeError):
        continue

    # Get the start date and end date for the variable
    start_date = datetime(year=gdp_year, month=1, day=1)
    end_date = start_date + timedelta(days=365)

    # Check if the key exists in mev_data, if not, add it
    if mev_key not in mev_data.index:
        mev_data.loc[mev_key] = [mev_key, mev_var, country, None] + [None] * len(date_cols)

    # Populate the values in the date columns
    for date_col in date_cols:
        date = datetime.strptime(date_col, '%m/%d/%Y')
        if start_date <= date < end_date:
            if pd.isna(mev_data.loc[mev_key, date_col]):
                mev_data.loc[mev_key, date_col] = mev_var
            else:
                mev_data.loc[mev_key, date_col] = f"{mev_data.loc[mev_key, date_col]}, {mev_var}"

# Write the data to a new Excel file
mev_data.to_excel('mev_data.xlsx', index=False)

print(dates)



















import pandas as pd
from datetime import datetime, timedelta

# Read the data from the Excel file
data = pd.read_excel('mev-nz.xlsx')

# Create a list of unique country ISO codes
countries = data['ISOCODES'].unique().tolist()

# Create a list of column names for the dates
date_cols = ['3/31/2021', '6/30/2021', '9/30/2021', '12/31/2021', '3/31/2022', '6/30/2022', '9/30/2022', '12/31/2022', '3/31/2023'] + [f"{d.strftime('%m/%d/%Y')}" for d in pd.date_range(start='6/30/2023', end='12/31/2052', freq='Q')]

# Create an empty DataFrame with the desired structure
mev_data = pd.DataFrame(columns=['MEV Key', 'MEV Variable', 'Country ISO Code', 'Region Mapped'] + date_cols)

# Iterate over each row in the original data
for _, row in data.iterrows():
    country = row['ISOCODES']
    mev_var = row.iloc[3]  # Assuming the variable name is in the 4th column
    region_mapped = row['GDP']

    # Ensure GDP_YR can be converted to an integer, if not, skip this row
    try:
        gdp_year = int(row['GDP_YR'])
        if gdp_year < 1:
            continue
    except (ValueError, TypeError):
        continue

    # Create the MEV Key based on the Region Mapped and MEV Variable
    mev_key = f"{region_mapped}_{mev_var}"

    # Get the start date and end date for the variable
    start_date = datetime(year=gdp_year, month=1, day=1)
    end_date = start_date + timedelta(days=365)

    # Check if the key exists in mev_data, if not, add it
    if mev_key not in mev_data.index:
        mev_data.loc[mev_key] = [mev_key, mev_var, country, region_mapped] + [None] * len(date_cols)

    # Populate the values in the date columns
    for date_col in date_cols:
        date = datetime.strptime(date_col, '%m/%d/%Y')
        if start_date <= date < end_date:
            if pd.isna(mev_data.loc[mev_key, date_col]):
                mev_data.loc[mev_key, date_col] = mev_var
            else:
                mev_data.loc[mev_key, date_col] = f"{mev_data.loc[mev_key, date_col]}, {mev_var}"

# Write the data to a new Excel file
mev_data.to_excel('mev_data.xlsx', index=False)























import pandas as pd
from datetime import datetime, timedelta

# Read the data from the Excel file
data = pd.read_excel('mev-nz.xlsx')

# Create a list of unique country ISO codes
countries = data['ISOCODES'].unique().tolist()

# Create a list of column names for the dates
date_cols = ['3/31/2021', '6/30/2021', '9/30/2021', '12/31/2021', '3/31/2022', '6/30/2022', '9/30/2022', '12/31/2022', '3/31/2023'] + [f"{d.strftime('%m/%d/%Y')}" for d in pd.date_range(start='6/30/2023', end='12/31/2052', freq='Q')]

# Create an empty DataFrame with the desired structure
mev_data = pd.DataFrame(columns=['MEV Key', 'MEV Variable', 'Country ISO Code', 'Region Mapped'] + date_cols)

# Iterate over each row in the original data
for row in data.itertuples(index=False):
    country = row.ISOCODES
    mev_var = row._fields[3]  # Assuming the variable name is in the 4th column
    region_mapped = row._fields[4]  # Assuming the region mapped is in the 5th column
    mev_key = f"{region_mapped}_{mev_var}"

    # Ensure GDP_YR can be converted to an integer, if not, skip this row
    try:
        gdp_year = int(row.GDP_YR)
        if gdp_year < 1:
            continue
    except (ValueError, TypeError):
        continue

    # Get the start date and end date for the variable
    start_date = datetime(year=gdp_year, month=1, day=1)
    end_date = start_date + timedelta(days=365)

    # Check if the key exists in mev_data, if not, add it
    if mev_key not in mev_data.index:
        mev_data.loc[mev_key] = [mev_key, mev_var, country, region_mapped] + [None] * len(date_cols)

    # Populate the values in the date columns
    for date_col in date_cols:
        date = datetime.strptime(date_col, '%m/%d/%Y')
        if start_date <= date < end_date:
            if pd.isna(mev_data.loc[mev_key, date_col]):
                mev_data.loc[mev_key, date_col] = mev_var
            else:
                mev_data.loc[mev_key, date_col] = f"{mev_data.loc[mev_key, date_col]}, {mev_var}"

# Write the data to a new Excel file
mev_data.to_excel('mev_data.xlsx', index=False)











import pandas as pd
from datetime import datetime, timedelta

# Read the data from the Excel file
data = pd.read_excel('mev-nz.xlsx')

# Create a list of unique country ISO codes
countries = data['ISOCODES'].unique().tolist()

# Create a list of column names for the dates
date_cols = ['3/31/2021', '6/30/2021', '9/30/2021', '12/31/2021', '3/31/2022', '6/30/2022', '9/30/2022', '12/31/2022', '3/31/2023'] + [f"{d.strftime('%m/%d/%Y')}" for d in pd.date_range(start='6/30/2023', end='12/31/2052', freq='Q')]

# Create an empty DataFrame with the desired structure
mev_data = pd.DataFrame(columns=['MEV Key', 'MEV Variable', 'Country ISO Code', 'Region Mapped'] + date_cols)

# Iterate over each row in the original data
for row in data.itertuples(index=False):
    country = row.ISOCODES
    mev_var = row.MEV_Variable
    region_mapped = row.Region_Mapped
    mev_key = f"{row.Region_Mapped}_{row.MEV_Variable}"

    # Ensure GDP_YR can be converted to an integer, if not, skip this row
    try:
        gdp_year = int(row.GDP_YR)
        if gdp_year < 1:
            continue
    except (ValueError, TypeError):
        continue

    # Get the start date and end date for the variable
    start_date = datetime(year=gdp_year, month=1, day=1)
    end_date = start_date + timedelta(days=365)

    # Check if the key exists in mev_data, if not, add it
    if mev_key not in mev_data.index:
        mev_data.loc[mev_key] = [mev_key, mev_var, country, region_mapped] + [None] * len(date_cols)

    # Populate the values in the date columns
    for date_col in date_cols:
        date = datetime.strptime(date_col, '%m/%d/%Y')
        if start_date <= date <= end_date:
            values = mev_data.loc[mev_key, date_col]
            if pd.isna(values):
                values = [mev_var]
            elif mev_var not in values:
                values.append(mev_var)
            mev_data.loc[mev_key, date_col] = values

# Convert list values in date columns to comma-separated strings
mev_data[date_cols] = mev_data[date_cols].apply(lambda x: x.apply(lambda y: ', '.join(map(str, y)) if isinstance(y, list) else y))

# Write the data to a new Excel file
mev_data.to_excel('mev_data.xlsx', index=False)
















import pandas as pd
from datetime import datetime

# Function to get user input for column names
def get_column_names():
    columns = []
    num_columns = int(input("Enter the number of columns: "))
    for i in range(num_columns):
        mev_variable = input(f"Enter the MEV Variable for column {i+1}: ")
        scenario_type = input(f"Enter the Scenario Type for column {i+1}: ")
        scenario_detail = input(f"Enter the Scenario Detail for column {i+1}: ")
        columns.append(('Unemployment Rate (%)', scenario_type, scenario_detail))
    return columns

# Define the current year
curr_year = datetime.now().year

# Get user input for the multi-level column names
column_1 = get_column_names()

# Define the row indices
rows = [
    'Q1', 'Q2', 'Q3', 'Q4',
    str(curr_year), 'Q1', 'Q2', 'Q3', 'Q4',
    str(curr_year + 1), str(curr_year + 2), str(curr_year + 3),
    '5yr Avg'
]

# Create the DataFrame with the specified structure
df_table = pd.DataFrame(columns=pd.MultiIndex.from_tuples(column_1), index=rows)

# Display the DataFrame structure
print(df_table)






















import pandas as pd
from datetime import datetime
import tkinter as tk
from tkinter import simpledialog

# Initialize Tkinter
root = tk.Tk()
root.withdraw()  # Hide the root window

# Function to get user input for parts of the column names
def get_user_input(prompt, cache={}):
    if prompt not in cache:
        cache[prompt] = simpledialog.askstring("Input", prompt)
    return cache[prompt]

# Define the prompts for unique parts of the column names
prompts = {
    "Unemployment Rate (%)": "Enter the name for 'Unemployment Rate (%)': ",
    "IFRS9 1024 Scenarios": "Enter the name for 'IFRS9 1024 Scenarios': ",
    "IFRS9 4023 Scenarios": "Enter the name for 'IFRS9 4023 Scenarios': ",
    "Hoody's": "Enter the name for 'Hoody's': ",
    "Upside": "Enter the name for 'Upside': ",
    "Central": "Enter the name for 'Central': ",
    "Down 1": "Enter the name for 'Down 1': ",
    "Down 2": "Enter the name for 'Down 2': ",
    "Weighted": "Enter the name for 'Weighted': ",
    "10% UP": "Enter the name for '10% UP': ",
    "10% DN": "Enter the name for '10% DN': ",
    "4% DN": "Enter the name for '4% DN': "
}

# Get user inputs for the column names
column_1 = [
    (get_user_input(prompts["Unemployment Rate (%)"]), get_user_input(prompts["IFRS9 1024 Scenarios"]), get_user_input(prompts["Upside"])),
    (get_user_input(prompts["Unemployment Rate (%)"]), get_user_input(prompts["IFRS9 1024 Scenarios"]), get_user_input(prompts["Central"])),
    (get_user_input(prompts["Unemployment Rate (%)"]), get_user_input(prompts["IFRS9 1024 Scenarios"]), get_user_input(prompts["Down 1"])),
    (get_user_input(prompts["Unemployment Rate (%)"]), get_user_input(prompts["IFRS9 1024 Scenarios"]), get_user_input(prompts["Down 2"])),
    (get_user_input(prompts["Unemployment Rate (%)"]), get_user_input(prompts["IFRS9 4023 Scenarios"]), get_user_input(prompts["Upside"])),
    (get_user_input(prompts["Unemployment Rate (%)"]), get_user_input(prompts["IFRS9 4023 Scenarios"]), get_user_input(prompts["Central"])),
    (get_user_input(prompts["Unemployment Rate (%)"]), get_user_input(prompts["IFRS9 4023 Scenarios"]), get_user_input(prompts["Down 1"])),
    (get_user_input(prompts["Unemployment Rate (%)"]), get_user_input(prompts["IFRS9 4023 Scenarios"]), get_user_input(prompts["Down 2"])),
    (get_user_input(prompts["Unemployment Rate (%)"]), get_user_input(prompts["IFRS9 4023 Scenarios"]), get_user_input(prompts["Weighted"])),
    (get_user_input(prompts["Unemployment Rate (%)"]), get_user_input(prompts["Hoody's"]), get_user_input(prompts["10% UP"])),
    (get_user_input(prompts["Unemployment Rate (%)"]), get_user_input(prompts["Hoody's"]), get_user_input(prompts["Central"])),
    (get_user_input(prompts["Unemployment Rate (%)"]), get_user_input(prompts["Hoody's"]), get_user_input(prompts["10% DN"])),
    (get_user_input(prompts["Unemployment Rate (%)"]), get_user_input(prompts["Hoody's"]), get_user_input(prompts["4% DN"]))
]

# Define the current year
curr_year = datetime.now().year

# Define the row indices
rows = [
    'Q1', 'Q2', 'Q3', 'Q4',
    str(curr_year), 'Q1', 'Q2', 'Q3', 'Q4',
    str(curr_year + 1), str(curr_year + 2), str(curr_year + 3),
    '5yr Avg'
]

# Create the DataFrame with the specified structure
df_table = pd.DataFrame(columns=pd.MultiIndex.from_tuples(column_1), index=rows)

# Display the DataFrame structure
print(df_table)

# Close the Tkinter root window
root.destroy()
























import pandas as pd
from datetime import datetime
import tkinter as tk
from tkinter import simpledialog

# Initialize Tkinter
root = tk.Tk()
root.withdraw()  # Hide the root window

# Function to get user input for parts of the column names, using a cache to avoid duplicate prompts
def get_user_input(prompt, cache={}):
    if prompt not in cache:
        cache[prompt] = simpledialog.askstring("Input", prompt)
    return cache[prompt]

# Define the prompts for unique parts of the column names
prompts = {
    "Unemployment Rate (%)": "Enter the name for 'Unemployment Rate (%)': ",
    "IFRS9 1024 Scenarios": "Enter the name for 'IFRS9 1024 Scenarios': ",
    "IFRS9 4023 Scenarios": "Enter the name for 'IFRS9 4023 Scenarios': ",
    "Hoody's": "Enter the name for 'Hoody's': ",
    "Upside": "Enter the name for 'Upside': ",
    "Central": "Enter the name for 'Central': ",
    "Down 1": "Enter the name for 'Down 1': ",
    "Down 2": "Enter the name for 'Down 2': ",
    "Weighted": "Enter the name for 'Weighted': ",
    "10% UP": "Enter the name for '10% UP': ",
    "10% DN": "Enter the name for '10% DN': ",
    "4% DN": "Enter the name for '4% DN': "
}

# Cache for user inputs
input_cache = {}

# Get user inputs for the column names
column_1 = [
    (get_user_input(prompts["Unemployment Rate (%)"], input_cache), get_user_input(prompts["IFRS9 1024 Scenarios"], input_cache), get_user_input(prompts["Upside"], input_cache)),
    (get_user_input(prompts["Unemployment Rate (%)"], input_cache), get_user_input(prompts["IFRS9 1024 Scenarios"], input_cache), get_user_input(prompts["Central"], input_cache)),
    (get_user_input(prompts["Unemployment Rate (%)"], input_cache), get_user_input(prompts["IFRS9 1024 Scenarios"], input_cache), get_user_input(prompts["Down 1"], input_cache)),
    (get_user_input(prompts["Unemployment Rate (%)"], input_cache), get_user_input(prompts["IFRS9 1024 Scenarios"], input_cache), get_user_input(prompts["Down 2"], input_cache)),
    (get_user_input(prompts["Unemployment Rate (%)"], input_cache), get_user_input(prompts["IFRS9 4023 Scenarios"], input_cache), get_user_input(prompts["Upside"], input_cache)),
    (get_user_input(prompts["Unemployment Rate (%)"], input_cache), get_user_input(prompts["IFRS9 4023 Scenarios"], input_cache), get_user_input(prompts["Central"], input_cache)),
    (get_user_input(prompts["Unemployment Rate (%)"], input_cache), get_user_input(prompts["IFRS9 4023 Scenarios"], input_cache), get_user_input(prompts["Down 1"], input_cache)),
    (get_user_input(prompts["Unemployment Rate (%)"], input_cache), get_user_input(prompts["IFRS9 4023 Scenarios"], input_cache), get_user_input(prompts["Down 2"], input_cache)),
    (get_user_input(prompts["Unemployment Rate (%)"], input_cache), get_user_input(prompts["IFRS9 4023 Scenarios"], input_cache), get_user_input(prompts["Weighted"], input_cache)),
    (get_user_input(prompts["Unemployment Rate (%)"], input_cache), get_user_input(prompts["Hoody's"], input_cache), get_user_input(prompts["10% UP"], input_cache)),
    (get_user_input(prompts["Unemployment Rate (%)"], input_cache), get_user_input(prompts["Hoody's"], input_cache), get_user_input(prompts["Central"], input_cache)),
    (get_user_input(prompts["Unemployment Rate (%)"], input_cache), get_user_input(prompts["Hoody's"], input_cache), get_user_input(prompts["10% DN"], input_cache)),
    (get_user_input(prompts["Unemployment Rate (%)"], input_cache), get_user_input(prompts["Hoody's"], input_cache), get_user_input(prompts["4% DN"], input_cache))
]

# Define the current year
curr_year = datetime.now().year

# Define the row indices
rows = [
    'Q1', 'Q2', 'Q3', 'Q4',
    str(curr_year), 'Q1', 'Q2', 'Q3', 'Q4',
    str(curr_year + 1), str(curr_year + 2), str(curr_year + 3),
    '5yr Avg'
]

# Create the DataFrame with the specified structure
df_table = pd.DataFrame(columns=pd.MultiIndex.from_tuples(column_1), index=rows)

# Display the DataFrame structure
print(df_table)

# Close the Tkinter root window
root.destroy()


























import pandas as pd
from datetime import datetime
import tkinter as tk
from tkinter import simpledialog

# Initialize Tkinter
root = tk.Tk()
root.withdraw()  # Hide the root window

# Define the prompts for unique parts of the column names
prompts = {
    "Unemployment Rate (%)": "Enter the name for 'Unemployment Rate (%)': ",
    "IFRS9 1024 Scenarios": "Enter the name for 'IFRS9 1024 Scenarios': ",
    "IFRS9 4023 Scenarios": "Enter the name for 'IFRS9 4023 Scenarios': ",
    "Hoody's": "Enter the name for 'Hoody's': ",
    "Upside": "Enter the name for 'Upside': ",
    "Central": "Enter the name for 'Central': ",
    "Down 1": "Enter the name for 'Down 1': ",
    "Down 2": "Enter the name for 'Down 2': ",
    "Weighted": "Enter the name for 'Weighted': ",
    "10% UP": "Enter the name for '10% UP': ",
    "10% DN": "Enter the name for '10% DN': ",
    "4% DN": "Enter the name for '4% DN': "
}

# Get user inputs for the unique parts of the column names
input_cache = {prompt: simpledialog.askstring("Input", prompt) for prompt in prompts.values()}

# Define the column names
column_1 = [
    (input_cache[prompts["Unemployment Rate (%)"]], input_cache[prompts["IFRS9 1024 Scenarios"]], input_cache[prompts["Upside"]]),
    (input_cache[prompts["Unemployment Rate (%)"]], input_cache[prompts["IFRS9 1024 Scenarios"]], input_cache[prompts["Central"]]),
    (input_cache[prompts["Unemployment Rate (%)"]], input_cache[prompts["IFRS9 1024 Scenarios"]], input_cache[prompts["Down 1"]]),
    (input_cache[prompts["Unemployment Rate (%)"]], input_cache[prompts["IFRS9 1024 Scenarios"]], input_cache[prompts["Down 2"]]),
    (input_cache[prompts["Unemployment Rate (%)"]], input_cache[prompts["IFRS9 4023 Scenarios"]], input_cache[prompts["Upside"]]),
    (input_cache[prompts["Unemployment Rate (%)"]], input_cache[prompts["IFRS9 4023 Scenarios"]], input_cache[prompts["Central"]]),
    (input_cache[prompts["Unemployment Rate (%)"]], input_cache[prompts["IFRS9 4023 Scenarios"]], input_cache[prompts["Down 1"]]),
    (input_cache[prompts["Unemployment Rate (%)"]], input_cache[prompts["IFRS9 4023 Scenarios"]], input_cache[prompts["Down 2"]]),
    (input_cache[prompts["Unemployment Rate (%)"]], input_cache[prompts["IFRS9 4023 Scenarios"]], input_cache[prompts["Weighted"]]),
    (input_cache[prompts["Unemployment Rate (%)"]], input_cache[prompts["Hoody's"]], input_cache[prompts["10% UP"]]),
    (input_cache[prompts["Unemployment Rate (%)"]], input_cache[prompts["Hoody's"]], input_cache[prompts["Central"]]),
    (input_cache[prompts["Unemployment Rate (%)"]], input_cache[prompts["Hoody's"]], input_cache[prompts["10% DN"]]),
    (input_cache[prompts["Unemployment Rate (%)"]], input_cache[prompts["Hoody's"]], input_cache[prompts["4% DN"]])
]

# Define the current year
curr_year = datetime.now().year

# Define the row indices
rows = [
    'Q1', 'Q2', 'Q3', 'Q4',
    str(curr_year), 'Q1', 'Q2', 'Q3', 'Q4',
    str(curr_year + 1), str(curr_year + 2), str(curr_year + 3),
    '5yr Avg'
]

# Create the DataFrame with the specified structure
df_table = pd.DataFrame(columns=pd.MultiIndex.from_tuples(column_1), index=rows)

# Display the DataFrame structure
print(df_table)

# Close the Tkinter root window
root.destroy()
































import pandas as pd
from datetime import datetime
import tkinter as tk
from tkinter import simpledialog

# Initialize Tkinter
root = tk.Tk()
root.withdraw()  # Hide the root window

# Define the prompts for unique parts of the column names
prompts = [
    "Enter the name for 'Unemployment Rate (%)': ",
    "Enter the name for 'IFRS9 1024 Scenarios': ",
    "Enter the name for 'IFRS9 4023 Scenarios': ",
    "Enter the name for 'Hoody's': ",
    "Enter the name for 'Upside': ",
    "Enter the name for 'Central': ",
    "Enter the name for 'Down 1': ",
    "Enter the name for 'Down 2': ",
    "Enter the name for 'Weighted': ",
    "Enter the name for '10% UP': ",
    "Enter the name for '10% DN': ",
    "Enter the name for '4% DN': "
]

# Get user inputs for the unique parts of the column names
user_inputs = []
for prompt in prompts:
    user_input = simpledialog.askstring("Input", prompt)
    if user_input is None:
        break
    user_inputs.append(user_input)

# Check if all inputs were provided
if len(user_inputs) != len(prompts):
    print("Incomplete inputs provided. Exiting...")
    root.destroy()
    exit()

# Define the column names
column_1 = [
    (user_inputs[0], user_inputs[1], user_inputs[4]),
    (user_inputs[0], user_inputs[1], user_inputs[5]),
    (user_inputs[0], user_inputs[1], user_inputs[6]),
    (user_inputs[0], user_inputs[1], user_inputs[7]),
    (user_inputs[0], user_inputs[2], user_inputs[4]),
    (user_inputs[0], user_inputs[2], user_inputs[5]),
    (user_inputs[0], user_inputs[2], user_inputs[6]),
    (user_inputs[0], user_inputs[2], user_inputs[7]),
    (user_inputs[0], user_inputs[2], user_inputs[8]),
    (user_inputs[0], user_inputs[3], user_inputs[9]),
    (user_inputs[0], user_inputs[3], user_inputs[5]),
    (user_inputs[0], user_inputs[3], user_inputs[10]),
    (user_inputs[0], user_inputs[3], user_inputs[11])
]

# Define the current year
curr_year = datetime.now().year

# Define the row indices
rows = [
    'Q1', 'Q2', 'Q3', 'Q4',
    str(curr_year), 'Q1', 'Q2', 'Q3', 'Q4',
    str(curr_year + 1), str(curr_year + 2), str(curr_year + 3),
    '5yr Avg'
]

# Create the DataFrame with the specified structure
df_table = pd.DataFrame(columns=pd.MultiIndex.from_tuples(column_1), index=rows)

# Display the DataFrame structure
print(df_table)

# Close the Tkinter root window
root.destroy()











import pandas as pd
from datetime import datetime
import tkinter as tk
from tkinter import simpledialog

# Initialize Tkinter
root = tk.Tk()
root.withdraw()  # Hide the root window

# Define the prompts for unique parts of the column names
prompts = [
    "Enter the name for 'Unemployment Rate (%)': ",
    "Enter the name for 'IFRS9 1024 Scenarios': ",
    "Enter the name for 'IFRS9 4023 Scenarios': ",
    "Enter the name for 'Hoody's': ",
    "Enter the name for 'Upside': ",
    "Enter the name for 'Central': ",
    "Enter the name for 'Down 1': ",
    "Enter the name for 'Down 2': ",
    "Enter the name for 'Weighted': ",
    "Enter the name for '10% UP': ",
    "Enter the name for '10% DN': ",
    "Enter the name for '4% DN': "
]

# Get user inputs for the unique parts of the column names
user_inputs = []
for prompt in prompts:
    user_input = simpledialog.askstring("Input", prompt)
    if user_input is None:
        break
    user_inputs.append(user_input)

# Check if all inputs were provided
if len(user_inputs) != len(prompts):
    print("Incomplete inputs provided. Exiting...")
    root.destroy()
    exit()

# Define the column names
column_1 = [
    (user_inputs[0], user_inputs[1], user_inputs[4]),
    (user_inputs[0], user_inputs[1], user_inputs[5]),
    (user_inputs[0], user_inputs[1], user_inputs[6]),
    (user_inputs[0], user_inputs[1], user_inputs[7]),
    (user_inputs[0], user_inputs[2], user_inputs[4]),
    (user_inputs[0], user_inputs[2], user_inputs[5]),
    (user_inputs[0], user_inputs[2], user_inputs[6]),
    (user_inputs[0], user_inputs[2], user_inputs[7]),
    (user_inputs[0], user_inputs[2], user_inputs[8]),
    (user_inputs[0], user_inputs[3], user_inputs[9]),
    (user_inputs[0], user_inputs[3], user_inputs[5]),
    (user_inputs[0], user_inputs[3], user_inputs[10]),
    (user_inputs[0], user_inputs[3], user_inputs[11])
]

# Define the current year
curr_year = datetime.now().year

# Define the row indices
rows = [
    'Q1', 'Q2', 'Q3', 'Q4',
    str(curr_year), 'Q1', 'Q2', 'Q3', 'Q4',
    str(curr_year + 1), str(curr_year + 2), str(curr_year + 3),
    '5yr Avg'
]

# Create the DataFrame with the specified structure
df_table = pd.DataFrame(columns=pd.MultiIndex.from_tuples(column_1), index=rows)

# Display the DataFrame structure
print(df_table)

# Close the Tkinter root window
root.destroy()






















import pandas as pd
from datetime import datetime
import tkinter as tk
from tkinter import simpledialog

# Initialize Tkinter
root = tk.Tk()
root.withdraw()  # Hide the root window

# Define the prompts for unique parts of the column names
prompts = [
    "Enter the name for 'Unemployment Rate (%)': ",
    "Enter the name for 'IFRS9 1024 Scenarios': ",
    "Enter the name for 'IFRS9 4023 Scenarios': ",
    "Enter the name for 'Hoody's': ",
    "Enter the name for 'Upside': ",
    "Enter the name for 'Central': ",
    "Enter the name for 'Down 1': ",
    "Enter the name for 'Down 2': ",
    "Enter the name for 'Weighted': ",
    "Enter the name for '10% UP': ",
    "Enter the name for '10% DN': ",
    "Enter the name for '4% DN': "
]

# Get user inputs for the unique parts of the column names
user_inputs = []
for prompt in prompts:
    user_input = simpledialog.askstring("Input", prompt)
    if user_input is None:
        break
    user_inputs.append(user_input)

# Check if all inputs were provided
if len(user_inputs) != len(prompts):
    print("Incomplete inputs provided. Exiting...")
    root.destroy()
    exit()

def Create_data(user_inputs):
    # Define the column names
    column_1 = [
        (user_inputs[0], user_inputs[1], user_inputs[4]),
        (user_inputs[0], user_inputs[1], user_inputs[5]),
        (user_inputs[0], user_inputs[1], user_inputs[6]),
        (user_inputs[0], user_inputs[1], user_inputs[7]),
        (user_inputs[0], user_inputs[2], user_inputs[4]),
        (user_inputs[0], user_inputs[2], user_inputs[5]),
        (user_inputs[0], user_inputs[2], user_inputs[6]),
        (user_inputs[0], user_inputs[2], user_inputs[7]),
        (user_inputs[0], user_inputs[2], user_inputs[8]),
        (user_inputs[0], user_inputs[3], user_inputs[9]),
        (user_inputs[0], user_inputs[3], user_inputs[5]),
        (user_inputs[0], user_inputs[3], user_inputs[10]),
        (user_inputs[0], user_inputs[3], user_inputs[11])
    ]

    # Define the current year
    curr_year = datetime.now().year

    # Define the row indices
    rows = [
        'Q1', 'Q2', 'Q3', 'Q4',
        str(curr_year), 'Q1', 'Q2', 'Q3', 'Q4',
        str(curr_year + 1), str(curr_year + 2), str(curr_year + 3),
        '5yr Avg'
    ]

    # Create the DataFrame with the specified structure
    df_table = pd.DataFrame(columns=pd.MultiIndex.from_tuples(column_1), index=rows)

    # Display the DataFrame structure
    print(df_table)

# Call the Create_data function with the user inputs
Create_data(user_inputs)

# Close the Tkinter root window
root.destroy()



















from openpyxl import load_workbook
from openpyxl.styles import PatternFill

# Load the workbook and select the sheet
workbook = load_workbook('your_workbook.xlsx')
sheet = workbook['your_sheet_name']

# Define the color fill
sky_blue_fill = PatternFill(start_color="FF87CEFA", end_color="FF87CEFA", fill_type="solid")

# Iterate over the rows to find the cell with the desired value
for row in sheet.iter_rows(min_row=4, max_row=24, min_col=1, max_col=1):
    for cell in row:
        if cell.value == 'IFRS9 1024 Scenarios':
            cell_position = cell.coordinate
            row_idx = cell.row
            col_idx = cell.column

            # Fill the cells with the sky blue color
            for r in range(row_idx, row_idx + 3):
                for c in range(col_idx, col_idx + 4):
                    sheet.cell(row=r, column=c).fill = sky_blue_fill

# Save the workbook
workbook.save('your_workbook_colored.xlsx')

























import pandas as pd
from datetime import datetime
import tkinter as tk
from tkinter import simpledialog
from PIL import Image, ImageTk

# Initialize Tkinter
root = tk.Tk()
root.withdraw()  # Hide the root window

# Function to display the input dialog with logo and custom size
def show_dialog_with_logo(prompt):
    dialog = tk.Toplevel()
    dialog.geometry("500x300")  # Set the size of the dialog
    dialog.title(prompt)

    # Load the image
    img = Image.open("hsbc_1.png")
    img = img.resize((100, 100), Image.ANTIALIAS)  # Resize the image if needed
    logo = ImageTk.PhotoImage(img)

    # Create a label for the image
    img_label = tk.Label(dialog, image=logo)
    img_label.image = logo  # Keep a reference to avoid garbage collection
    img_label.pack(side="left", padx=10, pady=10)

    # Create an entry widget for user input
    entry = tk.Entry(dialog, width=40)
    entry.pack(side="right", padx=10, pady=10)

    # Function to close the dialog and return the entry value
    def on_ok():
        user_input = entry.get()
        dialog.destroy()
        return user_input

    # Create OK button
    ok_button = tk.Button(dialog, text="OK", command=on_ok)
    ok_button.pack(side="bottom", pady=10)

    # Center the dialog on the screen
    dialog.update_idletasks()
    width = dialog.winfo_width()
    height = dialog.winfo_height()
    x = (dialog.winfo_screenwidth() // 2) - (width // 2)
    y = (dialog.winfo_screenheight() // 2) - (height // 2)
    dialog.geometry('{}x{}+{}+{}'.format(width, height, x, y))

    root.wait_window(dialog)
    return entry.get()

# Global cache for user inputs
input_cache = {}

# Function to get user input for parts of the column names, using a cache to avoid duplicate prompts
def get_user_input(prompt):
    if prompt not in input_cache:
        input_cache[prompt] = show_dialog_with_logo(prompt)
    return input_cache[prompt]

# Function to create data
def create_data(tzero_date):
    # Get user inputs for the column names
    unemployment_rate = get_user_input("Enter the name for 'Unemployment Rate (%)': ")
    ifrs9_1024 = get_user_input("Enter the name for 'IFRS9 1024 Scenarios': ")
    ifrs9_4023 = get_user_input("Enter the name for 'IFRS9 4023 Scenarios': ")
    hoodys = get_user_input("Enter the name for 'Hoody's': ")
    upside = get_user_input("Enter the name for 'Upside': ")
    central = get_user_input("Enter the name for 'Central': ")
    down1 = get_user_input("Enter the name for 'Down 1': ")
    down2 = get_user_input("Enter the name for 'Down 2': ")
    weighted = get_user_input("Enter the name for 'Weighted': ")
    ten_percent_up = get_user_input("Enter the name for '10% UP': ")
    ten_percent_dn = get_user_input("Enter the name for '10% DN': ")
    four_percent_dn = get_user_input("Enter the name for '4% DN': ")

    # Define the columns using the collected inputs
    column_1 = [
        (unemployment_rate, ifrs9_1024, upside),
        (unemployment_rate, ifrs9_1024, central),
        (unemployment_rate, ifrs9_1024, down1),
        (unemployment_rate, ifrs9_1024, down2),
        (unemployment_rate, ifrs9_4023, upside),
        (unemployment_rate, ifrs9_4023, central),
        (unemployment_rate, ifrs9_4023, down1),
        (unemployment_rate, ifrs9_4023, down2),
        (unemployment_rate, ifrs9_4023, weighted),
        (unemployment_rate, hoodys, ten_percent_up),
        (unemployment_rate, hoodys, central),
        (unemployment_rate, hoodys, ten_percent_dn),
        (unemployment_rate, hoodys, four_percent_dn)
    ]

    # Define the current year
    curr_year = datetime.now().year

    # Define the row indices
    rows = [
        'Q1', 'Q2', 'Q3', 'Q4',
        str(curr_year), 'Q1', 'Q2', 'Q3', 'Q4',
        str(curr_year + 1), str(curr_year + 2), str(curr_year + 3),
        '5yr Avg'
    ]

    # Create the DataFrame with the specified structure
    df_table = pd.DataFrame(columns=pd.MultiIndex.from_tuples(column_1), index=rows)

    # Display the DataFrame structure
    print(f"tzero_date: {tzero_date}")
    print(df_table)

# Close the Tkinter root window when done
root.destroy()

# Set tzero_date as a fixed string value
tzero_date = "2024-03-31"

# Example loop calling the create_data function
for _ in range(2):  # Replace 2 with the desired number of iterations
    create_data(tzero_date)























import pandas as pd
from openpyxl import load_workbook
from openpyxl.styles import PatternFill
from openpyxl.formatting.rule import ColorScaleRule
import numpy as np

# Load the Excel file
file_path = 'path_to_your_excel_file.xlsx'  # Update with your file path
wb = load_workbook(filename=file_path)
sheet = wb['data edge']

# Load the sheet into a DataFrame
df = pd.read_excel(file_path, sheet_name='data edge')

# Check the condition
if 'Conditional_Formatting_Required' in df.columns and any(df['Conditional_Formatting_Required'] == 'Yes'):
    # Iterate through the sheet and apply formatting based on the specified conditions
    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == '5yr Avg':
                # Define the ranges for max, min, and avg values
                max_value_range = sheet.iter_rows(min_row=cell.row-18, max_row=cell.row-3, min_col=cell.column, max_col=cell.column+4)
                min_value_range = sheet.iter_rows(min_row=cell.row-18, max_row=cell.row-3, min_col=cell.column, max_col=cell.column+4)
                avg_value_range = sheet.iter_rows(min_row=cell.row-2, max_row=cell.row, min_col=cell.column+2, max_col=cell.column+2)

                # Extract values from the ranges
                max_values = [c.value for r in max_value_range for c in r if isinstance(c.value, (int, float))]
                min_values = [c.value for r in min_value_range for c in r if isinstance(c.value, (int, float))]
                avg_values = [c.value for r in avg_value_range for c in r if isinstance(c.value, (int, float))]

                # Calculate max, min, and avg values
                max_value = max(max_values) if max_values else None
                min_value = min(min_values) if min_values else None
                avg_value = np.mean(avg_values) if avg_values else None

                # Define the data range for conditional formatting
                data_range = f'{sheet.cell(row=cell.row-2, column=cell.column).coordinate}:{sheet.cell(row=cell.row-1, column=cell.column+4).coordinate}'

                # Define colors
                min_color = "FFCCCC"
                mid_color = "FFFFCC"
                max_color = "CCFFCC"

                # Create the color scale rule
                rule = ColorScaleRule(start_type='num', start_value=min_value, start_color=min_color,
                                      mid_type='num', mid_value=avg_value, mid_color=mid_color,
                                      end_type='num', end_value=max_value, end_color=max_color)

                # Apply the conditional formatting
                sheet.conditional_formatting.add(data_range, rule)

# Save the workbook
wb.save('path_to_your_output_file.xlsx')  # Update with your desired output file path




















import pandas as pd
import openpyxl
from openpyxl.formatting.rule import ColorScaleRule
import numpy as np

def formatting_1(sheet):
    # Read the morpho_1.xlsx file
    file_path = r'c:/pat/ram.xlsx'
    morpho_df = pd.read_excel(file_path, sheet_name='Data_Edge')

    # Iterate over the rows in the sheet
    for row in sheet.iter_rows():
        for cell in row:
            # Check if the cell value matches any value in the 'Checks' column
            checks_values = morpho_df.loc[morpho_df['ISOCODES'] == sheet.title, 'Checks'].tolist()
            if cell.value in checks_values:
                # Get the corresponding 'Conditional_Formatting_Required' value
                conditional_formatting_required = morpho_df.loc[(morpho_df['ISOCODES'] == sheet.title) & (morpho_df['Checks'] == cell.value), 'Conditional_Formatting_Required'].values[0]

                # Check if 'Conditional_Formatting_Required' is 'Yes'
                if conditional_formatting_required == 'Yes':
                    if cell.value == '5yr Avg':
                        max_value_range = sheet.iter_rows(min_row=cell.row - 18, max_row=cell.row - 3, min_col=cell.column + 1, max_col=cell.column + 4)
                        min_value_range = sheet.iter_rows(min_row=cell.row - 18, max_row=cell.row - 3, min_col=cell.column + 1, max_col=cell.column + 4)
                        avg_value_range = sheet.iter_rows(min_row=cell.row - 2, max_row=cell.row, min_col=cell.column + 2, max_col=cell.column + 2)

                        max_values = [c.value for r in max_value_range for c in r if isinstance(c.value, (int, float))]
                        min_values = [c.value for r in min_value_range for c in r if isinstance(c.value, (int, float))]
                        avg_values = [c.value for r in avg_value_range for c in r if isinstance(c.value, (int, float))]

                        max_value = max(max_values) if max_values else None
                        min_value = min(min_values) if min_values else None
                        avg_value = np.mean(avg_values) if avg_values else None

                        data_range = f'{sheet.cell(row=cell.row - 2, column=cell.column + 1).coordinate}:{sheet.cell(row=cell.row - 1, column=cell.column + 4).coordinate}'
                        min_color = "FFCCCC"
                        mid_color = "FFFFFF"
                        max_color = 'CCFFCC'

                        rule = ColorScaleRule(start_type='num', start_value=max_value, start_color=min_color, mid_type='num', mid_value=avg_value, mid_color=mid_color, end_type='num', end_value=min_value, end_color=max_color)
                        sheet.conditional_formatting.add(data_range, rule)

# Usage example
file_path = r'c:/pat/ram.xlsx'
workbook = openpyxl.load_workbook(file_path)

# Iterate over each sheet in the workbook
for sheet_name in workbook.sheetnames:
    sheet = workbook[sheet_name]
    formatting_1(sheet)

# Save the updated workbook
workbook.save(file_path)
















import pandas as pd
import openpyxl
from openpyxl.formatting.rule import ColorScaleRule
import numpy as np

def apply_conditional_formatting(sheet, checks_value):
    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == checks_value:
                # Look for '5yr Avg' in the previous column of the same row
                if cell.col_idx > 1:  # Ensure we don't go out of bounds
                    target_cell = sheet.cell(row=cell.row, column=cell.col_idx - 1)
                    if target_cell.value == '5yr Avg':
                        max_value_range = sheet.iter_rows(min_row=cell.row - 18, max_row=cell.row - 3, min_col=cell.col_idx + 1, max_col=cell.col_idx + 4)
                        min_value_range = sheet.iter_rows(min_row=cell.row - 18, max_row=cell.row - 3, min_col=cell.col_idx + 1, max_col=cell.col_idx + 4)
                        avg_value_range = sheet.iter_rows(min_row=cell.row - 2, max_row=cell.row, min_col=cell.col_idx + 2, max_col=cell.col_idx + 2)

                        max_values = [c.value for r in max_value_range for c in r if isinstance(c.value, (int, float))]
                        min_values = [c.value for r in min_value_range for c in r if isinstance(c.value, (int, float))]
                        avg_values = [c.value for r in avg_value_range for c in r if isinstance(c.value, (int, float))]

                        max_value = max(max_values) if max_values else None
                        min_value = min(min_values) if min_values else None
                        avg_value = np.mean(avg_values) if avg_values else None

                        data_range = f'{sheet.cell(row=cell.row - 2, column=cell.col_idx + 1).coordinate}:{sheet.cell(row=cell.row - 1, column=cell.col_idx + 4).coordinate}'
                        min_color = "FFCCCC"
                        mid_color = "FFFFFF"
                        max_color = 'CCFFCC'

                        rule = ColorScaleRule(start_type='num', start_value=max_value, start_color=min_color, mid_type='num', mid_value=avg_value, mid_color=mid_color, end_type='num', end_value=min_value, end_color=max_color)
                        sheet.conditional_formatting.add(data_range, rule)

def formatting_1(sheet, morpho_df):
    # Get the current sheet name (ISOCODES)
    isocode = sheet.title

    # Filter DataFrame for the current ISOCODES
    filtered_df = morpho_df[morpho_df['ISOCODES'] == isocode]

    # Iterate over the filtered rows
    for _, row in filtered_df.iterrows():
        checks_value = row['Checks']
        conditional_formatting_required = row['Conditional_Formatting_Required']

        # Check if conditional formatting is required
        if conditional_formatting_required == 'Yes':
            apply_conditional_formatting(sheet, checks_value)

def main():
    # Paths to the files
    file_path = r'c:/pat/ram.xlsx'
    morpho_path = r'c:/pat/morpho_1.xlsx'

    # Load the main Excel file
    workbook = openpyxl.load_workbook(file_path)

    # Read the morpho_1.xlsx file
    morpho_df = pd.read_excel(morpho_path, sheet_name='Data_Edge')

    # Iterate over each sheet in the workbook
    for sheet_name in workbook.sheetnames:
        sheet = workbook[sheet_name]
        formatting_1(sheet, morpho_df)

    # Save the updated workbook
    workbook.save(file_path)

# Execute the main function
if __name__ == "__main__":
    main()










data_range = f'(sheet.cell(row=target_cell.row 7, column=target_cell.column + 1).coordinate): (sheet.cell(row=target_cell.row - 4, column=target_cell.column + 4).coordinate)'













import pandas as pd
import openpyxl
import numpy as np

def conditional_formatting_IFRS10_1(sheet):
    # Define the path to the workbook
    workbook_path = r"C:\Users\45363901\PycharmProjects\pythonProject\pythonProject2 GBIC Workings Data\Input\Mapping File Copy.xlsx"

    # Read the Excel file and load the specified sheet into a DataFrame
    df = pd.read_excel(workbook_path, sheet_name="Data_Edge")

    # Iterate over the rows in the sheet
    for row in sheet.iter_rows():
        for cell in row:
            # Get the check values that contain 'QoQ' and have conditional formatting required as 'Yes'
            checks_value = df.loc[
                (df['ISOCODES'] == sheet.title) &
                (df['Checks'].str.contains('QoQ')) &
                (df['Conditional_Formatting_Required'] == 'Yes'),
                'Checks'
            ].tolist()

            # Check if the cell value matches any of the check values
            for value in checks_value:
                if cell.value == value:
                    if cell.col_idx > 1:
                        target_cell = sheet.cell(row=cell.row, column=cell.col_idx - 1)
                        if target_cell.value == '5yr Avg':
                            # Define the data range based on the target cell
                            data_range = f'{sheet.cell(row=target_cell.row + 7, column=target_cell.column + 1).coordinate}:{sheet.cell(row=target_cell.row - 4, column=target_cell.column + 4).coordinate}'
                            # Clear the numbers in the specified range
                            for cell_range in sheet[data_range]:
                                for target in cell_range:
                                    if isinstance(target.value, (int, float)):
                                        target.value = None

# Example usage
file_path = r"C:\Users\45363901\PycharmProjects\pythonProject\pythonProject2 GBIC Workings Data\Input\Mapping File Copy.xlsx"
workbook = openpyxl.load_workbook(file_path)

# Iterate over each sheet in the workbook
for sheet_name in workbook.sheetnames:
    sheet = workbook[sheet_name]
    conditional_formatting_IFRS10_1(sheet)

# Save the updated workbook
workbook.save(file_path)







import openpyxl

def insert_empty_column_after_weighted(sheet):
    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == "Weighted":
                # Insert a new column after the column containing "Weighted"
                col_idx = cell.column
                sheet.insert_cols(col_idx + 1)

                # Set the width of the new column to 0.32
                new_col_letter = openpyxl.utils.get_column_letter(col_idx + 1)
                sheet.column_dimensions[new_col_letter].width = 0.32

                # Break to avoid processing the same row multiple times
                break

# Example usage
file_path = r"C:\Users\45363901\PycharmProjects\pythonProject\pythonProject2 GBIC Workings Data\Input\Mapping File Copy.xlsx"
workbook = openpyxl.load_workbook(file_path)

# Iterate over each sheet in the workbook
for sheet_name in workbook.sheetnames:
    sheet = workbook[sheet_name]
    insert_empty_column_after_weighted(sheet)

# Save the updated workbook
workbook.save(file_path)
