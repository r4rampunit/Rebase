from openpyxl.formatting.rule import ColorScaleRule
import numpy as np
from openpyxl import load_workbook

def conditional_formatting_IFRS1Q(sheet):
    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == '5yr Avg':
                # Define ranges for max, min, and average values
                max_value_range = sheet.iter_rows(min_row=cell.row + 18, max_row=cell.row + 21, min_col=cell.column + 1, max_col=cell.column + 4)
                min_value_range = sheet.iter_rows(min_row=cell.row + 18, max_row=cell.row + 21, min_col=cell.column + 1, max_col=cell.column + 4)
                avg_value_range = sheet.iter_rows(min_row=cell.row + 2, max_row=cell.row + 5, min_col=cell.column + 2, max_col=cell.column + 2)

                # Extract values from the ranges
                max_values = [c.value for r in max_value_range for c in r if isinstance(c.value, (int, float))]
                min_values = [c.value for r in min_value_range for c in r if isinstance(c.value, (int, float))]
                avg_values = [c.value for r in avg_value_range for c in r if isinstance(c.value, (int, float))]

                # Compute max, min, and average values
                max_value = max(max_values) if max_values else None
                min_value = min(min_values) if min_values else None
                avg_value = np.mean(avg_values) if avg_values else None

                # Skip if any value is not found
                if max_value is None or min_value is None or avg_value is None:
                    continue

                # Define the data range for conditional formatting
                data_range = f'{sheet.cell(row=cell.row + 12, column=cell.column + 1).coordinate}:{sheet.cell(row=cell.row + 11, column=cell.column + 4).coordinate}'

                # Define color scale rule
                min_color = 'FFCCCC'
                mid_color = 'FFFFFF'
                max_color = 'CCFFCC'

                rule = ColorScaleRule(start_type='min', start_value=min_value, start_color=min_color,
                                      mid_type='num', mid_value=avg_value, mid_color=mid_color,
                                      end_type='max', end_value=max_value, end_color=max_color)

                # Apply conditional formatting rule
                sheet.conditional_formatting.add(data_range, rule)

# Example usage
wb = load_workbook('your_workbook.xlsx')
sheet = wb['Sheet1']
conditional_formatting_IFRS1Q(sheet)
wb.save('your_workbook_with_formatting.xlsx')
















from openpyxl import load_workbook
from openpyxl.formatting.rule import ColorScaleRule
import numpy as np

def conditional_formatting_IFRS1Q(sheet):
    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == '5yr Avg':
                max_value_range = sheet.iter_rows(min_row=cell.row + 18, max_row=cell.row + 21, min_col=cell.column + 1, max_col=cell.column + 4)
                min_value_range = sheet.iter_rows(min_row=cell.row + 18, max_row=cell.row + 21, min_col=cell.column + 1, max_col=cell.column + 4)
                avg_value_range = sheet.iter_rows(min_row=cell.row + 2, max_row=cell.row + 5, min_col=cell.column + 2, max_col=cell.column + 2)

                max_values = [c.value for r in max_value_range for c in r if isinstance(c.value, (int, float))]
                min_values = [c.value for r in min_value_range for c in r if isinstance(c.value, (int, float))]
                avg_values = [c.value for r in avg_value_range for c in r if isinstance(c.value, (int, float))]

                max_value = max(max_values) if max_values else None
                min_value = min(min_values) if min_values else None
                avg_value = np.mean(avg_values) if avg_values else None

                if max_value is None or min_value is None or avg_value is None:
                    print(f"Skipping cell at {cell.coordinate} due to missing value.")
                    continue

                data_range = f'{sheet.cell(row=cell.row + 12, column=cell.column + 1).coordinate}:{sheet.cell(row=cell.row + 15, column=cell.column + 4).coordinate}'

                min_color = 'FFCCCC'
                mid_color = 'FFFFFF'
                max_color = 'CCFFCC'

                rule = ColorScaleRule(start_type='num', start_value=min_value, start_color=min_color,
                                      mid_type='num', mid_value=avg_value, mid_color=mid_color,
                                      end_type='num', end_value=max_value, end_color=max_color)

                sheet.conditional_formatting.add(data_range, rule)
                print(f"Applied conditional formatting to range: {data_range}")

# Use context manager to ensure the file is properly closed after processing
file_path = 'your_workbook.xlsx'
output_file_path = 'your_workbook_with_formatting.xlsx'

with load_workbook(file_path) as wb:
    sheet = wb['Sheet1']
    conditional_formatting_IFRS1Q(sheet)
    wb.save(output_file_path)

print(f"Workbook saved successfully to {output_file_path}")










df = pd.DataFrame(data)
iso_dict = {}
for index, row in df.iterrows():
    iso_code = row['ISOCODES']
    check = row['Checks']

    if iso_code not in iso_dict:
        iso_dict[iso_code] = []

    iso_dict[iso_code].append(check)

for iso_code in iso_dict:
    iso_dict[iso_code] = tuple(iso_dict[iso_code])

















change_name(sheet):

This function is responsible for renaming the column headers in the given sheet based on the country code.
It uses a dictionary A that maps country codes to lists of column names.
It iterates over each row and cell in the sheet and checks if the cell value matches the country code.
If a match is found, it replaces the cell value with the corresponding column name from the list associated with that country code.


add_output_columns(sheet):

This function calculates additional columns based on the existing columns in the given sheet.
It reads the data from the sheet into a Pandas DataFrame df.
It calculates year-over-year (YoY) and quarter-over-quarter (QoQ) percentage changes for various columns (e.g., GDP, CPI, PH, PH_DUBAI, PCOM).
It rounds the calculated values to one decimal place and returns the updated DataFrame.


calculate_5year_avg(frame, Isocode, tzero_date, col):

This function calculates the 5-year average for a given column col and country code Isocode.
It finds the row in the DataFrame frame that matches the Isocode and tzero_date.
It then calculates the mean of the next 20 values (representing the 5-year period) for the specified column.
It returns the calculated 5-year average.


calculate_weights(df_table, Isocode):

This function calculates and assigns weights to the rows of the DataFrame df_table based on the country code Isocode.
It reads scenario weights from a mapping file and merges them with the DataFrame based on the country code.
It calculates the weighted sum of the values in specific columns using the scenario weights.
It updates the DataFrame df_table with the calculated weighted values.


construct_and_populate_tables(Isocode, tzero_date, col):

This function constructs and populates a table (DataFrame) with data for a given country code Isocode, time zero date tzero_date, and column col.
It initializes a DataFrame df_table with a predefined column structure.
It iterates over the data frames in the All list and populates the df_table with the corresponding values based on the country code and dates.
It calculates additional columns like the 5-year average and weighted values using helper functions.
It rounds the values in the DataFrame and returns the populated df_table.


format_sheet(sheet):

This function formats the given sheet by applying various formatting rules.
It rounds the numeric values to one decimal place.
It applies a specific font to all cells.
It applies white font color to certain named ranges.
It applies a light gray fill color to certain rows and columns.
It applies bold formatting to specific rows and columns.
It applies conditional formatting based on decimal patterns and fills cells with a light gray color accordingly.
It applies thin borders to all cells.
It applies red and blue fill colors to specific named ranges.



The remaining functions perform tasks like conditional formatting, date writing, handling formatting for specific scenarios (e.g., IFRS1Q_1, IFRS1Q_2, IFRS1Q_3, IFRS_FIRST_Q, IFRS4Q), and more.
The overall logic seems to involve reading data from various sources, performing calculations and transformations, constructing tables (DataFrames) with the processed data, and formatting the tables according to specific rules and requirements. The code appears to be tailored for a specific data processing and reporting workflow.

























from datetime import datetime
from dateutil import relativedelta

zero_date = "2024-03-31"
zero_date = datetime.strptime(zero_date, "%Y-%m-%d")

zero_date_1 = zero_date.replace(year=zero_date.year - 1)
start_date = datetime.strptime(str(zero_date_1), "%Y-%m-%d")

date1 = start_date

date2 = (date1 + relativedelta(months=3)).replace(day=1) - relativedelta(months=1, days=-1)
date3 = (date2 + relativedelta(months=3)).replace(day=1) - relativedelta(months=1, days=-1)
date4 = (date3 + relativedelta(months=3)).replace(day=1) - relativedelta(months=1, days=-1)
date5 = (date4 + relativedelta(months=3)).replace(day=1) - relativedelta(months=1, days=-1)

date6 = (date5 + relativedelta(months=3)).replace(day=1) - relativedelta(months=1, days=-1)
date7 = (date6 + relativedelta(months=3)).replace(day=1) - relativedelta(months=1, days=-1)
date8 = (date7 + relativedelta(months=3)).replace(day=1) - relativedelta(months=1, days=-1)
date9 = (date8 + relativedelta(months=3)).replace(day=1) - relativedelta(months=1, days=-1)
date10 = (date9 + relativedelta(months=3)).replace(day=1) - relativedelta(months=1, days=-1)
date11 = (date10 + relativedelta(months=3)).replace(day=1) - relativedelta(months=1, days=-1)

dates = [
    date1.strftime("%d-%b-%y"), date2.strftime("%d-%b-%y"), date3.strftime("%d-%b-%y"), date4.strftime("%d-%b-%y"),
    date5.strftime("%d-%b-%y"), date6.strftime("%d-%b-%y"), date7.strftime("%d-%b-%y"), date8.strftime("%d-%b-%y"),
    date9.strftime("%d-%b-%y"), date10.strftime("%d-%b-%y"), date11.strftime("%d-%b-%y")
]
































import pandas as pd
from datetime import datetime, timedelta

# Read the data from the Excel file
data = pd.read_excel('mev-nz.xlsx')

# Create a list of unique country ISO codes
countries = data['ISOCODES'].unique().tolist()

# Create a list of column names for the dates
date_cols = [f"{d.strftime('%m/%d/%Y')}" for d in pd.date_range(start='12/31/2022', end='12/31/2052', freq='Q')]

# Create an empty DataFrame with the desired structure
mev_data = pd.DataFrame(index=data['GDP'].unique(), columns=['MEV Key', 'MEV Variable', 'Country ISO Code'] + date_cols + ['Region Mapped'])

# Iterate over each row in the original data
for row in data.itertuples(index=False):
    country = row.ISOCODES
    mev_key = row.GDP
    mev_var = row._fields[3]  # Assuming the variable name is in the 4th column

    # Create a new row in the mev_data DataFrame
    mev_data.loc[mev_key, 'MEV Key'] = mev_key
    mev_data.loc[mev_key, 'MEV Variable'] = mev_var
    mev_data.loc[mev_key, 'Country ISO Code'] = country

    # Get the start date and end date for the variable
    start_date = datetime(year=row.GDP_YR, month=1, day=1)
    end_date = start_date + timedelta(days=365)

    # Populate the values in the date columns
    for date_col in date_cols:
        date = datetime.strptime(date_col, '%m/%d/%Y')
        if start_date <= date < end_date:
            mev_data.loc[mev_key, date_col] = row._fields.index(mev_var)

# Write the data to a new Excel file
mev_data.to_excel('mev_data.xlsx', index=False)




















import pandas as pd
from datetime import datetime, timedelta

# Read the data from the Excel file
data = pd.read_excel('mev-nz.xlsx')

# Create a list of unique country ISO codes
countries = data['ISOCODES'].unique().tolist()

# Create a list of column names for the dates
date_cols = ['12/31/2022', '3/31/2023'] + [f"{d.strftime('%m/%d/%Y')}" for d in pd.date_range(start='6/30/2023', end='12/31/2052', freq='Q')]

# Create an empty DataFrame with the desired structure
mev_data = pd.DataFrame(columns=['MEV Key', 'MEV Variable', 'Country ISO Code'] + date_cols + ['Region Mapped'])

# Iterate over each row in the original data
for row in data.itertuples(index=False):
    country = row.ISOCODES
    mev_key = row.GDP
    mev_var = row._fields[3]  # Assuming the variable name is in the 4th column

    # Ensure GDP_YR can be converted to an integer, if not, skip this row
    try:
        gdp_year = int(row.GDP_YR)
        if gdp_year < 1:
            continue
    except (ValueError, TypeError):
        continue

    # Get the start date and end date for the variable
    start_date = datetime(year=gdp_year, month=1, day=1)
    end_date = start_date + timedelta(days=365)

    # Check if the key exists in mev_data, if not, add it
    if mev_key not in mev_data.index:
        mev_data.loc[mev_key] = [mev_key, mev_var, country] + [None] * (len(date_cols) + 1)

    # Populate the values in the date columns
    for date_col in date_cols:
        date = datetime.strptime(date_col, '%m/%d/%Y')
        if start_date <= date < end_date:
            if pd.isna(mev_data.loc[mev_key, date_col]):
                mev_data.loc[mev_key, date_col] = mev_var
            else:
                mev_data.loc[mev_key, date_col] = f"{mev_data.loc[mev_key, date_col]}, {mev_var}"

# Write the data to a new Excel file
mev_data.to_excel('mev_data.xlsx', index=False)

























import pandas as pd
from datetime import datetime, timedelta

# Read the data from the Excel file
data = pd.read_excel('mev-nz.xlsx')

# Create a list of unique country ISO codes
countries = data['ISOCODES'].unique().tolist()

# Create a list of column names for the dates
date_cols = ['3/31/2021', '6/30/2021', '9/30/2021', '12/31/2021', '3/31/2022', '6/30/2022', '9/30/2022', '12/31/2022', '3/31/2023'] + \
    [f"{d.strftime('%m/%d/%Y')}" for d in pd.date_range(start='6/30/2023', end='12/31/2052', freq='Q')]

# Create an empty DataFrame with the desired structure
mev_data = pd.DataFrame(columns=['MEV Key', 'MEV Variable', 'Country ISO Code', 'Region Mapped'] + date_cols)

# Iterate over each row in the original data
for row in data.itertuples(index=False):
    country = row.ISOCODES
    mev_key = row.GDP
    mev_var = row._fields[3]  # Assuming the variable name is in the 4th column

    # Ensure GDP_YR can be converted to an integer, if not, skip this row
    try:
        gdp_year = int(row.GDP_YR)
        if gdp_year < 1:
            continue
    except (ValueError, TypeError):
        continue

    # Get the start date and end date for the variable
    start_date = datetime(year=gdp_year, month=1, day=1)
    end_date = start_date + timedelta(days=365)

    # Check if the key exists in mev_data, if not, add it
    if mev_key not in mev_data.index:
        mev_data.loc[mev_key] = [mev_key, mev_var, country, None] + [None] * len(date_cols)

    # Populate the values in the date columns
    for date_col in date_cols:
        date = datetime.strptime(date_col, '%m/%d/%Y')
        if start_date <= date < end_date:
            if pd.isna(mev_data.loc[mev_key, date_col]):
                mev_data.loc[mev_key, date_col] = mev_var
            else:
                mev_data.loc[mev_key, date_col] = f"{mev_data.loc[mev_key, date_col]}, {mev_var}"

# Write the data to a new Excel file
mev_data.to_excel('mev_data.xlsx', index=False)















import pandas as pd
from datetime import datetime, timedelta

# Read the data from the Excel file
data = pd.read_excel('mev-nz.xlsx')

# Create a list of unique country ISO codes
countries = data['ISOCODES'].unique().tolist()

# Create a list of column names for the dates
date_cols = ['3/31/2021', '6/30/2021', '9/30/2021', '12/31/2021', '3/31/2022', '6/30/2022', '9/30/2022', '12/31/2022', '3/31/2023'] + [f"{d.strftime('%m/%d/%Y')}" for d in pd.date_range(start='6/30/2023', end='12/31/2052', freq='Q')]

# Create an empty DataFrame with the desired structure
mev_data = pd.DataFrame(columns=['MEV Key', 'MEV Variable', 'Country ISO Code', 'Region Mapped'] + date_cols)

# Iterate over each row in the original data
for _, row in data.iterrows():
    country = row['ISOCODES']
    mev_key = row['GDP']
    mev_var = row.iloc[3]  # Assuming the variable name is in the 4th column

    # Ensure GDP_YR can be converted to an integer, if not, skip this row
    try:
        gdp_year = int(row['GDP_YR'])
        if gdp_year < 1:
            continue
    except (ValueError, TypeError):
        continue

    # Get the start date and end date for the variable
    start_date = datetime(year=gdp_year, month=1, day=1)
    end_date = start_date + timedelta(days=365)

    # Check if the key exists in mev_data, if not, add it
    if mev_key not in mev_data.index:
        mev_data.loc[mev_key] = [mev_key, mev_var, country, None] + [None] * len(date_cols)

    # Populate the values in the date columns
    for date_col in date_cols:
        date = datetime.strptime(date_col, '%m/%d/%Y')
        if start_date <= date < end_date:
            if pd.isna(mev_data.loc[mev_key, date_col]):
                mev_data.loc[mev_key, date_col] = mev_var
            else:
                mev_data.loc[mev_key, date_col] = f"{mev_data.loc[mev_key, date_col]}, {mev_var}"

# Write the data to a new Excel file
mev_data.to_excel('mev_data.xlsx', index=False)

print(dates)



















import pandas as pd
from datetime import datetime, timedelta

# Read the data from the Excel file
data = pd.read_excel('mev-nz.xlsx')

# Create a list of unique country ISO codes
countries = data['ISOCODES'].unique().tolist()

# Create a list of column names for the dates
date_cols = ['3/31/2021', '6/30/2021', '9/30/2021', '12/31/2021', '3/31/2022', '6/30/2022', '9/30/2022', '12/31/2022', '3/31/2023'] + [f"{d.strftime('%m/%d/%Y')}" for d in pd.date_range(start='6/30/2023', end='12/31/2052', freq='Q')]

# Create an empty DataFrame with the desired structure
mev_data = pd.DataFrame(columns=['MEV Key', 'MEV Variable', 'Country ISO Code', 'Region Mapped'] + date_cols)

# Iterate over each row in the original data
for _, row in data.iterrows():
    country = row['ISOCODES']
    mev_var = row.iloc[3]  # Assuming the variable name is in the 4th column
    region_mapped = row['GDP']

    # Ensure GDP_YR can be converted to an integer, if not, skip this row
    try:
        gdp_year = int(row['GDP_YR'])
        if gdp_year < 1:
            continue
    except (ValueError, TypeError):
        continue

    # Create the MEV Key based on the Region Mapped and MEV Variable
    mev_key = f"{region_mapped}_{mev_var}"

    # Get the start date and end date for the variable
    start_date = datetime(year=gdp_year, month=1, day=1)
    end_date = start_date + timedelta(days=365)

    # Check if the key exists in mev_data, if not, add it
    if mev_key not in mev_data.index:
        mev_data.loc[mev_key] = [mev_key, mev_var, country, region_mapped] + [None] * len(date_cols)

    # Populate the values in the date columns
    for date_col in date_cols:
        date = datetime.strptime(date_col, '%m/%d/%Y')
        if start_date <= date < end_date:
            if pd.isna(mev_data.loc[mev_key, date_col]):
                mev_data.loc[mev_key, date_col] = mev_var
            else:
                mev_data.loc[mev_key, date_col] = f"{mev_data.loc[mev_key, date_col]}, {mev_var}"

# Write the data to a new Excel file
mev_data.to_excel('mev_data.xlsx', index=False)























import pandas as pd
from datetime import datetime, timedelta

# Read the data from the Excel file
data = pd.read_excel('mev-nz.xlsx')

# Create a list of unique country ISO codes
countries = data['ISOCODES'].unique().tolist()

# Create a list of column names for the dates
date_cols = ['3/31/2021', '6/30/2021', '9/30/2021', '12/31/2021', '3/31/2022', '6/30/2022', '9/30/2022', '12/31/2022', '3/31/2023'] + [f"{d.strftime('%m/%d/%Y')}" for d in pd.date_range(start='6/30/2023', end='12/31/2052', freq='Q')]

# Create an empty DataFrame with the desired structure
mev_data = pd.DataFrame(columns=['MEV Key', 'MEV Variable', 'Country ISO Code', 'Region Mapped'] + date_cols)

# Iterate over each row in the original data
for row in data.itertuples(index=False):
    country = row.ISOCODES
    mev_var = row._fields[3]  # Assuming the variable name is in the 4th column
    region_mapped = row._fields[4]  # Assuming the region mapped is in the 5th column
    mev_key = f"{region_mapped}_{mev_var}"

    # Ensure GDP_YR can be converted to an integer, if not, skip this row
    try:
        gdp_year = int(row.GDP_YR)
        if gdp_year < 1:
            continue
    except (ValueError, TypeError):
        continue

    # Get the start date and end date for the variable
    start_date = datetime(year=gdp_year, month=1, day=1)
    end_date = start_date + timedelta(days=365)

    # Check if the key exists in mev_data, if not, add it
    if mev_key not in mev_data.index:
        mev_data.loc[mev_key] = [mev_key, mev_var, country, region_mapped] + [None] * len(date_cols)

    # Populate the values in the date columns
    for date_col in date_cols:
        date = datetime.strptime(date_col, '%m/%d/%Y')
        if start_date <= date < end_date:
            if pd.isna(mev_data.loc[mev_key, date_col]):
                mev_data.loc[mev_key, date_col] = mev_var
            else:
                mev_data.loc[mev_key, date_col] = f"{mev_data.loc[mev_key, date_col]}, {mev_var}"

# Write the data to a new Excel file
mev_data.to_excel('mev_data.xlsx', index=False)











import pandas as pd
from datetime import datetime, timedelta

# Read the data from the Excel file
data = pd.read_excel('mev-nz.xlsx')

# Create a list of unique country ISO codes
countries = data['ISOCODES'].unique().tolist()

# Create a list of column names for the dates
date_cols = ['3/31/2021', '6/30/2021', '9/30/2021', '12/31/2021', '3/31/2022', '6/30/2022', '9/30/2022', '12/31/2022', '3/31/2023'] + [f"{d.strftime('%m/%d/%Y')}" for d in pd.date_range(start='6/30/2023', end='12/31/2052', freq='Q')]

# Create an empty DataFrame with the desired structure
mev_data = pd.DataFrame(columns=['MEV Key', 'MEV Variable', 'Country ISO Code', 'Region Mapped'] + date_cols)

# Iterate over each row in the original data
for row in data.itertuples(index=False):
    country = row.ISOCODES
    mev_var = row.MEV_Variable
    region_mapped = row.Region_Mapped
    mev_key = f"{row.Region_Mapped}_{row.MEV_Variable}"

    # Ensure GDP_YR can be converted to an integer, if not, skip this row
    try:
        gdp_year = int(row.GDP_YR)
        if gdp_year < 1:
            continue
    except (ValueError, TypeError):
        continue

    # Get the start date and end date for the variable
    start_date = datetime(year=gdp_year, month=1, day=1)
    end_date = start_date + timedelta(days=365)

    # Check if the key exists in mev_data, if not, add it
    if mev_key not in mev_data.index:
        mev_data.loc[mev_key] = [mev_key, mev_var, country, region_mapped] + [None] * len(date_cols)

    # Populate the values in the date columns
    for date_col in date_cols:
        date = datetime.strptime(date_col, '%m/%d/%Y')
        if start_date <= date <= end_date:
            values = mev_data.loc[mev_key, date_col]
            if pd.isna(values):
                values = [mev_var]
            elif mev_var not in values:
                values.append(mev_var)
            mev_data.loc[mev_key, date_col] = values

# Convert list values in date columns to comma-separated strings
mev_data[date_cols] = mev_data[date_cols].apply(lambda x: x.apply(lambda y: ', '.join(map(str, y)) if isinstance(y, list) else y))

# Write the data to a new Excel file
mev_data.to_excel('mev_data.xlsx', index=False)
















import pandas as pd
from datetime import datetime

# Function to get user input for column names
def get_column_names():
    columns = []
    num_columns = int(input("Enter the number of columns: "))
    for i in range(num_columns):
        mev_variable = input(f"Enter the MEV Variable for column {i+1}: ")
        scenario_type = input(f"Enter the Scenario Type for column {i+1}: ")
        scenario_detail = input(f"Enter the Scenario Detail for column {i+1}: ")
        columns.append(('Unemployment Rate (%)', scenario_type, scenario_detail))
    return columns

# Define the current year
curr_year = datetime.now().year

# Get user input for the multi-level column names
column_1 = get_column_names()

# Define the row indices
rows = [
    'Q1', 'Q2', 'Q3', 'Q4',
    str(curr_year), 'Q1', 'Q2', 'Q3', 'Q4',
    str(curr_year + 1), str(curr_year + 2), str(curr_year + 3),
    '5yr Avg'
]

# Create the DataFrame with the specified structure
df_table = pd.DataFrame(columns=pd.MultiIndex.from_tuples(column_1), index=rows)

# Display the DataFrame structure
print(df_table)






















import pandas as pd
from datetime import datetime
import tkinter as tk
from tkinter import simpledialog

# Initialize Tkinter
root = tk.Tk()
root.withdraw()  # Hide the root window

# Function to get user input for parts of the column names
def get_user_input(prompt, cache={}):
    if prompt not in cache:
        cache[prompt] = simpledialog.askstring("Input", prompt)
    return cache[prompt]

# Define the prompts for unique parts of the column names
prompts = {
    "Unemployment Rate (%)": "Enter the name for 'Unemployment Rate (%)': ",
    "IFRS9 1024 Scenarios": "Enter the name for 'IFRS9 1024 Scenarios': ",
    "IFRS9 4023 Scenarios": "Enter the name for 'IFRS9 4023 Scenarios': ",
    "Hoody's": "Enter the name for 'Hoody's': ",
    "Upside": "Enter the name for 'Upside': ",
    "Central": "Enter the name for 'Central': ",
    "Down 1": "Enter the name for 'Down 1': ",
    "Down 2": "Enter the name for 'Down 2': ",
    "Weighted": "Enter the name for 'Weighted': ",
    "10% UP": "Enter the name for '10% UP': ",
    "10% DN": "Enter the name for '10% DN': ",
    "4% DN": "Enter the name for '4% DN': "
}

# Get user inputs for the column names
column_1 = [
    (get_user_input(prompts["Unemployment Rate (%)"]), get_user_input(prompts["IFRS9 1024 Scenarios"]), get_user_input(prompts["Upside"])),
    (get_user_input(prompts["Unemployment Rate (%)"]), get_user_input(prompts["IFRS9 1024 Scenarios"]), get_user_input(prompts["Central"])),
    (get_user_input(prompts["Unemployment Rate (%)"]), get_user_input(prompts["IFRS9 1024 Scenarios"]), get_user_input(prompts["Down 1"])),
    (get_user_input(prompts["Unemployment Rate (%)"]), get_user_input(prompts["IFRS9 1024 Scenarios"]), get_user_input(prompts["Down 2"])),
    (get_user_input(prompts["Unemployment Rate (%)"]), get_user_input(prompts["IFRS9 4023 Scenarios"]), get_user_input(prompts["Upside"])),
    (get_user_input(prompts["Unemployment Rate (%)"]), get_user_input(prompts["IFRS9 4023 Scenarios"]), get_user_input(prompts["Central"])),
    (get_user_input(prompts["Unemployment Rate (%)"]), get_user_input(prompts["IFRS9 4023 Scenarios"]), get_user_input(prompts["Down 1"])),
    (get_user_input(prompts["Unemployment Rate (%)"]), get_user_input(prompts["IFRS9 4023 Scenarios"]), get_user_input(prompts["Down 2"])),
    (get_user_input(prompts["Unemployment Rate (%)"]), get_user_input(prompts["IFRS9 4023 Scenarios"]), get_user_input(prompts["Weighted"])),
    (get_user_input(prompts["Unemployment Rate (%)"]), get_user_input(prompts["Hoody's"]), get_user_input(prompts["10% UP"])),
    (get_user_input(prompts["Unemployment Rate (%)"]), get_user_input(prompts["Hoody's"]), get_user_input(prompts["Central"])),
    (get_user_input(prompts["Unemployment Rate (%)"]), get_user_input(prompts["Hoody's"]), get_user_input(prompts["10% DN"])),
    (get_user_input(prompts["Unemployment Rate (%)"]), get_user_input(prompts["Hoody's"]), get_user_input(prompts["4% DN"]))
]

# Define the current year
curr_year = datetime.now().year

# Define the row indices
rows = [
    'Q1', 'Q2', 'Q3', 'Q4',
    str(curr_year), 'Q1', 'Q2', 'Q3', 'Q4',
    str(curr_year + 1), str(curr_year + 2), str(curr_year + 3),
    '5yr Avg'
]

# Create the DataFrame with the specified structure
df_table = pd.DataFrame(columns=pd.MultiIndex.from_tuples(column_1), index=rows)

# Display the DataFrame structure
print(df_table)

# Close the Tkinter root window
root.destroy()
























import pandas as pd
from datetime import datetime
import tkinter as tk
from tkinter import simpledialog

# Initialize Tkinter
root = tk.Tk()
root.withdraw()  # Hide the root window

# Function to get user input for parts of the column names, using a cache to avoid duplicate prompts
def get_user_input(prompt, cache={}):
    if prompt not in cache:
        cache[prompt] = simpledialog.askstring("Input", prompt)
    return cache[prompt]

# Define the prompts for unique parts of the column names
prompts = {
    "Unemployment Rate (%)": "Enter the name for 'Unemployment Rate (%)': ",
    "IFRS9 1024 Scenarios": "Enter the name for 'IFRS9 1024 Scenarios': ",
    "IFRS9 4023 Scenarios": "Enter the name for 'IFRS9 4023 Scenarios': ",
    "Hoody's": "Enter the name for 'Hoody's': ",
    "Upside": "Enter the name for 'Upside': ",
    "Central": "Enter the name for 'Central': ",
    "Down 1": "Enter the name for 'Down 1': ",
    "Down 2": "Enter the name for 'Down 2': ",
    "Weighted": "Enter the name for 'Weighted': ",
    "10% UP": "Enter the name for '10% UP': ",
    "10% DN": "Enter the name for '10% DN': ",
    "4% DN": "Enter the name for '4% DN': "
}

# Cache for user inputs
input_cache = {}

# Get user inputs for the column names
column_1 = [
    (get_user_input(prompts["Unemployment Rate (%)"], input_cache), get_user_input(prompts["IFRS9 1024 Scenarios"], input_cache), get_user_input(prompts["Upside"], input_cache)),
    (get_user_input(prompts["Unemployment Rate (%)"], input_cache), get_user_input(prompts["IFRS9 1024 Scenarios"], input_cache), get_user_input(prompts["Central"], input_cache)),
    (get_user_input(prompts["Unemployment Rate (%)"], input_cache), get_user_input(prompts["IFRS9 1024 Scenarios"], input_cache), get_user_input(prompts["Down 1"], input_cache)),
    (get_user_input(prompts["Unemployment Rate (%)"], input_cache), get_user_input(prompts["IFRS9 1024 Scenarios"], input_cache), get_user_input(prompts["Down 2"], input_cache)),
    (get_user_input(prompts["Unemployment Rate (%)"], input_cache), get_user_input(prompts["IFRS9 4023 Scenarios"], input_cache), get_user_input(prompts["Upside"], input_cache)),
    (get_user_input(prompts["Unemployment Rate (%)"], input_cache), get_user_input(prompts["IFRS9 4023 Scenarios"], input_cache), get_user_input(prompts["Central"], input_cache)),
    (get_user_input(prompts["Unemployment Rate (%)"], input_cache), get_user_input(prompts["IFRS9 4023 Scenarios"], input_cache), get_user_input(prompts["Down 1"], input_cache)),
    (get_user_input(prompts["Unemployment Rate (%)"], input_cache), get_user_input(prompts["IFRS9 4023 Scenarios"], input_cache), get_user_input(prompts["Down 2"], input_cache)),
    (get_user_input(prompts["Unemployment Rate (%)"], input_cache), get_user_input(prompts["IFRS9 4023 Scenarios"], input_cache), get_user_input(prompts["Weighted"], input_cache)),
    (get_user_input(prompts["Unemployment Rate (%)"], input_cache), get_user_input(prompts["Hoody's"], input_cache), get_user_input(prompts["10% UP"], input_cache)),
    (get_user_input(prompts["Unemployment Rate (%)"], input_cache), get_user_input(prompts["Hoody's"], input_cache), get_user_input(prompts["Central"], input_cache)),
    (get_user_input(prompts["Unemployment Rate (%)"], input_cache), get_user_input(prompts["Hoody's"], input_cache), get_user_input(prompts["10% DN"], input_cache)),
    (get_user_input(prompts["Unemployment Rate (%)"], input_cache), get_user_input(prompts["Hoody's"], input_cache), get_user_input(prompts["4% DN"], input_cache))
]

# Define the current year
curr_year = datetime.now().year

# Define the row indices
rows = [
    'Q1', 'Q2', 'Q3', 'Q4',
    str(curr_year), 'Q1', 'Q2', 'Q3', 'Q4',
    str(curr_year + 1), str(curr_year + 2), str(curr_year + 3),
    '5yr Avg'
]

# Create the DataFrame with the specified structure
df_table = pd.DataFrame(columns=pd.MultiIndex.from_tuples(column_1), index=rows)

# Display the DataFrame structure
print(df_table)

# Close the Tkinter root window
root.destroy()


























import pandas as pd
from datetime import datetime
import tkinter as tk
from tkinter import simpledialog

# Initialize Tkinter
root = tk.Tk()
root.withdraw()  # Hide the root window

# Define the prompts for unique parts of the column names
prompts = {
    "Unemployment Rate (%)": "Enter the name for 'Unemployment Rate (%)': ",
    "IFRS9 1024 Scenarios": "Enter the name for 'IFRS9 1024 Scenarios': ",
    "IFRS9 4023 Scenarios": "Enter the name for 'IFRS9 4023 Scenarios': ",
    "Hoody's": "Enter the name for 'Hoody's': ",
    "Upside": "Enter the name for 'Upside': ",
    "Central": "Enter the name for 'Central': ",
    "Down 1": "Enter the name for 'Down 1': ",
    "Down 2": "Enter the name for 'Down 2': ",
    "Weighted": "Enter the name for 'Weighted': ",
    "10% UP": "Enter the name for '10% UP': ",
    "10% DN": "Enter the name for '10% DN': ",
    "4% DN": "Enter the name for '4% DN': "
}

# Get user inputs for the unique parts of the column names
input_cache = {prompt: simpledialog.askstring("Input", prompt) for prompt in prompts.values()}

# Define the column names
column_1 = [
    (input_cache[prompts["Unemployment Rate (%)"]], input_cache[prompts["IFRS9 1024 Scenarios"]], input_cache[prompts["Upside"]]),
    (input_cache[prompts["Unemployment Rate (%)"]], input_cache[prompts["IFRS9 1024 Scenarios"]], input_cache[prompts["Central"]]),
    (input_cache[prompts["Unemployment Rate (%)"]], input_cache[prompts["IFRS9 1024 Scenarios"]], input_cache[prompts["Down 1"]]),
    (input_cache[prompts["Unemployment Rate (%)"]], input_cache[prompts["IFRS9 1024 Scenarios"]], input_cache[prompts["Down 2"]]),
    (input_cache[prompts["Unemployment Rate (%)"]], input_cache[prompts["IFRS9 4023 Scenarios"]], input_cache[prompts["Upside"]]),
    (input_cache[prompts["Unemployment Rate (%)"]], input_cache[prompts["IFRS9 4023 Scenarios"]], input_cache[prompts["Central"]]),
    (input_cache[prompts["Unemployment Rate (%)"]], input_cache[prompts["IFRS9 4023 Scenarios"]], input_cache[prompts["Down 1"]]),
    (input_cache[prompts["Unemployment Rate (%)"]], input_cache[prompts["IFRS9 4023 Scenarios"]], input_cache[prompts["Down 2"]]),
    (input_cache[prompts["Unemployment Rate (%)"]], input_cache[prompts["IFRS9 4023 Scenarios"]], input_cache[prompts["Weighted"]]),
    (input_cache[prompts["Unemployment Rate (%)"]], input_cache[prompts["Hoody's"]], input_cache[prompts["10% UP"]]),
    (input_cache[prompts["Unemployment Rate (%)"]], input_cache[prompts["Hoody's"]], input_cache[prompts["Central"]]),
    (input_cache[prompts["Unemployment Rate (%)"]], input_cache[prompts["Hoody's"]], input_cache[prompts["10% DN"]]),
    (input_cache[prompts["Unemployment Rate (%)"]], input_cache[prompts["Hoody's"]], input_cache[prompts["4% DN"]])
]

# Define the current year
curr_year = datetime.now().year

# Define the row indices
rows = [
    'Q1', 'Q2', 'Q3', 'Q4',
    str(curr_year), 'Q1', 'Q2', 'Q3', 'Q4',
    str(curr_year + 1), str(curr_year + 2), str(curr_year + 3),
    '5yr Avg'
]

# Create the DataFrame with the specified structure
df_table = pd.DataFrame(columns=pd.MultiIndex.from_tuples(column_1), index=rows)

# Display the DataFrame structure
print(df_table)

# Close the Tkinter root window
root.destroy()
































import pandas as pd
from datetime import datetime
import tkinter as tk
from tkinter import simpledialog

# Initialize Tkinter
root = tk.Tk()
root.withdraw()  # Hide the root window

# Define the prompts for unique parts of the column names
prompts = [
    "Enter the name for 'Unemployment Rate (%)': ",
    "Enter the name for 'IFRS9 1024 Scenarios': ",
    "Enter the name for 'IFRS9 4023 Scenarios': ",
    "Enter the name for 'Hoody's': ",
    "Enter the name for 'Upside': ",
    "Enter the name for 'Central': ",
    "Enter the name for 'Down 1': ",
    "Enter the name for 'Down 2': ",
    "Enter the name for 'Weighted': ",
    "Enter the name for '10% UP': ",
    "Enter the name for '10% DN': ",
    "Enter the name for '4% DN': "
]

# Get user inputs for the unique parts of the column names
user_inputs = []
for prompt in prompts:
    user_input = simpledialog.askstring("Input", prompt)
    if user_input is None:
        break
    user_inputs.append(user_input)

# Check if all inputs were provided
if len(user_inputs) != len(prompts):
    print("Incomplete inputs provided. Exiting...")
    root.destroy()
    exit()

# Define the column names
column_1 = [
    (user_inputs[0], user_inputs[1], user_inputs[4]),
    (user_inputs[0], user_inputs[1], user_inputs[5]),
    (user_inputs[0], user_inputs[1], user_inputs[6]),
    (user_inputs[0], user_inputs[1], user_inputs[7]),
    (user_inputs[0], user_inputs[2], user_inputs[4]),
    (user_inputs[0], user_inputs[2], user_inputs[5]),
    (user_inputs[0], user_inputs[2], user_inputs[6]),
    (user_inputs[0], user_inputs[2], user_inputs[7]),
    (user_inputs[0], user_inputs[2], user_inputs[8]),
    (user_inputs[0], user_inputs[3], user_inputs[9]),
    (user_inputs[0], user_inputs[3], user_inputs[5]),
    (user_inputs[0], user_inputs[3], user_inputs[10]),
    (user_inputs[0], user_inputs[3], user_inputs[11])
]

# Define the current year
curr_year = datetime.now().year

# Define the row indices
rows = [
    'Q1', 'Q2', 'Q3', 'Q4',
    str(curr_year), 'Q1', 'Q2', 'Q3', 'Q4',
    str(curr_year + 1), str(curr_year + 2), str(curr_year + 3),
    '5yr Avg'
]

# Create the DataFrame with the specified structure
df_table = pd.DataFrame(columns=pd.MultiIndex.from_tuples(column_1), index=rows)

# Display the DataFrame structure
print(df_table)

# Close the Tkinter root window
root.destroy()











import pandas as pd
from datetime import datetime
import tkinter as tk
from tkinter import simpledialog

# Initialize Tkinter
root = tk.Tk()
root.withdraw()  # Hide the root window

# Define the prompts for unique parts of the column names
prompts = [
    "Enter the name for 'Unemployment Rate (%)': ",
    "Enter the name for 'IFRS9 1024 Scenarios': ",
    "Enter the name for 'IFRS9 4023 Scenarios': ",
    "Enter the name for 'Hoody's': ",
    "Enter the name for 'Upside': ",
    "Enter the name for 'Central': ",
    "Enter the name for 'Down 1': ",
    "Enter the name for 'Down 2': ",
    "Enter the name for 'Weighted': ",
    "Enter the name for '10% UP': ",
    "Enter the name for '10% DN': ",
    "Enter the name for '4% DN': "
]

# Get user inputs for the unique parts of the column names
user_inputs = []
for prompt in prompts:
    user_input = simpledialog.askstring("Input", prompt)
    if user_input is None:
        break
    user_inputs.append(user_input)

# Check if all inputs were provided
if len(user_inputs) != len(prompts):
    print("Incomplete inputs provided. Exiting...")
    root.destroy()
    exit()

# Define the column names
column_1 = [
    (user_inputs[0], user_inputs[1], user_inputs[4]),
    (user_inputs[0], user_inputs[1], user_inputs[5]),
    (user_inputs[0], user_inputs[1], user_inputs[6]),
    (user_inputs[0], user_inputs[1], user_inputs[7]),
    (user_inputs[0], user_inputs[2], user_inputs[4]),
    (user_inputs[0], user_inputs[2], user_inputs[5]),
    (user_inputs[0], user_inputs[2], user_inputs[6]),
    (user_inputs[0], user_inputs[2], user_inputs[7]),
    (user_inputs[0], user_inputs[2], user_inputs[8]),
    (user_inputs[0], user_inputs[3], user_inputs[9]),
    (user_inputs[0], user_inputs[3], user_inputs[5]),
    (user_inputs[0], user_inputs[3], user_inputs[10]),
    (user_inputs[0], user_inputs[3], user_inputs[11])
]

# Define the current year
curr_year = datetime.now().year

# Define the row indices
rows = [
    'Q1', 'Q2', 'Q3', 'Q4',
    str(curr_year), 'Q1', 'Q2', 'Q3', 'Q4',
    str(curr_year + 1), str(curr_year + 2), str(curr_year + 3),
    '5yr Avg'
]

# Create the DataFrame with the specified structure
df_table = pd.DataFrame(columns=pd.MultiIndex.from_tuples(column_1), index=rows)

# Display the DataFrame structure
print(df_table)

# Close the Tkinter root window
root.destroy()






















import pandas as pd
from datetime import datetime
import tkinter as tk
from tkinter import simpledialog

# Initialize Tkinter
root = tk.Tk()
root.withdraw()  # Hide the root window

# Define the prompts for unique parts of the column names
prompts = [
    "Enter the name for 'Unemployment Rate (%)': ",
    "Enter the name for 'IFRS9 1024 Scenarios': ",
    "Enter the name for 'IFRS9 4023 Scenarios': ",
    "Enter the name for 'Hoody's': ",
    "Enter the name for 'Upside': ",
    "Enter the name for 'Central': ",
    "Enter the name for 'Down 1': ",
    "Enter the name for 'Down 2': ",
    "Enter the name for 'Weighted': ",
    "Enter the name for '10% UP': ",
    "Enter the name for '10% DN': ",
    "Enter the name for '4% DN': "
]

# Get user inputs for the unique parts of the column names
user_inputs = []
for prompt in prompts:
    user_input = simpledialog.askstring("Input", prompt)
    if user_input is None:
        break
    user_inputs.append(user_input)

# Check if all inputs were provided
if len(user_inputs) != len(prompts):
    print("Incomplete inputs provided. Exiting...")
    root.destroy()
    exit()

def Create_data(user_inputs):
    # Define the column names
    column_1 = [
        (user_inputs[0], user_inputs[1], user_inputs[4]),
        (user_inputs[0], user_inputs[1], user_inputs[5]),
        (user_inputs[0], user_inputs[1], user_inputs[6]),
        (user_inputs[0], user_inputs[1], user_inputs[7]),
        (user_inputs[0], user_inputs[2], user_inputs[4]),
        (user_inputs[0], user_inputs[2], user_inputs[5]),
        (user_inputs[0], user_inputs[2], user_inputs[6]),
        (user_inputs[0], user_inputs[2], user_inputs[7]),
        (user_inputs[0], user_inputs[2], user_inputs[8]),
        (user_inputs[0], user_inputs[3], user_inputs[9]),
        (user_inputs[0], user_inputs[3], user_inputs[5]),
        (user_inputs[0], user_inputs[3], user_inputs[10]),
        (user_inputs[0], user_inputs[3], user_inputs[11])
    ]

    # Define the current year
    curr_year = datetime.now().year

    # Define the row indices
    rows = [
        'Q1', 'Q2', 'Q3', 'Q4',
        str(curr_year), 'Q1', 'Q2', 'Q3', 'Q4',
        str(curr_year + 1), str(curr_year + 2), str(curr_year + 3),
        '5yr Avg'
    ]

    # Create the DataFrame with the specified structure
    df_table = pd.DataFrame(columns=pd.MultiIndex.from_tuples(column_1), index=rows)

    # Display the DataFrame structure
    print(df_table)

# Call the Create_data function with the user inputs
Create_data(user_inputs)

# Close the Tkinter root window
root.destroy()



















from openpyxl import load_workbook
from openpyxl.styles import PatternFill

# Load the workbook and select the sheet
workbook = load_workbook('your_workbook.xlsx')
sheet = workbook['your_sheet_name']

# Define the color fill
sky_blue_fill = PatternFill(start_color="FF87CEFA", end_color="FF87CEFA", fill_type="solid")

# Iterate over the rows to find the cell with the desired value
for row in sheet.iter_rows(min_row=4, max_row=24, min_col=1, max_col=1):
    for cell in row:
        if cell.value == 'IFRS9 1024 Scenarios':
            cell_position = cell.coordinate
            row_idx = cell.row
            col_idx = cell.column

            # Fill the cells with the sky blue color
            for r in range(row_idx, row_idx + 3):
                for c in range(col_idx, col_idx + 4):
                    sheet.cell(row=r, column=c).fill = sky_blue_fill

# Save the workbook
workbook.save('your_workbook_colored.xlsx')

























import pandas as pd
from datetime import datetime
import tkinter as tk
from tkinter import simpledialog
from PIL import Image, ImageTk

# Initialize Tkinter
root = tk.Tk()
root.withdraw()  # Hide the root window

# Function to display the input dialog with logo and custom size
def show_dialog_with_logo(prompt):
    dialog = tk.Toplevel()
    dialog.geometry("500x300")  # Set the size of the dialog
    dialog.title(prompt)

    # Load the image
    img = Image.open("hsbc_1.png")
    img = img.resize((100, 100), Image.ANTIALIAS)  # Resize the image if needed
    logo = ImageTk.PhotoImage(img)

    # Create a label for the image
    img_label = tk.Label(dialog, image=logo)
    img_label.image = logo  # Keep a reference to avoid garbage collection
    img_label.pack(side="left", padx=10, pady=10)

    # Create an entry widget for user input
    entry = tk.Entry(dialog, width=40)
    entry.pack(side="right", padx=10, pady=10)

    # Function to close the dialog and return the entry value
    def on_ok():
        user_input = entry.get()
        dialog.destroy()
        return user_input

    # Create OK button
    ok_button = tk.Button(dialog, text="OK", command=on_ok)
    ok_button.pack(side="bottom", pady=10)

    # Center the dialog on the screen
    dialog.update_idletasks()
    width = dialog.winfo_width()
    height = dialog.winfo_height()
    x = (dialog.winfo_screenwidth() // 2) - (width // 2)
    y = (dialog.winfo_screenheight() // 2) - (height // 2)
    dialog.geometry('{}x{}+{}+{}'.format(width, height, x, y))

    root.wait_window(dialog)
    return entry.get()

# Global cache for user inputs
input_cache = {}

# Function to get user input for parts of the column names, using a cache to avoid duplicate prompts
def get_user_input(prompt):
    if prompt not in input_cache:
        input_cache[prompt] = show_dialog_with_logo(prompt)
    return input_cache[prompt]

# Function to create data
def create_data(tzero_date):
    # Get user inputs for the column names
    unemployment_rate = get_user_input("Enter the name for 'Unemployment Rate (%)': ")
    ifrs9_1024 = get_user_input("Enter the name for 'IFRS9 1024 Scenarios': ")
    ifrs9_4023 = get_user_input("Enter the name for 'IFRS9 4023 Scenarios': ")
    hoodys = get_user_input("Enter the name for 'Hoody's': ")
    upside = get_user_input("Enter the name for 'Upside': ")
    central = get_user_input("Enter the name for 'Central': ")
    down1 = get_user_input("Enter the name for 'Down 1': ")
    down2 = get_user_input("Enter the name for 'Down 2': ")
    weighted = get_user_input("Enter the name for 'Weighted': ")
    ten_percent_up = get_user_input("Enter the name for '10% UP': ")
    ten_percent_dn = get_user_input("Enter the name for '10% DN': ")
    four_percent_dn = get_user_input("Enter the name for '4% DN': ")

    # Define the columns using the collected inputs
    column_1 = [
        (unemployment_rate, ifrs9_1024, upside),
        (unemployment_rate, ifrs9_1024, central),
        (unemployment_rate, ifrs9_1024, down1),
        (unemployment_rate, ifrs9_1024, down2),
        (unemployment_rate, ifrs9_4023, upside),
        (unemployment_rate, ifrs9_4023, central),
        (unemployment_rate, ifrs9_4023, down1),
        (unemployment_rate, ifrs9_4023, down2),
        (unemployment_rate, ifrs9_4023, weighted),
        (unemployment_rate, hoodys, ten_percent_up),
        (unemployment_rate, hoodys, central),
        (unemployment_rate, hoodys, ten_percent_dn),
        (unemployment_rate, hoodys, four_percent_dn)
    ]

    # Define the current year
    curr_year = datetime.now().year

    # Define the row indices
    rows = [
        'Q1', 'Q2', 'Q3', 'Q4',
        str(curr_year), 'Q1', 'Q2', 'Q3', 'Q4',
        str(curr_year + 1), str(curr_year + 2), str(curr_year + 3),
        '5yr Avg'
    ]

    # Create the DataFrame with the specified structure
    df_table = pd.DataFrame(columns=pd.MultiIndex.from_tuples(column_1), index=rows)

    # Display the DataFrame structure
    print(f"tzero_date: {tzero_date}")
    print(df_table)

# Close the Tkinter root window when done
root.destroy()

# Set tzero_date as a fixed string value
tzero_date = "2024-03-31"

# Example loop calling the create_data function
for _ in range(2):  # Replace 2 with the desired number of iterations
    create_data(tzero_date)























import pandas as pd
from openpyxl import load_workbook
from openpyxl.styles import PatternFill
from openpyxl.formatting.rule import ColorScaleRule
import numpy as np

# Load the Excel file
file_path = 'path_to_your_excel_file.xlsx'  # Update with your file path
wb = load_workbook(filename=file_path)
sheet = wb['data edge']

# Load the sheet into a DataFrame
df = pd.read_excel(file_path, sheet_name='data edge')

# Check the condition
if 'Conditional_Formatting_Required' in df.columns and any(df['Conditional_Formatting_Required'] == 'Yes'):
    # Iterate through the sheet and apply formatting based on the specified conditions
    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == '5yr Avg':
                # Define the ranges for max, min, and avg values
                max_value_range = sheet.iter_rows(min_row=cell.row-18, max_row=cell.row-3, min_col=cell.column, max_col=cell.column+4)
                min_value_range = sheet.iter_rows(min_row=cell.row-18, max_row=cell.row-3, min_col=cell.column, max_col=cell.column+4)
                avg_value_range = sheet.iter_rows(min_row=cell.row-2, max_row=cell.row, min_col=cell.column+2, max_col=cell.column+2)

                # Extract values from the ranges
                max_values = [c.value for r in max_value_range for c in r if isinstance(c.value, (int, float))]
                min_values = [c.value for r in min_value_range for c in r if isinstance(c.value, (int, float))]
                avg_values = [c.value for r in avg_value_range for c in r if isinstance(c.value, (int, float))]

                # Calculate max, min, and avg values
                max_value = max(max_values) if max_values else None
                min_value = min(min_values) if min_values else None
                avg_value = np.mean(avg_values) if avg_values else None

                # Define the data range for conditional formatting
                data_range = f'{sheet.cell(row=cell.row-2, column=cell.column).coordinate}:{sheet.cell(row=cell.row-1, column=cell.column+4).coordinate}'

                # Define colors
                min_color = "FFCCCC"
                mid_color = "FFFFCC"
                max_color = "CCFFCC"

                # Create the color scale rule
                rule = ColorScaleRule(start_type='num', start_value=min_value, start_color=min_color,
                                      mid_type='num', mid_value=avg_value, mid_color=mid_color,
                                      end_type='num', end_value=max_value, end_color=max_color)

                # Apply the conditional formatting
                sheet.conditional_formatting.add(data_range, rule)

# Save the workbook
wb.save('path_to_your_output_file.xlsx')  # Update with your desired output file path




















import pandas as pd
import openpyxl
from openpyxl.formatting.rule import ColorScaleRule
import numpy as np

def formatting_1(sheet):
    # Read the morpho_1.xlsx file
    file_path = r'c:/pat/ram.xlsx'
    morpho_df = pd.read_excel(file_path, sheet_name='Data_Edge')

    # Iterate over the rows in the sheet
    for row in sheet.iter_rows():
        for cell in row:
            # Check if the cell value matches any value in the 'Checks' column
            checks_values = morpho_df.loc[morpho_df['ISOCODES'] == sheet.title, 'Checks'].tolist()
            if cell.value in checks_values:
                # Get the corresponding 'Conditional_Formatting_Required' value
                conditional_formatting_required = morpho_df.loc[(morpho_df['ISOCODES'] == sheet.title) & (morpho_df['Checks'] == cell.value), 'Conditional_Formatting_Required'].values[0]

                # Check if 'Conditional_Formatting_Required' is 'Yes'
                if conditional_formatting_required == 'Yes':
                    if cell.value == '5yr Avg':
                        max_value_range = sheet.iter_rows(min_row=cell.row - 18, max_row=cell.row - 3, min_col=cell.column + 1, max_col=cell.column + 4)
                        min_value_range = sheet.iter_rows(min_row=cell.row - 18, max_row=cell.row - 3, min_col=cell.column + 1, max_col=cell.column + 4)
                        avg_value_range = sheet.iter_rows(min_row=cell.row - 2, max_row=cell.row, min_col=cell.column + 2, max_col=cell.column + 2)

                        max_values = [c.value for r in max_value_range for c in r if isinstance(c.value, (int, float))]
                        min_values = [c.value for r in min_value_range for c in r if isinstance(c.value, (int, float))]
                        avg_values = [c.value for r in avg_value_range for c in r if isinstance(c.value, (int, float))]

                        max_value = max(max_values) if max_values else None
                        min_value = min(min_values) if min_values else None
                        avg_value = np.mean(avg_values) if avg_values else None

                        data_range = f'{sheet.cell(row=cell.row - 2, column=cell.column + 1).coordinate}:{sheet.cell(row=cell.row - 1, column=cell.column + 4).coordinate}'
                        min_color = "FFCCCC"
                        mid_color = "FFFFFF"
                        max_color = 'CCFFCC'

                        rule = ColorScaleRule(start_type='num', start_value=max_value, start_color=min_color, mid_type='num', mid_value=avg_value, mid_color=mid_color, end_type='num', end_value=min_value, end_color=max_color)
                        sheet.conditional_formatting.add(data_range, rule)

# Usage example
file_path = r'c:/pat/ram.xlsx'
workbook = openpyxl.load_workbook(file_path)

# Iterate over each sheet in the workbook
for sheet_name in workbook.sheetnames:
    sheet = workbook[sheet_name]
    formatting_1(sheet)

# Save the updated workbook
workbook.save(file_path)
















import pandas as pd
import openpyxl
from openpyxl.formatting.rule import ColorScaleRule
import numpy as np

def apply_conditional_formatting(sheet, checks_value):
    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == checks_value:
                # Look for '5yr Avg' in the previous column of the same row
                if cell.col_idx > 1:  # Ensure we don't go out of bounds
                    target_cell = sheet.cell(row=cell.row, column=cell.col_idx - 1)
                    if target_cell.value == '5yr Avg':
                        max_value_range = sheet.iter_rows(min_row=cell.row - 18, max_row=cell.row - 3, min_col=cell.col_idx + 1, max_col=cell.col_idx + 4)
                        min_value_range = sheet.iter_rows(min_row=cell.row - 18, max_row=cell.row - 3, min_col=cell.col_idx + 1, max_col=cell.col_idx + 4)
                        avg_value_range = sheet.iter_rows(min_row=cell.row - 2, max_row=cell.row, min_col=cell.col_idx + 2, max_col=cell.col_idx + 2)

                        max_values = [c.value for r in max_value_range for c in r if isinstance(c.value, (int, float))]
                        min_values = [c.value for r in min_value_range for c in r if isinstance(c.value, (int, float))]
                        avg_values = [c.value for r in avg_value_range for c in r if isinstance(c.value, (int, float))]

                        max_value = max(max_values) if max_values else None
                        min_value = min(min_values) if min_values else None
                        avg_value = np.mean(avg_values) if avg_values else None

                        data_range = f'{sheet.cell(row=cell.row - 2, column=cell.col_idx + 1).coordinate}:{sheet.cell(row=cell.row - 1, column=cell.col_idx + 4).coordinate}'
                        min_color = "FFCCCC"
                        mid_color = "FFFFFF"
                        max_color = 'CCFFCC'

                        rule = ColorScaleRule(start_type='num', start_value=max_value, start_color=min_color, mid_type='num', mid_value=avg_value, mid_color=mid_color, end_type='num', end_value=min_value, end_color=max_color)
                        sheet.conditional_formatting.add(data_range, rule)

def formatting_1(sheet, morpho_df):
    # Get the current sheet name (ISOCODES)
    isocode = sheet.title

    # Filter DataFrame for the current ISOCODES
    filtered_df = morpho_df[morpho_df['ISOCODES'] == isocode]

    # Iterate over the filtered rows
    for _, row in filtered_df.iterrows():
        checks_value = row['Checks']
        conditional_formatting_required = row['Conditional_Formatting_Required']

        # Check if conditional formatting is required
        if conditional_formatting_required == 'Yes':
            apply_conditional_formatting(sheet, checks_value)

def main():
    # Paths to the files
    file_path = r'c:/pat/ram.xlsx'
    morpho_path = r'c:/pat/morpho_1.xlsx'

    # Load the main Excel file
    workbook = openpyxl.load_workbook(file_path)

    # Read the morpho_1.xlsx file
    morpho_df = pd.read_excel(morpho_path, sheet_name='Data_Edge')

    # Iterate over each sheet in the workbook
    for sheet_name in workbook.sheetnames:
        sheet = workbook[sheet_name]
        formatting_1(sheet, morpho_df)

    # Save the updated workbook
    workbook.save(file_path)

# Execute the main function
if __name__ == "__main__":
    main()










data_range = f'(sheet.cell(row=target_cell.row 7, column=target_cell.column + 1).coordinate): (sheet.cell(row=target_cell.row - 4, column=target_cell.column + 4).coordinate)'













import pandas as pd
import openpyxl
import numpy as np

def conditional_formatting_IFRS10_1(sheet):
    # Define the path to the workbook
    workbook_path = r"C:\Users\45363901\PycharmProjects\pythonProject\pythonProject2 GBIC Workings Data\Input\Mapping File Copy.xlsx"

    # Read the Excel file and load the specified sheet into a DataFrame
    df = pd.read_excel(workbook_path, sheet_name="Data_Edge")

    # Iterate over the rows in the sheet
    for row in sheet.iter_rows():
        for cell in row:
            # Get the check values that contain 'QoQ' and have conditional formatting required as 'Yes'
            checks_value = df.loc[
                (df['ISOCODES'] == sheet.title) &
                (df['Checks'].str.contains('QoQ')) &
                (df['Conditional_Formatting_Required'] == 'Yes'),
                'Checks'
            ].tolist()

            # Check if the cell value matches any of the check values
            for value in checks_value:
                if cell.value == value:
                    if cell.col_idx > 1:
                        target_cell = sheet.cell(row=cell.row, column=cell.col_idx - 1)
                        if target_cell.value == '5yr Avg':
                            # Define the data range based on the target cell
                            data_range = f'{sheet.cell(row=target_cell.row + 7, column=target_cell.column + 1).coordinate}:{sheet.cell(row=target_cell.row - 4, column=target_cell.column + 4).coordinate}'
                            # Clear the numbers in the specified range
                            for cell_range in sheet[data_range]:
                                for target in cell_range:
                                    if isinstance(target.value, (int, float)):
                                        target.value = None

# Example usage
file_path = r"C:\Users\45363901\PycharmProjects\pythonProject\pythonProject2 GBIC Workings Data\Input\Mapping File Copy.xlsx"
workbook = openpyxl.load_workbook(file_path)

# Iterate over each sheet in the workbook
for sheet_name in workbook.sheetnames:
    sheet = workbook[sheet_name]
    conditional_formatting_IFRS10_1(sheet)

# Save the updated workbook
workbook.save(file_path)







import openpyxl

def insert_empty_column_after_weighted(sheet):
    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == "Weighted":
                # Insert a new column after the column containing "Weighted"
                col_idx = cell.column
                sheet.insert_cols(col_idx + 1)

                # Set the width of the new column to 0.32
                new_col_letter = openpyxl.utils.get_column_letter(col_idx + 1)
                sheet.column_dimensions[new_col_letter].width = 0.32

                # Break to avoid processing the same row multiple times
                break

# Example usage
file_path = r"C:\Users\45363901\PycharmProjects\pythonProject\pythonProject2 GBIC Workings Data\Input\Mapping File Copy.xlsx"
workbook = openpyxl.load_workbook(file_path)

# Iterate over each sheet in the workbook
for sheet_name in workbook.sheetnames:
    sheet = workbook[sheet_name]
    insert_empty_column_after_weighted(sheet)

# Save the updated workbook
workbook.save(file_path)














def calculate_weights(df_table, Isocode):
    mapping_file_path = r"C:\Users\45363901\PycharmProjects\pythonProject\pythonProject2\GBIC_Workings\Data\Input\Mapping_File Copy.xlsx"
    Country_sheet = pd.read_excel(mapping_file_path, sheet_name="Country")
    Scenario_Weights_sheet = pd.read_excel(mapping_file_path, sheet_name='Scenario_weights')
    merged_sheet = Scenario_Weights_sheet.merge(Country_sheet)

    u1 = merged_sheet[(merged_sheet['ISOCODE'] == Isocode) & (merged_sheet['SCENARIO_NAME'] == '1')].WEIGHT.values
    cn = merged_sheet[(merged_sheet['ISOCODE'] == Isocode) & (merged_sheet['SCENARIO_NAME'] == 'CN')].WEIGHT.values
    d1 = merged_sheet[(merged_sheet['ISOCODE'] == Isocode) & (merged_sheet['SCENARIO_NAME'] == 'D1')].WEIGHT.values
    d2 = merged_sheet[(merged_sheet['ISOCODE'] == Isocode) & (merged_sheet['SCENARIO_NAME'] == 'D2')].WEIGHT.values

    for i in range(0, 18):
        df_table.iloc[i, 4] = (df_table.iloc[i, 0] * u1 + df_table.iloc[i, 1] * cn + df_table.iloc[i, 2] * d1 + df_table.iloc[i, 3] * d2).round(1)
        df_table.iloc[i, 9] = (df_table.iloc[i, 5] * u1 + df_table.iloc[i, 6] * cn + df_table.iloc[i, 7] * d1 + df_table.iloc[i, 8] * d2).round(1)

    return df_table




def construct_and_populate_tables(Isocode, tzero_date, col):
    curr_year = 2024
    column_1 = [
        ('Unemployment Rate (%)', 'IFRS9 2024 Scenarios', 'Upside'),
        ('Unemployment Rate (%)', 'IFRS9 2024 Scenarios', 'Central'),
        ('Unemployment Rate (%)', 'IFRS9 2024 Scenarios', 'Down 1'),
        ('Unemployment Rate (%)', 'IFRS9 2024 Scenarios', 'Down 2'),
        ('Unemployment Rate (%)', 'IFRS9 2024 Scenarios', 'Weighted'),

        ('Unemployment Rate (%)', 'IFRS9 2023 Scenarios', 'Upside'),
        ('Unemployment Rate (%)', 'IFRS9 2023 Scenarios', 'Central'),
        ('Unemployment Rate (%)', 'IFRS9 2023 Scenarios', 'Down 1'),
        ('Unemployment Rate (%)', 'IFRS9 2023 Scenarios', 'Down 2'),
        ('Unemployment Rate (%)', 'IFRS9 2023 Scenarios', 'Weighted'),

        ('Unemployment Rate (%)', 'Moody\'s', '10% UP'),
        ('Unemployment Rate (%)', 'Moody\'s', 'Central'),
        ('Unemployment Rate (%)', 'Moody\'s', '10% DN'),
        ('Unemployment Rate (%)', 'Moody\'s', '4% DN')
    ]

    rows = ['Q1', 'Q2', 'Q3', 'Q4', str(curr_year - 1), 'Q1', 'Q2', 'Q3', 'Q4', str(curr_year), 'Q1', 'Q2', 'Q3', 'Q4', str(curr_year + 1), str(curr_year + 2), str(curr_year + 3), '5Yr Avg']

    df_table = pd.DataFrame(columns=pd.MultiIndex.from_tuples(column_1), index=rows)

    year3_sum = year4_sum = 0
    col_index = 0

    for frame in All:
        for row in frame.itertuples():
            # Populating the table similar to the existing logic
            # The code below assumes 'getattr(row, col)' gives the right data for each 'row'
            if row.ISOCODES == Isocode:
                if row.date == datetime.strptime(f"{curr_year - 1}-03-31 00:00:00", "%Y-%m-%d %H:%M:%S"):
                    df_table.iloc[0, col_index] = round(getattr(row, col), 1)
                # Repeat for other dates and quarters
                # ...

    df_table = df_table.round(1)
    df_table = calculate_weights(df_table, Isocode)

    return df_table








import openpyxl
import pandas as pd
from openpyxl import load_workbook, Workbook
from openpyxl.styles import Font, PatternFill, Side, Border, Alignment
from openpyxl.formatting.rule import ColorScaleRule
from openpyxl.styles.borders import Border, Side, BORDER_THIN
from openpyxl.utils import get_column_letter
from datetime import datetime
from dateutil.relativedelta import relativedelta

def add_output_columns(sheet, df):
    df["GDP_YR"] = df.groupby(["ISOCODES"])["GDP"].pct_change(4) * 100
    df["CPI_YR"] = df.groupby(["ISOCODES"])["CPI"].pct_change(4) * 100
    df["PH_YR"] = df.groupby(["ISOCODES"])["PH"].pct_change(4) * 100
    df["PH_DUBAI_YR"] = df.groupby(["ISOCODES"])["PH_DUBAI"].pct_change(4) * 100
    df["PCOM_YR"] = df.groupby(["ISOCODES"])["PCOM"].pct_change(4) * 100
    df["GDP_QoQ"] = df.groupby(["ISOCODES"])["GDP"].pct_change(1) * 100
    df["CPI_QoQ"] = df.groupby(["ISOCODES"])["CPI"].pct_change(1) * 100
    df["PH_QoQ"] = df.groupby(["ISOCODES"])["PH"].pct_change(1) * 100
    df["PH_DUBAI_QoQ"] = df.groupby(["ISOCODES"])["PH_DUBAI"].pct_change(1) * 100
    df["PCOM_QoQ"] = df.groupby(["ISOCODES"])["PCOM"].pct_change(1) * 100
    return df.round(1)

input_file = r"C:\Users\45363901\PycharmProjects\pythonProject\pythonProject2\GBIC_Workings Data\Input\Data - Copy.xlsx"
workbook = openpyxl.load_workbook(input_file)
sheetNames = workbook.sheetnames
All = list()
for sheet in sheetNames:
    df = pd.read_excel(input_file, sheet_name=sheet)
    df = add_output_columns(sheet, df)
    All.append(df)

def calculate_5year_avg(frame, Isocode, tzero_date, col):
    index = frame[(frame['ISOCODES'] == Isocode) & (frame['date'] == datetime.strptime(tzero_date + " 00:00:00", "%Y-%m-%d %H:%M:%S"))].index
    index = index[0] + 1
    avg = frame[col].iloc[index: (index + 20)].mean()
    return avg

def calculate_weights(df_table, Isocode):
    mapping_file_path = "C:\Users\45363901\PycharmProjects\pythonProject\pythonProject2\GBIC_Workings Data\Input\Mapping_File Copy.xlsx"
    Country_sheet = pd.read_excel(mapping_file_path, sheet_name='Country')
    Scenario_Weights_sheet = pd.read_excel(mapping_file_path, sheet_name='Scenario_Weights')
    merged_sheet = Scenario_Weights_sheet.merge(Country_sheet)
    u1 = merged_sheet[(merged_sheet['ISOCODE'] == Isocode) & (merged_sheet['SCENARIO_NAME'] == 'U1')]['WEIGHT'].values[0]
    cn = merged_sheet[(merged_sheet['ISOCODE'] == Isocode) & (merged_sheet['SCENARIO_NAME'] == 'CN')]['WEIGHT'].values[0]
    d1 = merged_sheet[(merged_sheet['ISOCODE'] == Isocode) & (merged_sheet['SCENARIO_NAME'] == 'D1')]['WEIGHT'].values[0]
    d2 = merged_sheet[(merged_sheet['ISOCODE'] == Isocode) & (merged_sheet['SCENARIO_NAME'] == 'D2')]['WEIGHT'].values[0]

    for i in range(0, 18):
        df_table.values[i][8] = ((df_table.values[i][4] * u1) + (df_table.values[i][5] * cn) + (df_table.values[i][6] * d1) + (df_table.values[i][7] * d2))[0]
        df_table.values[i][9] = ((df_table.values[i][5] * u1) + (df_table.values[i][6] * cn) + (df_table.values[i][7] * d1) + (df_table.values[i][8] * d2))[0]
        df_table.values[i][4] = ((df_table.values[i][0] * u1) + (df_table.values[i][1] * cn) + (df_table.values[i][2] * d1) + (df_table.values[i][3] * d2))[0]

def construct_and_populate_tables(Isocode, tzero_date, col):
    # curr_year = int(input("enter the current year: "))
    curr_year = 2024
    column_1 = [('Unemployment Rate (%)', 'IFRS9 2024 Scenarios', 'Upside'), ('Unemployment Rate (%)', 'IFRS9 2024 Scenarios', 'Central'), ('Unemployment Rate (%)', 'IFRS9 2024 Scenarios', 'Down 1'), ('Unemployment Rate (%)', 'IFRS9 2024 Scenarios', 'Down 2'), ('Unemployment Rate (%)', 'IFRS9 2024 Scenarios', 'Weighted'), ('Unemployment Rate (%)', 'IFRS9 2023 Scenarios', 'Upside'), ('Unemployment Rate (%)', 'IFRS9 2023 Scenarios', 'Central'), ('Unemployment Rate (%)', 'IFRS9 2023 Scenarios', 'Down 1'), ('Unemployment Rate (%)', 'IFRS9 2023 Scenarios', 'Weighted'), ('Unemployment Rate (%)', "Moody's", '10% UP'), ('Unemployment Rate (%)', 'Moody\'s', 'Central'), ('Unemployment Rate (%)', 'Moody\'s', '10% DN'), ('Unemployment Rate (%)', 'Moody\'s', '4% DN')]
    rows = ['Q1', 'Q2', 'Q3', 'Q4', str(curr_year-1), 'Q1', 'Q2', 'Q3', 'Q4', str(curr_year), 'Q1', 'Q2', 'Q3', 'Q4', str(curr_year + 1), str(curr_year + 2), str(curr_year + 3), 'Syr Avg']

    # Creating DataFrames for each element in column_names
    df_table = pd.DataFrame(columns=pd.MultiIndex.from_tuples(column_1), index=rows)
    year3_sum = 0
    year4_sum = 0
    col_index = 0

    # tzero_date = input("please give the tzero input: ")
    for frame in All:
        for row in frame.itertuples():
            # for previous year
            if row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year - 1) + "-03-31 00:00:00", "%Y-%m-%d %H:%M:%S"):
                df_table.values[0][col_index] = round(getattr(row, col), 1)
            if row.ISOCODES ==




















import openpyxl
from openpyxl.utils import get_column_letter
from openpyxl.worksheet.worksheet import Worksheet

def find_column_index(sheet: Worksheet, header_text: str) -> int:
    """
    Find the column index based on the header text.

    Parameters:
    sheet (openpyxl.worksheet.worksheet.Worksheet): The sheet to search in.
    header_text (str): The text to search for in the headers.

    Returns:
    int: The index (1-based) of the column containing the header text, or -1 if not found.
    """
    for row in sheet.iter_rows(min_row=1, max_row=1):
        for cell in row:
            if cell.value == header_text:
                return cell.column
    return -1

def adjust_merged_cells(sheet: Worksheet, col_idx: int):
    """
    Adjust the merged cell ranges to include the new column.

    Parameters:
    sheet (openpyxl.worksheet.worksheet.Worksheet): The sheet containing merged cells.
    col_idx (int): The index (1-based) of the new column to be inserted.
    """
    for merged_range in list(sheet.merged_cells.ranges):
        min_col, min_row, max_col, max_row = openpyxl.utils.range_boundaries(str(merged_range))
        if min_col <= col_idx <= max_col:
            # If the column to be inserted is within the merged cell range
            new_max_col = max_col + 1
            sheet.unmerge_cells(start_row=min_row, start_column=min_col, end_row=max_row, end_column=max_col)
            sheet.merge_cells(start_row=min_row, start_column=min_col, end_row=max_row, end_column=new_max_col)
        elif col_idx <= min_col:
            # If the column to be inserted is before the merged cell range
            new_min_col = min_col + 1
            new_max_col = max_col + 1
            sheet.unmerge_cells(start_row=min_row, start_column=min_col, end_row=max_row, end_column=max_col)
            sheet.merge_cells(start_row=min_row, start_column=new_min_col, end_row=max_row, end_column=new_max_col)

def insert_empty_column_after_weighted(sheet: Worksheet, width=0.33):
    """
    Inserts an empty column after the column containing 'Weighted'.

    Parameters:
    sheet (openpyxl.worksheet.worksheet.Worksheet): The sheet where the column will be inserted.
    width (float): The width of the new column.
    """
    col_idx = find_column_index(sheet, 'Weighted')
    if col_idx == -1:
        raise ValueError("Column with header 'Weighted' not found.")

    col_idx += 1  # Insert after the 'Weighted' column

    # Adjust the merged cell ranges
    adjust_merged_cells(sheet, col_idx)

    # Insert the column
    sheet.insert_cols(col_idx)

    # Set the width of the new column
    col_letter = get_column_letter(col_idx)
    sheet.column_dimensions[col_letter].width = width

# Example usage:
# Load your workbook and sheet
input_file = r"C:\Users\45363901\PycharmProjects\pythonProject\pythonProject2\GBIC_Workings Data\Input\Data - Copy.xlsx"
workbook = openpyxl.load_workbook(input_file)
sheet = workbook.active

# Insert an empty column after the column containing 'Weighted'
insert_empty_column_after_weighted(sheet)

# Save the workbook
workbook.save(input_file)












import openpyxl
from openpyxl.utils import get_column_letter
from openpyxl.worksheet.worksheet import Worksheet

def insert_empty_column_after_weighted(sheet: Worksheet):
    # Find the cell with the value "Weighted"
    def find_cell(sheet: Worksheet, text: str):
        for row in sheet.iter_rows():
            for cell in row:
                if cell.value == text:
                    return cell
        return None

    # Adjust merged cells to include the new column
    def adjust_merged_cells(sheet: Worksheet, col_idx: int):
        for merged_range in list(sheet.merged_cells.ranges):
            min_col, min_row, max_col, max_row = openpyxl.utils.range_boundaries(str(merged_range))
            if min_col <= col_idx <= max_col:
                new_max_col = max_col + 1
                sheet.unmerge_cells(start_row=min_row, start_column=min_col, end_row=max_row, end_column=max_col)
                sheet.merge_cells(start_row=min_row, start_column=min_col, end_row=max_row, end_column=new_max_col)
            elif col_idx <= min_col:
                new_min_col = min_col + 1
                new_max_col = max_col + 1
                sheet.unmerge_cells(start_row=min_row, start_column=min_col, end_row=max_row, end_column=max_col)
                sheet.merge_cells(start_row=min_row, start_column=new_min_col, end_row=max_row, end_column=new_max_col)

    # Find the cell with the text "Weighted"
    weighted_cell = find_cell(sheet, 'Weighted')
    if not weighted_cell:
        raise ValueError("Cell with value 'Weighted' not found.")

    col_idx = weighted_cell.column + 1  # Insert after the column containing "Weighted"

    # Adjust the merged cell ranges
    adjust_merged_cells(sheet, col_idx)

    # Insert the column
    sheet.insert_cols(col_idx)

    # Set the width of the new column
    col_letter = get_column_letter(col_idx)
    sheet.column_dimensions[col_letter].width = 0.33

# Example usage:
input_file = r"C:\Users\45363901\PycharmProjects\pythonProject\pythonProject2\GBIC_Workings Data\Input\Data - Copy.xlsx"
workbook = openpyxl.load_workbook(input_file)
sheet = workbook.active

insert_empty_column_after_weighted(sheet)

workbook.save(input_file)



















import openpyxl
from openpyxl.utils import get_column_letter
from openpyxl.worksheet.worksheet import Worksheet

def empty_column_width(sheet: Worksheet):
    # Find the columns containing "Down 2" and "Weighted"
    down2_col = None
    weighted_col = None

    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == "Down 2":
                down2_col = cell.column
            if cell.value == "Weighted":
                weighted_col = cell.column
            if down2_col and weighted_col:
                break
        if down2_col and weighted_col:
            break

    if down2_col is None or weighted_col is None:
        raise ValueError("One or both of the columns with 'Down 2' or 'Weighted' not found.")

    # Set the width of all columns after the largest column index found
    start_col_idx = max(down2_col, weighted_col)
    for col_idx in range(start_col_idx + 1, sheet.max_column + 1):
        col_letter = get_column_letter(col_idx)
        sheet.column_dimensions[col_letter].width = 0.33

# Example usage:
input_file = r"C:\Users\45363901\PycharmProjects\pythonProject\pythonProject2\GBIC_Workings Data\Input\Data - Copy.xlsx"
workbook = openpyxl.load_workbook(input_file)
sheet = workbook.active

empty_column_width(sheet)

workbook.save(input_file)





























from openpyxl.utils import get_column_letter

def empty_column_width(sheet):
    # Find the column index of "Down 2"
    col_down_2 = None
    for col in sheet.iter_cols(min_row=1, max_row=1):
        cell = col[0]
        if cell.value == "Down 2":
            col_down_2 = cell.column
            break

    # Find the column index of "Weighted"
    col_weighted = None
    for col in sheet.iter_cols(min_row=1, max_row=1):
        cell = col[0]
        if cell.value == "Weighted":
            col_weighted = cell.column
            break

    # Set the width of columns after "Down 2" and "Weighted" to 0.33
    for col_idx in range(col_down_2 + 1, col_weighted):
        sheet.column_dimensions[get_column_letter(col_idx)].width = 0.33

    for col_idx in range(col_weighted + 1, sheet.max_column + 1):
        sheet.column_dimensions[get_column_letter(col_idx)].width = 0.33

    # Set the width of the "Weighted" column to 7.57
    sheet.column_dimensions[get_column_letter(col_weighted)].width = 7.57

    # Set the width of all other columns to 6.14
    for col_idx in range(1, col_down_2):
        sheet.column_dimensions[get_column_letter(col_idx)].width = 6.14

    for col_idx in range(col_down_2, col_weighted):
        sheet.column_dimensions[get_column_letter(col_idx)].width = 6.14






















def row_height(sheet):
    # Set the height of all rows to 14.5
    for row in sheet.iter_rows():
        for cell in row:
            sheet.row_dimensions[cell.row].height = 14.5











def delete_hidden_rows(sheet):
    # Iterate over rows in reverse order
    for row in reversed(list(sheet.iter_rows())):
        # Check if the row is hidden
        if sheet.row_dimensions[row[0].row].hidden:
            sheet.delete_rows(row[0].row, 1)













from openpyxl.utils import get_column_letter

def empty_column_width(sheet):
    col_weighted = None
    col_down_2 = None

    # Find the column index of "Down 2"
    for row in sheet.iter_rows(min_row=1, max_row=1):
        for cell in row:
            if cell.value == "Down 2":
                col_down_2 = cell.column
                break

    # Find the column index of "Weighted"
    for row in sheet.iter_rows(min_row=1, max_row=1):
        for cell in row:
            if cell.value == "Weighted":
                col_weighted = cell.column
                break

    # Check if both columns were found
    if col_down_2 is None or col_weighted is None:
        print("Error: 'Down 2' or 'Weighted' column not found in the first row.")
        return

    # Set the width of columns after "Down 2" and before "Weighted" to 0.33
    for row in sheet.iter_rows():
        for cell in row:
            if cell.column > col_down_2 and cell.column < col_weighted:
                sheet.column_dimensions[get_column_letter(cell.column)].width = 0.33

    # Set the width of columns after "Weighted" to 0.33
    for row in sheet.iter_rows():
        for cell in row:
            if cell.column > col_weighted:
                sheet.column_dimensions[get_column_letter(cell.column)].width = 0.33

    # Set the width of the "Weighted" column to 7.57
    sheet.column_dimensions[get_column_letter(col_weighted)].width = 7.57

    # Set the width of all other columns to 6.14
    for row in sheet.iter_rows():
        for cell in row:
            if cell.column < col_down_2 or (cell.column > col_down_2 and cell.column < col_weighted):
                sheet.column_dimensions[get_column_letter(cell.column)].width = 6.14





















from openpyxl.utils import get_column_letter

def column_width(sheet):
    col_down_2 = None
    col_weighted = None

    # Find the column index of "Down 2"
    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == "Down 2":
                col_down_2 = cell.column
                break
        if col_down_2:
            break

    # Find the column index of "Weighted"
    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == "Weighted":
                col_weighted = cell.column
                break
        if col_weighted:
            break

    # Check if both columns were found
    if col_down_2 is None or col_weighted is None:
        print("Error: 'Down 2' or 'Weighted' not found in the worksheet.")
        return

    # Set the width of columns after "Down 2" and before "Weighted" to 0.33
    for col_idx in range(col_down_2 + 1, col_weighted):
        sheet.column_dimensions[get_column_letter(col_idx)].width = 0.33

    # Set the width of columns after "Weighted" to 0.33
    for col_idx in range(col_weighted + 1, sheet.max_column + 1):
        sheet.column_dimensions[get_column_letter(col_idx)].width = 0.33

    # Set the width of the "Weighted" column to 7.57
    sheet.column_dimensions[get_column_letter(col_weighted)].width = 7.57

    # Set the width of all other columns to 6.14
    for col_idx in range(1, col_down_2):
        sheet.column_dimensions[get_column_letter(col_idx)].width = 6.14

    for col_idx in range(col_down_2, col_weighted):
        sheet.column_dimensions[get_column_letter(col_idx)].width = 6.14



















from openpyxl.utils import get_column_letter

def column_width(sheet):
    columns_with_down_2 = set()
    columns_with_weighted = set()

    # Find the columns containing "Down 2" and "Weighted"
    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == "Down 2":
                columns_with_down_2.add(cell.column)
            elif cell.value == "Weighted":
                columns_with_weighted.add(cell.column)

    # Set the width of columns immediately after "Down 2" and "Weighted" to 0.33
    for col_idx in range(1, sheet.max_column + 1):
        if col_idx in columns_with_down_2 or col_idx in columns_with_weighted:
            sheet.column_dimensions[get_column_letter(col_idx + 1)].width = 0.33

    # Set the width of columns containing "Weighted" to 7.57
    for col_idx in columns_with_weighted:
        sheet.column_dimensions[get_column_letter(col_idx)].width = 7.57

    # Set the width of all other columns to 6.14
    for col_idx in range(1, sheet.max_column + 1):
        if col_idx not in columns_with_down_2 and col_idx not in columns_with_weighted and col_idx + 1 not in columns_with_down_2 and col_idx + 1 not in columns_with_weighted:
            sheet.column_dimensions[get_column_letter(col_idx)].width = 6.14





























import openpyxl
from openpyxl.utils import get_column_letter
from openpyxl.worksheet.worksheet import Worksheet

def column_width(sheet: Worksheet):
    weighted_columns = set()
    down2_columns = set()

    # Identify the columns containing "Down 2" and "Weighted"
    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == "Down 2":
                down2_columns.add(cell.column)
            if cell.value == "Weighted":
                weighted_columns.add(cell.column)

    # Set the width of all columns to 6.14 initially
    for col_idx in range(1, sheet.max_column + 1):
        col_letter = get_column_letter(col_idx)
        sheet.column_dimensions[col_letter].width = 6.14

    # Set the width for columns containing "Weighted"
    for col_idx in weighted_columns:
        col_letter = get_column_letter(col_idx)
        sheet.column_dimensions[col_letter].width = 7.57

    # Set the width of the columns immediately after "Down 2" and "Weighted" to 0.33
    for col_idx in down2_columns.union(weighted_columns):
        next_col_idx = col_idx + 1
        if next_col_idx <= sheet.max_column:
            next_col_letter = get_column_letter(next_col_idx)
            sheet.column_dimensions[next_col_letter].width = 0.33

# Example usage:
input_file = r"C:\Users\45363901\PycharmProjects\pythonProject\pythonProject2\GBIC_Workings Data\Input\Data - Copy.xlsx"
workbook = openpyxl.load_workbook(input_file)
sheet = workbook.active

column_width(sheet)

workbook.save(input_file)



















from openpyxl import load_workbook

def set_column_widths(sheet):
    weighted_columns = []
    narrow_columns = []

    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == 'Down 2':
                narrow_columns.append(cell.column + 1)  # Column just after 'Down 2'
            if cell.value == 'Weighted':
                weighted_columns.append(cell.column)  # Column containing 'Weighted'
                narrow_columns.append(cell.column + 1)  # Column just after 'Weighted'

    # Set default column width
    for col in range(1, sheet.max_column + 1):
        sheet.column_dimensions[sheet.cell(row=1, column=col).column_letter].width = 6.14

    # Set column width for 'Weighted'
    for col in weighted_columns:
        sheet.column_dimensions[sheet.cell(row=1, column=col).column_letter].width = 7.57

    # Set column width for columns after 'Down 2' and 'Weighted'
    for col in narrow_columns:
        sheet.column_dimensions[sheet.cell(row=1, column=col).column_letter].width = 0.33

# Example usage
input_file = "your_excel_file.xlsx"
wb = load_workbook(input_file)
sheet = wb.active  # Adjust if you need a specific sheet

set_column_widths(sheet)

wb.save("your_modified_excel_file.xlsx")
























from openpyxl import load_workbook

def column_of_trough(sheet):
    # Helper function to find cells with specific values
    cells_to_find = ['5yr Avg', 'Upside', 'Central', 'Down 1', 'Down 2']
    found_cells = {key: [] for key in cells_to_find}

    for row in sheet.iter_rows():
        for cell in row:
            if cell.value in found_cells:
                found_cells[cell.value].append(cell)

    # Write 'Start to trough' and 'Peak to trough' after three and four rows from '5yr Avg'
    for cell in found_cells['5yr Avg']:
        sheet.cell(row=cell.row + 3, column=cell.column, value='Start to trough')
        sheet.cell(row=cell.row + 4, column=cell.column, value='Peak to trough')

    # Write 'Upside', 'Central', 'Down 1', 'Down 2' after 21 rows
    scenarios = ['Upside', 'Central', 'Down 1', 'Down 2']
    for scenario in scenarios:
        for cell in found_cells[scenario]:
            for i, sc in enumerate(scenarios):
                sheet.cell(row=cell.row + 21, column=cell.column, value=sc)
            if scenario in ['Central', 'Down 1', 'Down 2']:
                extra_values = ['3+4', '5+7', '2', '3', '5', '7', '7', '9']
                for i, val in enumerate(extra_values):
                    sheet.cell(row=cell.row + 22 + i, column=cell.column, value=val)

# Example usage
input_file = "your_excel_file.xlsx"
wb = load_workbook(input_file)
sheet = wb.active  # Adjust if you need a specific sheet

column_of_trough(sheet)

wb.save("your_modified_excel_file.xlsx")
















from openpyxl import load_workbook

def column_of_trough(sheet):
    # Helper function to find all cells with a specific value
    def find_cells(value):
        cells = []
        for row in sheet.iter_rows():
            for cell in row:
                if cell.value == value:
                    cells.append(cell)
        return cells

    # Find all occurrences of '5yr Avg'
    five_year_avg_cells = find_cells('5yr Avg')

    # Iterate over each '5yr Avg' cell and write the required values in appropriate locations
    for cell in five_year_avg_cells:
        row, col = cell.row, cell.column

        # Write 'Start to trough' and 'Peak to trough'
        sheet.cell(row=row + 3, column=col, value='Start to trough')
        sheet.cell(row=row + 4, column=col, value='Peak to trough')

        # Write scenarios in the next rows and specific columns
        scenarios = ['Upside', 'Central', 'Down 1', 'Down 2']
        offsets = [(2, 1), (2, 2), (2, 3), (2, 4), (2, 6), (2, 7), (2, 8), (2, 9)]

        for scenario, (r_offset, c_offset) in zip(scenarios * 2, offsets):
            sheet.cell(row=row + r_offset, column=col + c_offset, value=scenario)

        # Write numerical values in the appropriate locations
        num_values = [
            (3, 1, 44), (3, 2, 56), (3, 3, 76), (3, 4, 87),
            (4, 6, 77), (4, 7, 78), (4, 8, 89), (4, 9, 91)
        ]

        for r_offset, c_offset, value in num_values:
            sheet.cell(row=row + r_offset, column=col + c_offset, value=value)

# Example usage
input_file = "your_excel_file.xlsx"
wb = load_workbook(input_file)
sheet = wb.active  # Adjust if you need a specific sheet

column_of_trough(sheet)

wb.save("your_modified_excel_file.xlsx")



























from openpyxl import load_workbook

def column_of_trough(sheet):
    def find_cells(value):
        """Find all cells that match the provided value."""
        cells = []
        for row in sheet.iter_rows():
            for cell in row:
                if cell.value == value:
                    cells.append(cell)
        return cells

    # Find all occurrences of '5yr Avg'
    five_year_avg_cells = find_cells('5yr Avg')

    # Iterate over each '5yr Avg' cell and write the required values in appropriate locations
    for cell in five_year_avg_cells:
        row, col = cell.row, cell.column

        # Write 'Start to trough' and 'Peak to trough'
        sheet.cell(row=row + 3, column=col, value='Start to trough')
        sheet.cell(row=row + 4, column=col, value='Peak to trough')

        # Write scenarios in the next rows and specific columns
        scenarios_offsets = [
            (2, 1, 'Upside'), (2, 2, 'Central'), (2, 3, 'Down 1'), (2, 4, 'Down 2'),
            (2, 8, 'Upside'), (2, 9, 'Central'), (2, 10, 'Down 1'), (2, 11, 'Down 2')
        ]

        for r_offset, c_offset, text in scenarios_offsets:
            sheet.cell(row=row + r_offset, column=col + c_offset, value=text)

        # Write numerical values in the appropriate locations
        num_values_offsets = [
            (3, 1, 1), (3, 2, 2), (3, 3, 31), (3, 4, 42),
            (3, 8, 5), (3, 9, 6), (3, 10, 71), (3, 11, 82),
            (4, 1, 9), (4, 2, 10), (4, 3, 11), (4, 4, 12),
            (4, 8, 13), (4, 9, 14), (4, 10, 15), (4, 11, 16)
        ]

        for r_offset, c_offset, value in num_values_offsets:
            sheet.cell(row=row + r_offset, column=col + c_offset, value=value)

# Example usage
input_file = "your_excel_file.xlsx"
wb = load_workbook(input_file)
sheet = wb.active  # Adjust if you need a specific sheet

column_of_trough(sheet)

wb.save("your_modified_excel_file.xlsx")














from openpyxl import load_workbook
import pandas as pd

def column_of_trough(sheet):
    def find_cells(value):
        """Find all cells that match the provided value."""
        cells = []
        for row in sheet.iter_rows():
            for cell in row:
                if cell.value == value:
                    cells.append(cell)
        return cells

    workbook_path = "C:\\Users\\45363901\\PycharmProjects\\pythonProject\\pythonProject2\\GBIC_Workings Data\\Input\\Mapping File Copy.xlsx"
    df = pd.read_excel(workbook_path, sheet_name="Data_Edge")

    for row in sheet.iter_rows():
        for cell in row:
            checks_value = df.loc[(df['ISOCODES'] == sheet.title) & (df['Trough_required'] == 'Yes'), 'Checks'].tolist()
            for value in checks_value:
                if cell.value == value:
                    if cell.col_idx > 1:
                        target_cell = sheet.cell(row=cell.row + 21, column=cell.col_idx + 1)
                        if target_cell.value == '5yr Avg':
                            five_year_avg_cells = find_cells('5yr Avg')
                            # Iterate over each '5yr Avg' cell and write the required values in appropriate locations
                            for avg_cell in five_year_avg_cells:
                                row, col = avg_cell.row, avg_cell.column

                                # Write 'Start to trough' and 'Peak to trough'
                                sheet.cell(row=row + 3, column=col, value='Start to trough')
                                sheet.cell(row=row + 4, column=col, value='Peak to trough')

                                # Write scenarios in the next rows and specific columns
                                scenarios_offsets = [
                                    (2, 1, 'Upside'), (2, 2, 'Central'), (2, 3, 'Down 1'), (2, 4, 'Down 2'),
                                    (2, 8, 'Upside'), (2, 9, 'Central'), (2, 10, 'Down 1'), (2, 11, 'Down 2')
                                ]

                                for r_offset, c_offset, text in scenarios_offsets:
                                    sheet.cell(row=row + r_offset, column=col + c_offset, value=text)

                                # Write numerical values in the appropriate locations
                                num_values_offsets = [
                                    (3, 1, 1), (3, 2, 2), (3, 3, 31), (3, 4, 42),
                                    (3, 8, 5), (3, 9, 6), (3, 10, 71), (3, 11, 82),
                                    (4, 1, 9), (4, 2, 10), (4, 3, 11), (4, 4, 12),
                                    (4, 8, 13), (4, 9, 14), (4, 10, 15), (4, 11, 16)
                                ]

                                for r_offset, c_offset, value in num_values_offsets:
                                    sheet.cell(row=row + r_offset, column=col + c_offset, value=value)

# Example usage
input_file = "your_excel_file.xlsx"
wb = load_workbook(input_file)
sheet = wb.active  # Adjust if you need a specific sheet

column_of_trough(sheet)

wb.save("your_modified_excel_file.xlsx")

















from openpyxl.styles import Border, Side
import pandas as pd

def red_marking(sheet, user_inputs):
    thin_border = Border(
        left=Side(border_style='thin', color='FFFF0000'),
        right=Side(border_style='thin', color='FFFF0000'),
        top=Side(border_style='thin', color='FFFF0000'),
        bottom=Side(border_style='thin', color='FFFF0000')
    )

    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == 'IFRS9 1Q23 Scenarios':
                date_column = list(cell[0].value for cell in sheet.iter_rows(min_row=4, max_row=24, min_col=1, max_col=1))
                datetime_index = pd.to_datetime([date for date in date_column if date and date != ''], format='%m/%d/%Y', errors='coerce')
                formatted_dates = [date.strftime('%Y-%m-%d') if pd.notnull(date) else None for date in datetime_index]

                above_date, below_date = user_inputs
                above_date = pd.to_datetime(above_date, format='%Y-%m-%d', errors='coerce')
                below_date = pd.to_datetime(below_date, format='%Y-%m-%d', errors='coerce')

                above_row = None
                below_row = None

                for date in formatted_dates:
                    if date == above_date.strftime('%Y-%m-%d'):
                        above_row = formatted_dates.index(date) + 4  # Adjusted for min_row=4
                    if date == below_date.strftime('%Y-%m-%d'):
                        below_row = formatted_dates.index(date) + 4  # Adjusted for min_row=4

                if above_row and below_row:
                    for row in sheet.iter_rows(min_row=above_row, max_row=below_row, min_col=cell.column+1, max_col=cell.column+1):
                        for cell in row:
                            cell.border = thin_border

# Example usage
# user_inputs = ['2023-01-01', '2023-03-31']
# red_marking(sheet, user_inputs)



















from openpyxl.styles import Border, Side
import pandas as pd

def red_marking(sheet, user_inputs):
    thick_border = Border(
        left=Side(border_style='thick', color='FFFF0000'),
        right=Side(border_style='thick', color='FFFF0000'),
        top=Side(border_style='thick', color='FFFF0000'),
        bottom=Side(border_style='thick', color='FFFF0000')
    )

    # Find the cell containing 'IFRS9 1Q23 Scenarios'
    scenario_cell = None
    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == 'IFRS9 1Q23 Scenarios':
                scenario_cell = cell
                break
        if scenario_cell:
            break

    if not scenario_cell:
        print("Scenario cell not found")
        return

    date_column = list(cell[0].value for cell in sheet.iter_rows(min_row=4, max_row=24, min_col=1, max_col=1))
    datetime_index = pd.to_datetime([date for date in date_column if date and date != ''], format='%m/%d/%Y', errors='coerce')
    formatted_dates = [date.strftime('%Y-%m-%d') if pd.notnull(date) else None for date in datetime_index]

    above_date, below_date = user_inputs
    above_date = pd.to_datetime(above_date, format='%Y-%m-%d', errors='coerce')
    below_date = pd.to_datetime(below_date, format='%Y-%m-%d', errors='coerce')

    above_row = None
    below_row = None

    for i, date in enumerate(formatted_dates):
        if date == above_date.strftime('%Y-%m-%d'):
            above_row = i + 4  # Adjusted for min_row=4
        if date == below_date.strftime('%Y-%m-%d'):
            below_row = i + 4  # Adjusted for min_row=4

    if above_row is not None and below_row is not None:
        col = scenario_cell.column + 1  # The column after the 'IFRS9 1Q23 Scenarios' column
        for row in sheet.iter_rows(min_row=above_row, max_row=below_row):
            for cell in row:
                if cell.column == col:
                    if row[0].row == above_row:  # Top border
                        cell.border = Border(top=thick_border.top)
                    if row[0].row == below_row:  # Bottom border
                        cell.border = Border(bottom=thick_border.bottom)
                    if cell.column == col:  # Left and right borders
                        cell.border = Border(left=thick_border.left, right=thick_border.right)

                    # Add top and bottom borders to the left-most and right-most cells
                    if cell.column == col:
                        if row[0].row == above_row:
                            cell.border = Border(top=thick_border.top, left=thick_border.left)
                        if row[0].row == below_row:
                            cell.border = Border(bottom=thick_border.bottom, left=thick_border.left)
                        if cell.column == col:
                            cell.border = Border(right=thick_border.right)

# Example usage
# user_inputs = ['2023-01-01', '2023-03-31']
# red_marking(sheet, user_inputs)
























from openpyxl.styles import Border, Side
import pandas as pd

def red_marking(sheet, user_inputs):
    thick_border = Border(
        left=Side(border_style='thick', color='FFFF0000'),
        right=Side(border_style='thick', color='FFFF0000'),
        top=Side(border_style='thick', color='FFFF0000'),
        bottom=Side(border_style='thick', color='FFFF0000')
    )

    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == 'IFRS9 1Q23 Scenarios':
                date_column = [cell[0].value for cell in sheet.iter_rows(min_row=4, max_row=24, min_col=1, max_col=1)]
                datetime_index = pd.to_datetime([date for date in date_column if date and date != ''], format='%m/%d/%Y', errors='coerce')
                formatted_dates = [date.strftime('%Y-%m-%d') if pd.notnull(date) else None for date in datetime_index]
                above_date, below_date = user_inputs
                above_date = pd.to_datetime(above_date, format='%Y-%m-%d', errors='coerce')
                below_date = pd.to_datetime(below_date, format='%Y-%m-%d', errors='coerce')
                above_row = None
                below_row = None
                for date in formatted_dates:
                    if date == above_date.strftime('%Y-%m-%d'):
                        above_row = formatted_dates.index(date) + 4  # Adjusted for min_row=4
                    if date == below_date.strftime('%Y-%m-%d'):
                        below_row = formatted_dates.index(date) + 4  # Adjusted for min_row=4
                if above_row and below_row:
                    # Apply thick border to the top-left cell
                    sheet.cell(row=above_row, column=cell.column+1).border = thick_border

                    # Apply thick border to the top-right cell
                    sheet.cell(row=above_row, column=sheet.max_column).border = Border(
                        top=Side(border_style='thick', color='FFFF0000'),
                        right=Side(border_style='thick', color='FFFF0000')
                    )

                    # Apply thick border to the bottom-left cell
                    sheet.cell(row=below_row, column=cell.column+1).border = Border(
                        bottom=Side(border_style='thick', color='FFFF0000'),
                        left=Side(border_style='thick', color='FFFF0000')
                    )

                    # Apply thick border to the bottom-right cell
                    sheet.cell(row=below_row, column=sheet.max_column).border = Border(
                        bottom=Side(border_style='thick', color='FFFF0000'),
                        right=Side(border_style='thick', color='FFFF0000')
                    )

# Example usage
# user_inputs = ['2023-01-01', '2023-03-31']
# red_marking(sheet, user_inputs)














from openpyxl.styles import Border, Side
import pandas as pd

def red_marking(sheet, user_inputs):
    thick_border = Side(border_style='thick', color='FFFF0000')

    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == 'IFRS9 1Q23 Scenarios':
                date_column = [cell.value for cell in sheet.iter_rows(min_row=4, max_row=24, min_col=1, max_col=1)]
                datetime_index = pd.to_datetime([date for date in date_column if date and date != ''], format='%m/%d/%Y', errors='coerce')
                formatted_dates = [date.strftime('%Y-%m-%d') if pd.notnull(date) else None for date in datetime_index]

                above_date, below_date = user_inputs
                above_date = pd.to_datetime(above_date, format='%Y-%m-%d', errors='coerce')
                below_date = pd.to_datetime(below_date, format='%Y-%m-%d', errors='coerce')

                above_row = None
                below_row = None

                for i, date in enumerate(formatted_dates):
                    if date == above_date.strftime('%Y-%m-%d'):
                        above_row = i + 4  # Adjusted for min_row=4
                    if date == below_date.strftime('%Y-%m-%d'):
                        below_row = i + 4  # Adjusted for min_row=4

                if above_row is not None and below_row is not None:
                    col = scenario_cell.column + 1  # The column after the 'IFRS9 1Q23 Scenarios' column

                    # Apply top border
                    for cell in sheet.iter_rows(min_row=above_row, max_row=above_row, min_col=col, max_col=col):
                        cell[0].border = Border(top=thick_border, left=thick_border, right=thick_border)

                    # Apply bottom border
                    for cell in sheet.iter_rows(min_row=below_row, max_row=below_row, min_col=col, max_col=col):
                        cell[0].border = Border(bottom=thick_border, left=thick_border, right=thick_border)

                    # Apply left border
                    for row in sheet.iter_rows(min_row=above_row + 1, max_row=below_row - 1):
                        row[col - 1].border = Border(left=thick_border)

                    # Apply right border
                    for row in sheet.iter_rows(min_row=above_row + 1, max_row=below_row - 1):
                        row[col].border = Border(right=thick_border)

# Example usage
# user_inputs = ['2023-01-01', '2023-03-31']
# red_marking(sheet, user_inputs)
