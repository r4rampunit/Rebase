import openpyxl
from openpyxl.utils import get_column_letter

def Weighted_column_required(sheet):
    merged_ranges = list(sheet.merged_cells.ranges)
    columns_to_delete = []

    for merged_range in merged_ranges:
        if merged_range.max_col - merged_range.min_col == 4:  # IFRS9 1Q24 Scenarios merged cell
            # Find the 'Weighted' column
            weighted_col = merged_range.max_col
            down1_col = weighted_col - 1

            # Add these columns to the list to delete
            columns_to_delete.extend([weighted_col, down1_col])

    # Delete columns from right to left
    for col in sorted(set(columns_to_delete), reverse=True):
        sheet.delete_cols(col)

    # Adjust merged cells
    new_merged_ranges = []
    for merged_range in merged_ranges:
        new_min_col = merged_range.min_col
        new_max_col = merged_range.max_col

        # Adjust the range based on deleted columns
        for col in columns_to_delete:
            if merged_range.min_col < col <= merged_range.max_col:
                new_max_col -= 1
            elif col < merged_range.min_col:
                new_min_col -= 1
                new_max_col -= 1

        if new_min_col != new_max_col:
            new_range = openpyxl.worksheet.cell_range.CellRange(
                min_col=new_min_col,
                min_row=merged_range.min_row,
                max_col=new_max_col,
                max_row=merged_range.max_row
            )
            new_merged_ranges.append(new_range)

    # Clear all merges and set new ones
    sheet.merged_cells.ranges.clear()
    for new_range in new_merged_ranges:
        sheet.merge_cells(range_string=str(new_range))

    print("Processing complete.")

# Usage
workbook_path = r".\Input\Mapping_File Copy.xlsx"
workbook = openpyxl.load_workbook(workbook_path)
sheet = workbook['Sheet1']  # Replace 'Sheet1' with your actual sheet name
Weighted_column_required(sheet)
workbook.save(workbook_path)






import pandas as pd
import openpyxl
from openpyxl.utils import get_column_letter

def Weighted_column_required(sheet):
    workbook_path = r".\Input\Mapping_File Copy.xlsx"
    df = pd.read_excel(workbook_path, sheet_name="Data_Edge")

    merged_ranges = list(sheet.merged_cells.ranges)
    columns_to_delete = []

    for index, row in df.iterrows():
        description = row['Description']
        weighted_required = row['Weighted_required']

        for merged_range in merged_ranges:
            top_left_cell = sheet.cell(row=merged_range.min_row, column=merged_range.min_col)

            # Check if the cell is not empty before accessing its value
            if top_left_cell.data_type != 'n':
                top_left_cell_value = top_left_cell.value

                if top_left_cell_value == description:
                    if weighted_required.lower() == 'no':
                        if merged_range.max_col - merged_range.min_col == 4:  # IFRS9 1Q24 Scenarios merged cell
                            # Find the 'Weighted' column
                            weighted_col = merged_range.max_col
                            down1_col = weighted_col - 1

                            # Add these columns to the list to delete
                            columns_to_delete.extend([weighted_col, down1_col])

    # Delete columns from right to left
    for col in sorted(set(columns_to_delete), reverse=True):
        sheet.delete_cols(col)

    # Adjust merged cells
    new_merged_ranges = []
    for merged_range in merged_ranges:
        new_min_col = merged_range.min_col
        new_max_col = merged_range.max_col

        # Adjust the range based on deleted columns
        for col in columns_to_delete:
            if merged_range.min_col < col <= merged_range.max_col:
                new_max_col -= 1
            elif col < merged_range.min_col:
                new_min_col -= 1
                new_max_col -= 1

        if new_min_col != new_max_col:
            new_range = openpyxl.worksheet.cell_range.CellRange(
                min_col=new_min_col,
                min_row=merged_range.min_row,
                max_col=new_max_col,
                max_row=merged_range.max_row
            )
            new_merged_ranges.append(new_range)

    # Clear all merges and set new ones
    sheet.merged_cells.ranges.clear()
    for new_range in new_merged_ranges:
        sheet.merge_cells(range_string=str(new_range))

    print("Processing complete.")

# Usage
workbook_path = r".\Input\Mapping_File Copy.xlsx"
workbook = openpyxl.load_workbook(workbook_path)
sheet = workbook['Sheet1']  # Replace 'Sheet1' with your actual sheet name
Weighted_column_required(sheet)
workbook.save(workbook_path)






from openpyxl import load_workbook

def delete_4th_column_after_first_of_merged_cell(filename, sheet_name):
    # Load the workbook and select the sheet
    wb = load_workbook(filename)
    sheet = wb[sheet_name]

    # Store the columns to be deleted
    columns_to_delete = []

    # Identify and adjust merged cells
    for merged_cell in sheet.merged_cells.ranges:
        # Determine the 4th column after the first column of the merged cell
        col_idx = merged_cell.min_col + 3

        # If the 4th column is within the merged cell's range
        if col_idx in range(merged_cell.min_col, merged_cell.max_col + 1):
            if merged_cell.size[1] > 1:  # Check if the merged cell spans more than one column
                new_max_col = merged_cell.max_col - 1
                new_range = f"{merged_cell.coord.split(':')[0]}:{sheet.cell(row=merged_cell.max_row, column=new_max_col).coordinate}"  # Adjust the column span
                sheet.merged_cells.remove(merged_cell)
                sheet.merge_cells(new_range)
            else:
                sheet.merged_cells.remove(merged_cell)
            columns_to_delete.append(col_idx)

    # Delete the specified columns (reversed order to avoid index shift)
    for col_idx in sorted(columns_to_delete, reverse=True):
        sheet.delete_cols(col_idx)

    # Save the workbook
    wb.save(filename)

# Example usage:
filename = 'example.xlsx'
sheet_name = 'Sheet1'

delete_4th_column_after_first_of_merged_cell(filename, sheet_name)

















import itertools

projection_mappings = {
    "T1": ([4], [1, 2, 3, 4]),
    "T2": ([8], [5, 6, 7, 8]),
    "T3": ([12], [9, 10, 11, 12]),
    "T4": ([16], [13, 14, 15, 16]),
    "T5": ([20], [17, 18, 19, 20])
}

for x, col in itertools.product(listl, column_names):
    scenario = x[1]
    ST = x[0]
    print(ST)

    projection_period, projection_period_range = projection_mappings.get(col, ([0], [0]))

    filter_conditions = (
        (lic_df["Organisational unit level 1"].isin(Organisational_unit_level_1_selected)) &
        (lic_df["ST"] == ST) &
        (lic_df["Organisational unit level 2"].isin(Organisational_unit_level_2_selected)) &
        (lic_df["Organisational unit level 3"].isin(Organisational_unit_level_3_selected)) &
        (lic_df["Country of Exposure"].isin(Country_of_Exposure_selected)) &
        (lic_df["Asset class"].isin(Asset_class_selected)) &
        (lic_df["Product Type"].isin(Product_Type_selected)) &
        (lic_df["Basel_Approach"].isin(Basel_Approach_selected)) &
        (lic_df["scenario"] == scenario) &
        (lic_df["Projection Period"].isin(projection_period))
    )

    rwa_filter_conditions = (
        (rwa_df["Organisational unit level 1"].isin(Organisational_unit_level_1_selected)) &
        (rwa_df["ST"] == ST) &
        (rwa_df["Organisational unit level 2"].isin(Organisational_unit_level_2_selected)) &
        (rwa_df["Organisational unit level 3"].isin(Organisational_unit_level_3_selected)) &
        (rwa_df["Country of Exposure"].isin(Country_of_Exposure_selected)) &
        (rwa_df["Asset class"].isin(Asset_class_selected)) &
        (rwa_df["Product Type"].isin(Product_Type_selected)) &
        (rwa_df["Basel_Approach"].isin(Basel_Approach_selected)) &
        (rwa_df["scenario"] == scenario) &
        (rwa_df["Projection Period"] == 0)
    )

    net_balance = lic_df[filter_conditions]["Balance"].sum()
    table_df1.loc["Net Balance ($ MM)", col] = round(net_balance / 1000000, 2)

    gross_balance = net_balance + lic_df[filter_conditions]["Comm Gross WO"].sum()
    table_df1.loc["Gross Balance ($ MM)", col] = round(gross_balance / 1000000, 2)

    for stage in [1, 2, 3]:
        stage_balance = lic_df[filter_conditions & (lic_df["IFRS9 Stage"] == stage)]["Balance"].sum()
        proportion = (stage_balance / net_balance) * 100 if net_balance != 0 else 0
        table_df1.loc[f"Net Balance Proportion S{stage}", col] = f"{proportion:.2f}%"

    provisions = lic_df[filter_conditions]["Provisions"].sum()
    table_df1.loc["ECL ($ MM)", col] = round(provisions / 1000000, 2)

    provisions_orig = lic_df[filter_conditions]["Provisions orig"].sum()
    table_df1.loc["ECL Original ($ MM)", col] = round(provisions_orig / 1000000, 2)

    ecl_rate = (provisions / net_balance) * 100 if net_balance != 0 else 0
    table_df1.loc["ECL Rate", col] = f"{ecl_rate:.2f}%"

    loss_at_wo = lic_df[filter_conditions & (lic_df["Projection_Period"].isin(projection_period_range))]["Loss_at_WO"].sum()
    table_df1.loc["Loss at WO ($ MM)", col] = round(loss_at_wo / 1000000, 2)

    loss_at_wo_orig = lic_df[filter_conditions & (lic_df["Projection_Period"].isin(projection_period_range))]["Loss_at_WO_orig"].sum()
    table_df1.loc["Loss at WO Original ($ MM)", col] = round(loss_at_wo_orig / 1000000, 2)

    lic = lic_df[filter_conditions & (lic_df["Projection_Period"].isin(projection_period_range))]["LIC"].sum()
    table_df1.loc["LIC ($ MM)", col] = round(lic / 1000000, 2)

    lic_orig = lic_df[filter_conditions & (lic_df["Projection_Period"].isin(projection_period_range))]["LIC_orig"].sum()
    table_df1.loc["LIC Original ($ MM)", col] = round(lic_orig / 1000000, 2)

    table_df1.loc["LIC overlay ($ MM)", col] = table_df1.loc["LIC ($ MM)", col] - table_df1.loc["LIC Original ($ MM)", col]

    lic_rate = (lic / net_balance) * 100 if net_balance != 0 else 0
    table_df1.loc["LIC Rate", col] = f"{lic_rate:.2f}%"

    ead = rwa_df[rwa_filter_conditions]["Exposure_for_RWA"].sum()
    table_df1.loc["EAD ($ MM)", col] = round(ead / 1000000, 2)

    rwa = rwa_df[rwa_filter_conditions]["RWA"].sum()
    table_df1.loc["RWA ($ MM)", col] = round(rwa / 1000000, 2)

    rwa_orig = rwa_df[rwa_filter_conditions]["RWA_Orig"].sum()
    table_df1.loc["RWA Original ($ MM)", col] = round(rwa_orig / 1000000, 2)

    table_df1.loc["RWA Overlay ($ MM)", col] = round(table_df1.loc["RWA ($ MM)", col] - table_df1.loc["RWA Original ($ MM)", col], 2)

    rwa_density = (rwa / ead) * 100 if ead != 0 else 0
    table_df1.loc["RWA Density", col] = f"{rwa_density:.2f}%"

    el = rwa_df[rwa_filter_conditions]["Expected_Loss_Regulatory"].sum()
    table_df1.loc["EL ($ MM)", col] = round(el / 1000000, 2)

    el_orig = rwa_df[rwa_filter_conditions]["Expected_Loss_Regulatory_Orig"].sum()
    table_df1.loc["EL Overlay ($ MM)", col] = round((el - el_orig) / 1000000, 2)

    el_density = (el / ead) * 100 if ead != 0 else 0
    table_df1.loc["EL Density", col] = f"{el_density:.2f}%"

table_df = pd.concat([table_df, table_df1], axis=1)
table_html = table_df.to_html(classes="table table-striped table-bordered", index=True)
return JsonResponse({'table_html': table_html})





weighted_required = input_mapping_df.loc[input_mapping_df["trans variable"] == col, "weighted_required"].values[0]
            if weighted_required == "Ne":
                df.drop(columns=[col, f"{col}, Weighted"], inplace=True)

















import itertools

projection_mappings = {
    "T1": ([4], [1, 2, 3, 4]),
    "T2": ([8], [5, 6, 7, 8]),
    "T3": ([12], [9, 10, 11, 12]),
    "T4": ([16], [13, 14, 15, 16]),
    "T5": ([20], [17, 18, 19, 20])
}

for x, col in itertools.product(listl, column_names):
    scenario = x[1]
    ST = x[0]
    print(ST)

    projection_period, projection_period_range = projection_mappings.get(col, ([0], [0]))

    filter_conditions = (
        (lic_df["Organisational unit level 1"].isin(Organisational_unit_level_1_selected)) &
        (lic_df["ST"] == ST) &
        (lic_df["Organisational unit level 2"].isin(Organisational_unit_level_2_selected)) &
        (lic_df["Organisational unit level 3"].isin(Organisational_unit_level_3_selected)) &
        (lic_df["Country of Exposure"].isin(Country_of_Exposure_selected)) &
        (lic_df["Asset class"].isin(Asset_class_selected)) &
        (lic_df["Product Type"].isin(Product_Type_selected)) &
        (lic_df["Basel_Approach"].isin(Basel_Approach_selected)) &
        (lic_df["scenario"] == scenario) &
        (lic_df["Projection Period"].isin(projection_period))
    )

    rwa_filter_conditions = (
        (rwa_df["Organisational unit level 1"].isin(Organisational_unit_level_1_selected)) &
        (rwa_df["ST"] == ST) &
        (rwa_df["Organisational unit level 2"].isin(Organisational_unit_level_2_selected)) &
        (rwa_df["Organisational unit level 3"].isin(Organisational_unit_level_3_selected)) &
        (rwa_df["Country of Exposure"].isin(Country_of_Exposure_selected)) &
        (rwa_df["Asset class"].isin(Asset_class_selected)) &
        (rwa_df["Product Type"].isin(Product_Type_selected)) &
        (rwa_df["Basel_Approach"].isin(Basel_Approach_selected)) &
        (rwa_df["scenario"] == scenario) &
        (rwa_df["Projection Period"] == 0)
    )

    net_balance = lic_df[filter_conditions]["Balance"].sum()
    table_df1.loc["Net Balance ($ MM)", col] = round(net_balance / 1000000, 2)

    gross_balance = net_balance + lic_df[filter_conditions]["Comm Gross WO"].sum()
    table_df1.loc["Gross Balance ($ MM)", col] = round(gross_balance / 1000000, 2)

    for stage in [1, 2, 3]:
        stage_balance = lic_df[filter_conditions & (lic_df["IFRS9 Stage"] == stage)]["Balance"].sum()
        proportion = (stage_balance / net_balance) * 100 if net_balance != 0 else 0
        table_df1.loc[f"Net Balance Proportion S{stage}", col] = f"{proportion:.2f}%"

    provisions = lic_df[filter_conditions]["Provisions"].sum()
    table_df1.loc["ECL ($ MM)", col] = round(provisions / 1000000, 2)

    provisions_orig = lic_df[filter_conditions]["Provisions orig"].sum()
    table_df1.loc["ECL Original ($ MM)", col] = round(provisions_orig / 1000000, 2)

    ecl_rate = (provisions / net_balance) * 100 if net_balance != 0 else 0
    table_df1.loc["ECL Rate", col] = f"{ecl_rate:.2f}%"

    loss_at_wo = lic_df[filter_conditions & (lic_df["Projection_Period"].isin(projection_period_range))]["Loss_at_WO"].sum()
    table_df1.loc["Loss at WO ($ MM)", col] = round(loss_at_wo / 1000000, 2)

    loss_at_wo_orig = lic_df[filter_conditions & (lic_df["Projection_Period"].isin(projection_period_range))]["Loss_at_WO_orig"].sum()
    table_df1.loc["Loss at WO Original ($ MM)", col] = round(loss_at_wo_orig / 1000000, 2)

    lic = lic_df[filter_conditions & (lic_df["Projection_Period"].isin(projection_period_range))]["LIC"].sum()
    table_df1.loc["LIC ($ MM)", col] = round(lic / 1000000, 2)

    lic_orig = lic_df[filter_conditions & (lic_df["Projection_Period"].isin(projection_period_range))]["LIC_orig"].sum()
    table_df1.loc["LIC Original ($ MM)", col] = round(lic_orig / 1000000, 2)

    table_df1.loc["LIC overlay ($ MM)", col] = table_df1.loc["LIC ($ MM)", col] - table_df1.loc["LIC Original ($ MM)", col]

    lic_rate = (lic / net_balance) * 100 if net_balance != 0 else 0
    table_df1.loc["LIC Rate", col] = f"{lic_rate:.2f}%"

    ead = rwa_df[rwa_filter_conditions]["Exposure_for_RWA"].sum()
    table_df1.loc["EAD ($ MM)", col] = round(ead / 1000000, 2)

    rwa = rwa_df[rwa_filter_conditions]["RWA"].sum()
    table_df1.loc["RWA ($ MM)", col] = round(rwa / 1000000, 2)

    rwa_orig = rwa_df[rwa_filter_conditions]["RWA_Orig"].sum()
    table_df1.loc["RWA Original ($ MM)", col] = round(rwa_orig / 1000000, 2)

    table_df1.loc["RWA Overlay ($ MM)", col] = round(table_df1.loc["RWA ($ MM)", col] - table_df1.loc["RWA Original ($ MM)", col], 2)

    rwa_density = (rwa / ead) * 100 if ead != 0 else 0
    table_df1.loc["RWA Density", col] = f"{rwa_density:.2f}%"

    el = rwa_df[rwa_filter_conditions]["Expected_Loss_Regulatory"].sum()
    table_df1.loc["EL ($ MM)", col] = round(el / 1000000, 2)

    el_orig = rwa_df[rwa_filter_conditions]["Expected_Loss_Regulatory_Orig"].sum()
    table_df1.loc["EL Overlay ($ MM)", col] = round((el - el_orig) / 1000000, 2)

    el_density = (el / ead) * 100 if ead != 0 else 0
    table_df1.loc["EL Density", col] = f"{el_density:.2f}%"

table_df = pd.concat([table_df, table_df1], axis=1)
table_html = table_df.to_html(classes="table table-striped table-bordered", index=True)
return JsonResponse({'table_html': table_html})



def view_function(request):
    folders = get_folders()
    selected_folder = request.GET.get("folder") or None
    selected_subfolder = request.GET.get("subfolder") or None

    subfolders = get_subfolders(selected_folder) if selected_folder else []

    folder_path = os.path.join(FOLDER_PATH, selected_folder or '', selected_subfolder or '')
    excel_files = [f for f in os.listdir(folder_path) if f.endswith('.xlsx')] if (selected_folder and selected_subfolder) else []

    # Rest of your view logic here

    return render(request, 'your_template.html', {
        'folders': folders,
        'subfolders': subfolders,
        'selected_folder': selected_folder,
        'selected_subfolder': selected_subfolder,
        'excel_files': excel_files,
        # Other context variables
    })







def read_excel_files(folder_path, excel_files):
    file_paths = {excel_file: os.path.join(folder_path, excel_file) for excel_file in excel_files}

    return {
        'lic_hbap_first_run': pd.read_excel(file_paths[next((f for f in excel_files if all(s in f for s in ["LIC", "HBAP", "FirstRun"])), '')], sheet_name="LPACT_OL_YTD_QTR_Final") if any(all(s in f for s in ["LIC", "HBAP", "FirstRun"]) for f in excel_files) else None,
        'lic_hbap_last_run': pd.read_excel(file_paths[next((f for f in excel_files if all(s in f for s in ["LIC", "HBAP", "LastRun"])), '')], sheet_name="LPACT_OL_YTD_QTR_Final") if any(all(s in f for s in ["LIC", "HBAP", "LastRun"]) for f in excel_files) else None,
        'lpact_hbap_data': pd.read_excel(file_paths[next((f for f in excel_files if all(s in f for s in ["LPACT", "HBAP"])), '')], sheet_name="PD_series") if any(all(s in f for s in ["LPACT", "HBAP"]) for f in excel_files) else None,
        'lic_non_hbap_first_run': pd.read_excel(file_paths[next((f for f in excel_files if all(s in f for s in ["LIC", "NonHBAP", "FirstRun"])), '')], sheet_name="LPACT_OL_YTD_QTR_Final") if any(all(s in f for s in ["LIC", "NonHBAP", "FirstRun"]) for f in excel_files) else None,
        'lic_non_hbap_last_run': pd.read_excel(file_paths[next((f for f in excel_files if all(s in f for s in ["LIC", "NonHBAP", "LastRun"])), '')], sheet_name="LPACT_OL_YTD_QTR_Final") if any(all(s in f for s in ["LIC", "NonHBAP", "LastRun"]) for f in excel_files) else None,
        'lpact_non_hbap_data': pd.read_excel(file_paths[next((f for f in excel_files if all(s in f for s in ["LPACT", "Non", "HBAP"])), '')], sheet_name="PD_series") if any(all(s in f for s in ["LPACT", "Non", "HBAP"]) for f in excel_files) else None,
        'rwa_hbap_first_run': pd.read_excel(file_paths[next((f for f in excel_files if all(s in f for s in ["MI", "HBAP", "FirstRun"])), '')], sheet_name="Temp_RRM_Final_OL") if any(all(s in f for s in ["MI", "HBAP", "FirstRun"]) for f in excel_files) else None,
        'rwa_hbap_last_run': pd.read_excel(file_paths[next((f for f in excel_files if all(s in f for s in ["MI", "HBAP", "LastRun"])), '')], sheet_name="Temp_RRM_Final_OL") if any(all(s in f for s in ["MI", "HBAP", "LastRun"]) for f in excel_files) else None,
        'rwa_non_hbap_first_run': pd.read_excel(file_paths[next((f for f in excel_files if all(s in f for s in ["MI", "Non", "HBAP", "FirstRun"])), '')], sheet_name="Temp_RRM_Final_OL") if any(all(s in f for s in ["MI", "Non", "HBAP", "FirstRun"]) for f in excel_files) else None,
        'rwa_non_hbap_last_run': pd.read_excel(file_paths[next((f for f in excel_files if all(s in f for s in ["MI", "Non", "HBAP", "LastRun"])), '')], sheet_name="Temp_RRM_Final_OL") if any(all(s in f for s in ["MI", "Non", "HBAP", "LastRun"]) for f in excel_files) else None,
        'lic_views_previous': pd.read_excel(file_paths[next((f for f in excel_files if all(s in f for s in ["LIC", "Previous"])), '')], sheet_name="LIC_raw1") if any(all(s in f for s in ["LIC", "Previous"]) for f in excel_files) else None,
        'rwa_views_previous': pd.read_excel(file_paths[next((f for f in excel_files if all(s in f for s in ["RWA", "Previous"])), '')], sheet_name="RWA_raw1") if any(all(s in f for s in ["RWA", "Previous"]) for f in excel_files) else None,
    }




file_paths = {excel_file: os.path.join(folder_path, excel_file) for excel_file in excel_files}

lic_hbap_first_run = pd.read_excel(file_paths[next((f for f in excel_files if all(s in f for s in ["LIC", "HBAP", "FirstRun"])), '')], sheet_name="LPACT_OL_YTD_QTR_Final") if any(all(s in f for s in ["LIC", "HBAP", "FirstRun"]) for f in excel_files) else pd.DataFrame()

lic_hbap_last_run = pd.read_excel(file_paths[next((f for f in excel_files if all(s in f for s in ["LIC", "HBAP", "LastRun"])), '')], sheet_name="LPACT_OL_YTD_QTR_Final") if any(all(s in f for s in ["LIC", "HBAP", "LastRun"]) for f in excel_files) else pd.DataFrame()

lpact_hbap_data = pd.read_excel(file_paths[next((f for f in excel_files if all(s in f for s in ["LPACT", "HBAP"])), '')], sheet_name="PD_series") if any(all(s in f for s in ["LPACT", "HBAP"]) for f in excel_files) else pd.DataFrame()

lic_non_hbap_first_run = pd.read_excel(file_paths[next((f for f in excel_files if all(s in f for s in ["LIC", "NonHBAP", "FirstRun"])), '')], sheet_name="LPACT_OL_YTD_QTR_Final") if any(all(s in f for s in ["LIC", "NonHBAP", "FirstRun"]) for f in excel_files) else pd.DataFrame()

lic_non_hbap_last_run = pd.read_excel(file_paths[next((f for f in excel_files if all(s in f for s in ["LIC", "NonHBAP", "LastRun"])), '')], sheet_name="LPACT_OL_YTD_QTR_Final") if any(all(s in f for s in ["LIC", "NonHBAP", "LastRun"]) for f in excel_files) else pd.DataFrame()

lpact_non_hbap_data = pd.read_excel(file_paths[next((f for f in excel_files if all(s in f for s in ["LPACT", "Non", "HBAP"])), '')], sheet_name="PD_series") if any(all(s in f for s in ["LPACT", "Non", "HBAP"]) for f in excel_files) else pd.DataFrame()

rwa_hbap_first_run = pd.read_excel(file_paths[next((f for f in excel_files if all(s in f for s in ["MI", "HBAP", "FirstRun"])), '')], sheet_name="Temp_RRM_Final_OL") if any(all(s in f for s in ["MI", "HBAP", "FirstRun"]) for f in excel_files) else pd.DataFrame()

rwa_hbap_last_run = pd.read_excel(file_paths[next((f for f in excel_files if all(s in f for s in ["MI", "HBAP", "LastRun"])), '')], sheet_name="Temp_RRM_Final_OL") if any(all(s in f for s in ["MI", "HBAP", "LastRun"]) for f in excel_files) else pd.DataFrame()

rwa_non_hbap_first_run = pd.read_excel(file_paths[next((f for f in excel_files if all(s in f for s in ["MI", "Non", "HBAP", "FirstRun"])), '')], sheet_name="Temp_RRM_Final_OL") if any(all(s in f for s in ["MI", "Non", "HBAP", "FirstRun"]) for f in excel_files) else pd.DataFrame()

rwa_non_hbap_last_run = pd.read_excel(file_paths[next((f for f in excel_files if all(s in f for s in ["MI", "Non", "HBAP", "LastRun"])), '')], sheet_name="Temp_RRM_Final_OL") if any(all(s in f for s in ["MI", "Non", "HBAP", "LastRun"]) for f in excel_files) else pd.DataFrame()

lic_views_previous = pd.read_excel(file_paths[next((f for f in excel_files if all(s in f for s in ["LIC", "Previous"])), '')], sheet_name="LIC_raw1") if any(all(s in f for s in ["LIC", "Previous"]) for f in excel_files) else pd.DataFrame()

rwa_views_previous = pd.read_excel(file_paths[next((f for f in excel_files if all(s in f for s in ["RWA", "Previous"])), '')], sheet_name="RWA_raw1") if any(all(s in f for s in ["RWA", "Previous"]) for f in excel_files) else pd.DataFrame()






















def view_function(request):
    folders = get_folders()
    selected_folder = request.GET.get("folder") or None
    selected_subfolder = request.GET.get("subfolder") or None

    subfolders = get_subfolders(selected_folder) if selected_folder else []

    folder_path = os.path.join(FOLDER_PATH, selected_folder or '', selected_subfolder or '')
    excel_files = [f for f in os.listdir(folder_path) if f.endswith('.xlsx')] if (selected_folder and selected_subfolder) else []

    # Rest of your view logic here

    return render(request, 'your_template.html', {
        'folders': folders,
        'subfolders': subfolders,
        'selected_folder': selected_folder,
        'selected_subfolder': selected_subfolder,
        'excel_files': excel_files,
        # Other context variables
    })







# Calculate net balance
table_df1.loc["Net Balance (SMM)", col] = round(net_balance / 1000000)

# Calculate gross balance
gross_balance = net_balance + lic_df[
    (lic_df["Organisational_unit_level_1"].isin(Organisational_unit_level_1_selected)) &
    (lic_df["Organisational_unit_level_2"].isin(Organisational_unit_level_2_selected)) &
    (lic_df["ST"] == ST) &
    (lic_df["Organisational_unit_level_3"].isin(Organisational_unit_level_3_selected)) &
    (lic_df["Country_of_Exposure"].isin(Country_of_Exposure_selected)) &
    (lic_df["Asset_class"].isin(Asset_class_selected)) &
    (lic_df["Product_Type"].isin(Product_Type_selected)) &
    (lic_df["Basel_Approach"].isin(Basel_Approach_selected)) &
    (lic_df["scenario"] == scenario) &
    (lic_df["Projection_Period"].isin(Projection_Period))
]["Cumm_Gross_WO"].sum()

table_df1.loc["Gross Balance ($ MM)", col] = round(gross_balance / 1000000)

# Calculate net balance proportions for different stages
for stage in [1, 2, 3]:
    proportion = lic_df[
        (lic_df["Organisational_unit_level_1"].isin(Organisational_unit_level_1_selected)) &
        (lic_df["ST"] == ST) &
        (lic_df["Organisational_unit_level_2"].isin(Organisational_unit_level_2_selected)) &
        (lic_df["Organisational_unit_level_3"].isin(Organisational_unit_level_3_selected)) &
        (lic_df["Country_of_Exposure"].isin(Country_of_Exposure_selected)) &
        (lic_df["Asset_class"].isin(Asset_class_selected)) &
        (lic_df["Product_Type"].isin(Product_Type_selected)) &
        (lic_df["Basel_Approach"].isin(Basel_Approach_selected)) &
        (lic_df["scenario"] == scenario) &
        (lic_df["Projection_Period"].isin(Projection_Period)) &
        (lic_df["IFRS9_Stage"] == stage)
    ]["Balance"].sum() / net_balance

    table_df1.loc[f"Net Balance Proportion ${stage}", col] = f"{round(proportion * 100, 2)}%"

# Calculate provisions
provisions = lic_df[
    (lic_df["Organisational_unit_level_1"].isin(Organisational_unit_level_1_selected)) &
    (lic_df["ST"] == ST) &
    (lic_df["Organisational_unit_level_2"].isin(Organisational_unit_level_2_selected)) &
    (lic_df["Organisational_unit_level_3"].isin(Organisational_unit_level_3_selected)) &
    (lic_df["Country_of_Exposure"].isin(Country_of_Exposure_selected)) &
    (lic_df["Asset_class"].isin(Asset_class_selected)) &
    (lic_df["Product_Type"].isin(Product_Type_selected)) &
    (lic_df["Basel_Approach"].isin(Basel_Approach_selected)) &
    (lic_df["scenario"] == scenario) &
    (lic_df["Projection_Period"].isin(Projection_Period)) &
    (lic_df["IFRS9_Stage"] == 3)
]["Provisions"].sum()

table_df1.loc["ECL ($ MM)", col] = round(provisions / 1000000)

# Calculate original provisions
provisions_orig = lic_df[
    (lic_df["Organisational_unit_level_1"].isin(Organisational_unit_level_1_selected)) &
    (lic_df["ST"] == ST) &
    (lic_df["Organisational_unit_level_2"].isin(Organisational_unit_level_2_selected)) &
    (lic_df["Organisational_unit_level_3"].isin(Organisational_unit_level_3_selected)) &
    (lic_df["Country_of_Exposure"].isin(Country_of_Exposure_selected)) &
    (lic_df["Asset_class"].isin(Asset_class_selected)) &
    (lic_df["Product_Type"].isin(Product_Type_selected)) &
    (lic_df["Basel_Approach"].isin(Basel_Approach_selected)) &
    (lic_df["scenario"] == scenario) &
    (lic_df["Projection_Period"].isin(Projection_Period))
]["Provisions_orig"].sum()

table_df1.loc["ECL Original ($ MM)", col] = round(provisions_orig / 1000000)

# Calculate ECL rate
table_df1.loc["ECL Rate", col] = f"{round((provisions / net_balance) * 100, 2)}%"

# Calculate Loss at WO
loss_at_wo = lic_df[
    (lic_df["Organisational_unit_level_1"].isin(Organisational_unit_level_1_selected)) &
    (lic_df["ST"] == ST) &
    (lic_df["Organisational_unit_level_2"].isin(Organisational_unit_level_2_selected)) &
    (lic_df["Organisational_unit_level_3"].isin(Organisational_unit_level_3_selected)) &
    (lic_df["Country_of_Exposure"].isin(Country_of_Exposure_selected)) &
    (lic_df["Asset_class"].isin(Asset_class_selected)) &
    (lic_df["Product_Type"].isin(Product_Type_selected)) &
    (lic_df["Basel_Approach"].isin(Basel_Approach_selected)) &
    (lic_df["scenario"] == scenario) &
    (lic_df["Projection_Period"].isin(projection_period_range))
]["Loss_at_WO"].sum()

table_df1.loc["Loss at WO ($ MM)", col] = round(loss_at_wo / 1000000)

# Calculate original Loss at WO
loss_at_wo_orig = lic_df[
    (lic_df["Organisational_unit_level_1"].isin(Organisational_unit_level_1_selected)) &
    (lic_df["ST"] == ST) &
    (lic_df["Organisational_unit_level_2"].isin(Organisational_unit_level_2_selected)) &
    (lic_df["Organisational_unit_level_3"].isin(Organisational_unit_level_3_selected)) &
    (lic_df["Country_of_Exposure"].isin(Country_of_Exposure_selected)) &
    (lic_df["Asset_class"].isin(Asset_class_selected)) &
    (lic_df["Product_Type"].isin(Product_Type_selected)) &
    (lic_df["Basel_Approach"].isin(Basel_Approach_selected)) &
    (lic_df["scenario"] == scenario) &
    (lic_df["Projection_Period"].isin(projection_period_range))
]["Loss_at_WO_orig"].sum()

table_df1.loc["Loss at WO Original ($ MM)", col] = round(loss_at_wo_orig / 1000000)

# Calculate LIC
lic = lic_df[
    (lic_df["Organisational_unit_level_1"].isin(Organisational_unit_level_1_selected)) &
    (lic_df["ST"] == ST) &
    (lic_df["Organisational_unit_level_2"].isin(Organisational_unit_level_2_selected)) &
    (lic_df["Organisational_unit_level_3"].isin(Organisational_unit_level_3_selected)) &
    (lic_df["Country_of_Exposure"].isin(Country_of_Exposure_selected)) &
    (lic_df["Asset_class"].isin(Asset_class_selected)) &
    (lic_df["Product_Type"].isin(Product_Type_selected)) &
    (lic_df["Basel_Approach"].isin(Basel_Approach_selected)) &
    (lic_df["scenario"] == scenario) &
    (lic_df["Projection_Period"].isin(projection_period_range))
]["LIC"].sum()

table_df1.loc["LIC ($ MM)", col] = round(lic / 1000000)

# Calculate original LIC
lic_orig = lic_df[
    (lic_df["Organisational_unit_level_1"].isin(Organisational_unit_level_1_selected)) &
    (lic_df["ST"] == ST) &
    (lic_df["Organisational_unit_level_2"].isin(Organisational_unit_level_2_selected)) &
    (lic_df["Organisational_unit_level_3"].isin(Organisational_unit_level_3_selected)) &
    (lic_df["Country_of_Exposure"].isin(Country_of_Exposure_selected)) &
    (lic_df["Asset_class"].isin(Asset_class_selected)) &
    (lic_df["Product_Type"].isin(Product_Type_selected)) &
    (lic_df["Basel_Approach"].isin(Basel_Approach_selected)) &
    (lic_df["scenario"] == scenario) &
    (lic_df["Projection_Period"].isin(projection_period_range))
]["LIC_orig"].sum()

table_df1.loc["LIC Original ($ MM)", col] = round(lic_orig / 1000000)





scenario, ST = zip(*[st.split('-') for st in ST_scenario_selected])














{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MI Chart</title>
    <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>
</head>
<body>
    <div class="container mt-5">
        <h1>MI Chart</h1>
        <form id="dropdown-form">
            {% csrf_token %}
            {% for dropdown_name, options in dropdowns.items %}
            <div class="mb-3">
                <label for="{{ dropdown_name }}" class="form-label">{{ dropdown_name|title }}</label>
                <select class="form-select select2" name="{{ dropdown_name }}" id="{{ dropdown_name }}" multiple>
                    {% for option in options %}
                    <option value="{{ option }}">{{ option }}</option>
                    {% endfor %}
                </select>
            </div>
            {% endfor %}
        </form>

        <h2 class="mt-5">Data Table</h2>
        <div id="table-container">
            {{ initial_table_html|safe }}
        </div>
    </div>

    <script>
        $(document).ready(function() {
            $('.select2').select2();

            function updateTable() {
                $.ajax({
                    url: '{% url "mi_chart" %}',
                    type: 'POST',
                    data: $('#dropdown-form').serialize(),
                    success: function(response) {
                        $('#table-container').html(response.table_html);
                    }
                });
            }

            $('.select2').on('change', updateTable);
        });
    </script>
</body>
</html>










import pandas as pd
from openpyxl import Workbook

# Read the Excel file
workbook_path = r".\Input\Mapping_File Copy.xlsx"
Table_List = pd.read_excel(workbook_path, sheet_name="Table_List")
Data_Edge_1 = pd.read_excel(workbook_path, sheet_name="Data_Edge")
country_list = list(Data_Edge_1["ISOCODES"].unique())

# Create a new workbook
wb = Workbook()
wb.save(user_inputs[19])

def should_keep_column(col, df):
    for _, row in df.iterrows():
        if row['Trans_variable'] == col[0]:
            return row['Weighted_required'] != 'No'
    return True

for Isocode in country_list:
    col_list = (Table_List["MEV"].loc[Table_List.Country == Isocode]).tolist()

    with pd.ExcelWriter(user_inputs[19], engine='openpyxl', mode="a", if_sheet_exists="overlay") as writer:
        start_row = 1
        start_col = 1

        for col in col_list:
            table = construct_and_populate_tables(Isocode, tzero_date, col).round(1)

            # Filter columns based on Data_Edge sheet
            df = pd.read_excel(workbook_path, sheet_name="Data_Edge")
            current_columns = table.columns
            new_columns = [col for col in current_columns if should_keep_column(col, df)]

            # Remove 'Weighted' column and the column before it
            weighted_index = next((i for i, col in enumerate(new_columns) if 'Weighted' in col), None)
            if weighted_index is not None and weighted_index > 0:
                new_columns = new_columns[:weighted_index-1] + new_columns[weighted_index+1:]

            table = table[new_columns]

            # Write the table to Excel
            table.to_excel(writer, sheet_name=Isocode, startrow=start_row, startcol=start_col, index=True)
            print(table.columns)

            # Adjust the worksheet properties
            worksheet = writer.sheets[Isocode]
            worksheet.sheet_view.showGridLines = False

print("Process completed successfully.")












import pandas as pd
from openpyxl import Workbook

# Read the Excel file
workbook_path = r".\Input\Mapping_File Copy.xlsx"
Table_List = pd.read_excel(workbook_path, sheet_name="Table_List")
Data_Edge_1 = pd.read_excel(workbook_path, sheet_name="Data_Edge")
country_list = list(Data_Edge_1["ISOCODES"].unique())

# Create a new workbook
wb = Workbook()
wb.save(user_inputs[19])

def remove_weighted_and_preceding(columns):
    new_columns = []
    skip_next = False
    for i, col in enumerate(columns):
        if skip_next:
            skip_next = False
            continue
        if 'Weighted' in col[-1]:
            if i > 0:
                new_columns.pop()  # Remove the preceding column
            skip_next = True  # Skip the Weighted column
        else:
            new_columns.append(col)
    return new_columns

for Isocode in country_list:
    col_list = (Table_List["MEV"].loc[Table_List.Country == Isocode]).tolist()

    with pd.ExcelWriter(user_inputs[19], engine='openpyxl', mode="a", if_sheet_exists="overlay") as writer:
        start_row = 1
        start_col = 1

        for col in col_list:
            table = construct_and_populate_tables(Isocode, tzero_date, col).round(1)

            # Remove 'Weighted' columns and the columns before them
            new_columns = remove_weighted_and_preceding(table.columns)

            table = table[new_columns]

            # Write the table to Excel
            table.to_excel(writer, sheet_name=Isocode, startrow=start_row, startcol=start_col, index=True)
            print(table.columns)

            # Adjust the worksheet properties
            worksheet = writer.sheets[Isocode]
            worksheet.sheet_view.showGridLines = False

print("Process completed successfully.")






import pandas as pd
from openpyxl import Workbook

# Read the Excel file
workbook_path = r".\Input\Mapping_File Copy.xlsx"
Table_List = pd.read_excel(workbook_path, sheet_name="Table_List")
Data_Edge_1 = pd.read_excel(workbook_path, sheet_name="Data_Edge")
country_list = list(Data_Edge_1["ISOCODES"].unique())

# Create a new workbook
wb = Workbook()
wb.save(user_inputs[19])

def process_columns(columns, df):
    new_columns = []
    scenario_groups = {}

    for col in columns:
        scenario = col[1]
        if scenario not in scenario_groups:
            scenario_groups[scenario] = []
        scenario_groups[scenario].append(col)

    for scenario, cols in scenario_groups.items():
        new_columns.extend(cols)
        if scenario != "Moody's":
            new_columns.append((cols[0][0], ' ', ' '))

    return new_columns

for Isocode in country_list:
    col_list = (Table_List["MEV"].loc[Table_List.Country == Isocode]).tolist()

    with pd.ExcelWriter(user_inputs[19], engine='openpyxl', mode="a", if_sheet_exists="overlay") as writer:
        start_row = 1
        start_col = 1

        for col in col_list:
            table = construct_and_populate_tables(Isocode, tzero_date, col).round(1)

            # Check if Weighted_required is 'Yes' in Data_Edge
            df = pd.read_excel(workbook_path, sheet_name="Data_Edge")
            weighted_required = df.loc[df['Trans_variable'] == col, 'Weighted_required'].iloc[0]

            if weighted_required == 'Yes':
                # Keep original columns
                new_columns = table.columns
            else:
                # Process columns
                new_columns = process_columns(table.columns, df)

            # Create a new table with the processed columns
            new_table = pd.DataFrame(columns=pd.MultiIndex.from_tuples(new_columns))

            # Copy data from the original table to the new table
            for col in table.columns:
                if col in new_table.columns:
                    new_table[col] = table[col]

            # Write the table to Excel
            new_table.to_excel(writer, sheet_name=Isocode, startrow=start_row, startcol=start_col, index=True)
            print(new_table.columns)

            # Adjust the worksheet properties
            worksheet = writer.sheets[Isocode]
            worksheet.sheet_view.showGridLines = False

print("Process completed successfully.")










import pandas as pd
from openpyxl import Workbook

# Read the Excel file
workbook_path = r".\Input\Mapping_File Copy.xlsx"
Table_List = pd.read_excel(workbook_path, sheet_name="Table_List")
Data_Edge_1 = pd.read_excel(workbook_path, sheet_name="Data_Edge")
country_list = list(Data_Edge_1["ISOCODES"].unique())

# Create a new workbook
wb = Workbook()
wb.save(user_inputs[19])

def process_columns(columns):
    new_columns = []
    scenario_groups = {}

    for col in columns:
        scenario = col[1]
        if scenario not in scenario_groups:
            scenario_groups[scenario] = []
        scenario_groups[scenario].append(col)

    for scenario, cols in scenario_groups.items():
        new_columns.extend(cols)
        if scenario != "Moody's":
            new_columns.append((cols[0][0], ' ', ' '))

    return new_columns

for Isocode in country_list:
    col_list = (Table_List["MEV"].loc[Table_List.Country == Isocode]).tolist()

    with pd.ExcelWriter(user_inputs[19], engine='openpyxl', mode="a", if_sheet_exists="overlay") as writer:
        start_row = 1
        start_col = 1

        for col in col_list:
            table = construct_and_populate_tables(Isocode, tzero_date, col).round(1)

            # Check if Weighted_required is 'Yes' in Data_Edge
            df = pd.read_excel(workbook_path, sheet_name="Data_Edge")
            weighted_required = df.loc[df['Trans_variable'] == col, 'Weighted_required'].iloc[0]

            if weighted_required == 'Yes':
                # Keep original columns
                new_columns = table.columns
            else:
                # Process columns
                new_columns = process_columns(table.columns)

            # Create a new table with the processed columns
            new_table = pd.DataFrame(index=table.index, columns=pd.MultiIndex.from_tuples(new_columns))

            # Copy data from the original table to the new table
            for col in table.columns:
                if col in new_table.columns:
                    new_table[col] = table[col]

            # Write the table to Excel
            new_table.to_excel(writer, sheet_name=Isocode, startrow=start_row, startcol=start_col, index=True)
            print(new_table.columns)

            # Adjust the worksheet properties
            worksheet = writer.sheets[Isocode]
            worksheet.sheet_view.showGridLines = False

print("Process completed successfully.")










import pandas as pd
from openpyxl import Workbook
import openpyxl

# Read the Excel file
workbook_path = r".\Input\Mapping_File Copy.xlsx"
Table_List = pd.read_excel(workbook_path, sheet_name="Table_List")
Data_Edge_1 = pd.read_excel(workbook_path, sheet_name="Data_Edge")
country_list = list(Data_Edge_1["ISOCODES"].unique())

# Create a new workbook
output_path = user_inputs[19]
wb = Workbook()
wb.save(output_path)

def process_columns(columns):
    new_columns = []
    current_scenario = None
    for col in columns:
        if col[1] != current_scenario:
            if current_scenario and current_scenario != "Moody's":
                new_columns.append((col[0], ' ', ' '))
            current_scenario = col[1]
        new_columns.append(col)
    return new_columns

for Isocode in country_list:
    col_list = (Table_List["MEV"].loc[Table_List.Country == Isocode]).tolist()

    wb = openpyxl.load_workbook(output_path)
    if Isocode in wb.sheetnames:
        wb.remove(wb[Isocode])
    ws = wb.create_sheet(Isocode)

    start_row = 1
    start_col = 1

    for col in col_list:
        table = construct_and_populate_tables(Isocode, tzero_date, col).round(1)

        # Check if Weighted_required is 'Yes' in Data_Edge
        df = pd.read_excel(workbook_path, sheet_name="Data_Edge")
        weighted_required = df.loc[df['Trans_variable'] == col, 'Weighted_required'].iloc[0]

        if weighted_required == 'Yes':
            new_columns = table.columns
        else:
            new_columns = process_columns(table.columns)

        # Write the column headers
        for i, col_header in enumerate(new_columns):
            ws.cell(row=start_row, column=start_col+i, value=str(col_header))

        # Write the data
        for i, row in enumerate(table.values):
            for j, value in enumerate(row):
                ws.cell(row=start_row+i+1, column=start_col+j, value=value)

        print(f"Processed table for {col} in {Isocode}")

    ws.sheet_view.showGridLines = False
    wb.save(output_path)

print("Process completed successfully.")

























import pandas as pd
from openpyxl import Workbook

# Read the Excel file
workbook_path = r".\Input\Mapping_File Copy.xlsx"
Table_List = pd.read_excel(workbook_path, sheet_name="Table_List")
Data_Edge_1 = pd.read_excel(workbook_path, sheet_name="Data_Edge")
country_list = list(Data_Edge_1["ISOCODES"].unique())

# Create a new workbook
wb = Workbook()
wb.save(user_inputs[19])

for Isocode in country_list:
    col_list = (Table_List["MEV"].loc[Table_List.Country == Isocode]).tolist()

    with pd.ExcelWriter(user_inputs[19], engine='openpyxl', mode="a", if_sheet_exists="overlay") as writer:
        start_row = 1
        start_col = 1

        for col in col_list:
            table = construct_and_populate_tables(Isocode, tzero_date, col).round(1)

            # Check if Weighted_required is 'Yes' in Data_Edge
            df = pd.read_excel(workbook_path, sheet_name="Data_Edge")
            weighted_required = df.loc[df['Trans_variable'] == col, 'Weighted_required'].iloc[0]

            if weighted_required == 'Yes':
                # Keep original columns
                new_columns = table.columns
            else:
                # Process columns
                new_columns = []
                scenario_groups = {}

                for column in table.columns:
                    scenario = column[1]
                    if scenario not in scenario_groups:
                        scenario_groups[scenario] = []
                    scenario_groups[scenario].append(column)

                for scenario, cols in scenario_groups.items():
                    new_columns.extend(cols)
                    if scenario != "Moody's":
                        new_columns.append((cols[0][0], ' ', ' '))

            # Create a new table with the processed columns
            new_table = pd.DataFrame(columns=pd.MultiIndex.from_tuples(new_columns))

            # Copy data from the original table to the new table
            for column in table.columns:
                if column in new_table.columns:
                    new_table[column] = table[column]

            # Write the table to Excel
            new_table.to_excel(writer, sheet_name=Isocode, startrow=start_row, startcol=start_col, index=True)
            print(new_table.columns)

            # Adjust the worksheet properties
            worksheet = writer.sheets[Isocode]
            worksheet.sheet_view.showGridLines = False

print("Process completed successfully.")







import pandas as pd
from openpyxl import Workbook

# Read the Excel file
workbook_path = r".\Input\Mapping_File Copy.xlsx"
Table_List = pd.read_excel(workbook_path, sheet_name="Table_List")
Data_Edge_1 = pd.read_excel(workbook_path, sheet_name="Data_Edge")
country_list = list(Data_Edge_1["ISOCODES"].unique())

# Create a new workbook
wb = Workbook()
output_path = "./Output/Processed_File.xlsx"
wb.save(output_path)

def process_columns(columns, df):
    new_columns = []
    scenario_groups = {}

    for col in columns:
        scenario = col[1]
        if scenario not in scenario_groups:
            scenario_groups[scenario] = []
        scenario_groups[scenario].append(col)

    for scenario, cols in scenario_groups.items():
        new_columns.extend(cols)
        if scenario != "Moody's":
            new_columns.append((cols[0][0], ' ', ' '))

    return new_columns

for Isocode in country_list:
    col_list = (Table_List["MEV"].loc[Table_List.Country == Isocode]).tolist()

    with pd.ExcelWriter(output_path, engine='openpyxl', mode="a", if_sheet_exists="overlay") as writer:
        start_row = 1
        start_col = 1

        for col in col_list:
            # Assuming construct_and_populate_tables is a valid function defined elsewhere
            table = construct_and_populate_tables(Isocode, tzero_date, col).round(1)

            # Check if Weighted_required is 'Yes' in Data_Edge
            df = pd.read_excel(workbook_path, sheet_name="Data_Edge")
            weighted_required = df.loc[df['Trans_variable'] == col, 'Weighted_required'].iloc[0]

            if weighted_required == 'Yes':
                # Keep original columns
                new_columns = table.columns
            else:
                # Process columns
                new_columns = process_columns(table.columns, df)

            # Create a new table with the processed columns
            new_table = pd.DataFrame(columns=pd.MultiIndex.from_tuples(new_columns))

            # Copy data from the original table to the new table
            for col in table.columns:
                if col in new_table.columns:
                    new_table[col] = table[col]

            # Write the table to Excel
            new_table.to_excel(writer, sheet_name=Isocode, startrow=start_row, startcol=start_col, index=True)
            print(new_table.columns)

            # Adjust the worksheet properties
            worksheet = writer.sheets[Isocode]
            worksheet.sheet_view.showGridLines = False

print("Process completed successfully.")


def remove_weighted_and_preceding(columns):
    new_columns = []
    for i, col in enumerate(columns):
        if 'Weighted' in col[-1]:
            if new_columns:
                new_columns.pop()  # Remove the preceding column
        elif i > 0 and 'Weighted' in columns[i-1][-1]:
            continue  # Skip this column (it's the one after 'Weighted')
        else:
            new_columns.append(col)
    return new_columns

def remove_weighted(columns):
    return [col for col in columns if 'Weighted' not in col[-1]]









import pandas as pd

# Assuming 'table' is your existing DataFrame with the original columns
# If not, replace 'table' with the actual name of your DataFrame

# Create a list to store the new columns
new_columns = []

# Iterate through the existing columns
for col in table.columns:
    # Check if the column is not a 'Weighted' column
    if col[2] != 'Weighted' and col[1] != ' ':
        new_columns.append(col)

    # Add a blank column after each scenario group (except Moody's)
    if col[2] == 'Down 2' and col[1] != "Moody's":
        new_columns.append((col[0], ' ', ' '))

# Create a new DataFrame with the modified columns
new_table = pd.DataFrame(columns=pd.MultiIndex.from_tuples(new_columns))

# Copy data from the original table to the new table
for col in new_columns:
    if col in table.columns:
        new_table[col] = table[col]

# Now 'new_table' has the desired column structure

# Print the new columns to verify
print(new_table.columns)

# If you want to replace the original table with the new one:
table = new_table

# If you need to write this to Excel:
# table.to_excel('your_output_file.xlsx', index=False)








def remove_weighted_and_preceding(columns):
    new_columns = []
    skip_next = False

    for i, col in enumerate(columns):
        if skip_next:
            skip_next = False
            continue

        if 'Weighted' in col[-1]:
            if new_columns:
                new_columns.pop()  # Remove the preceding column
            skip_next = True
        elif ' ' in col[-1] and 'IFRS9 1024 Scenarios' in col[1]:
            if new_columns:
                new_columns.pop()  # Remove the preceding column
            skip_next = True
        elif ' ' in col[-1] and 'IFRS9 4023 Scenarios' in col[1]:
            if new_columns:
                new_columns.pop()  # Remove the preceding column
            skip_next = True
        else:
            new_columns.append(col)

    return new_columns

# Example usage:
import pandas as pd

# Assuming 'table' is your well-defined DataFrame
table = pd.DataFrame(columns=pd.MultiIndex.from_tuples([
    ('Unemployment Rate (%)', 'IFRS9 1024 Scenarios', 'Upside'),
    ('Unemployment Rate (%)', 'IFRS9 1024 Scenarios', 'Central'),
    ('Unemployment Rate (%)', 'IFRS9 1024 Scenarios', 'Down 1'),
    ('Unemployment Rate (%)', 'IFRS9 1024 Scenarios', 'Down 2'),
    ('Unemployment Rate (%)', 'IFRS9 1024 Scenarios', ' '),
    ('Unemployment Rate (%)', 'IFRS9 1024 Scenarios', 'Weighted'),
    ('Unemployment Rate (%)', ' ', '  '),
    ('Unemployment Rate (%)', 'IFRS9 1024 Scenarios', 'Upside'),
    ('Unemployment Rate (%)', 'IFRS9 1024 Scenarios', 'Central'),
    ('Unemployment Rate (%)', 'IFRS9 1024 Scenarios', 'Down 1'),
    ('Unemployment Rate (%)', 'IFRS9 1024 Scenarios', 'Down 2'),
    ('Unemployment Rate (%)', 'IFRS9 1024 Scenarios', ' '),
    ('Unemployment Rate (%)', 'IFRS9 1024 Scenarios', 'Weighted'),
    ('Unemployment Rate (%)', ' ', ' '),
    ('Unemployment Rate (%)', 'Moody\'s', '10 % UP'),
    ('Unemployment Rate (%)', 'Moody\'s', 'Central'),
    ('Unemployment Rate (%)', 'Moody\'s', '10% DN'),
    ('Unemployment Rate (%)', 'Moody\'s', '4% DN')
]))

# Use the function to get the new columns
new_columns = remove_weighted_and_preceding(table.columns)

# Create a new DataFrame with the filtered columns
filtered_table = table[new_columns]

# Print the updated DataFrame columns
print(filtered_table.columns)








def remove_weighted_and_preceding(columns):
    new_columns = []
    skip_next = False

    for i, col in enumerate(columns):
        if skip_next:
            skip_next = False
            continue

        if 'Weighted' in col[-1]:
            if new_columns:
                new_columns.pop()  # Remove the preceding column
            skip_next = True
        elif ' ' in col[-1] and ('IFRS9 1024 Scenarios' in col[1] or 'IFRS9 4023 Scenarios' in col[1]):
            if new_columns:
                new_columns.pop()  # Remove the preceding column
            skip_next = True
        else:
            new_columns.append(col)

    return new_columns




def remove_weighted_and_preceding(columns):
    new_columns = []
    skip_next = False

    for i, col in enumerate(columns):
        if skip_next:
            skip_next = False
            continue

        if 'Weighted' in col[-1]:
            if new_columns:
                new_columns.pop()  # Remove the preceding column
            skip_next = True
        elif ' ' in col[-1] and ('IFRS9 1024 Scenarios' in col[1] or 'IFRS9 4023 Scenarios' in col[1]):
            if new_columns:
                new_columns.pop()  # Remove the preceding column
            skip_next = True
        else:
            new_columns.append(col)

    # Ensure the column with the structure ('Unemployment Rate (%)', ' ', '  ') is kept
    required_column = ('Unemployment Rate (%)', ' ', '  ')
    if required_column not in new_columns:
        new_columns.append(required_column)

    return new_columns






def update_col(sheet):
    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == "Upside":
                target_cell = sheet.cell(row=cell.row, column=cell.column + 4)
                if target_cell.value == 'a':
                    target_cell.value = ' '
                break





import pandas as pd
from openpyxl import load_workbook
from openpyxl.styles import PatternFill

# Define the path to your workbook
workbook_path = r".\Input\Rapping_File Copy.xlsx"

# Load the workbook and select the required sheet
workbook = load_workbook(workbook_path)
sheet = workbook['Data_Edge']

# Read the sheet into a DataFrame
df = pd.read_excel(workbook_path, sheet_name="Data_Edge")

# Iterate over the rows in the sheet
for row in sheet.iter_rows():
    for cell in row:
        if cell.value == '5yr Avg':
            # Determine the target column
            target_column = sheet.iter_rows(min_row=cell.row + 21, max_row=cell.row + 21, min_col=cell.column + 1, max_col=cell.column + 1)

            # Retrieve the target column value from the DataFrame
            target_column_value = None
            for target_cell in target_column:
                for value_cell in target_cell:
                    target_column_value = value_cell.value

            # Check if the target column exists in the DataFrame
            if target_column_value in df['Description'].values:
                weighted_required = df.loc[df['Description'] == target_column_value, 'Weighted_required'].iloc[0]
            else:
                print(f"Target column {target_column_value} not found in DataFrame")
                continue

            # Conditional formatting based on 'Weighted_required' value
            if weighted_required == "Yes":
                column_to_format = sheet.iter_rows(min_row=cell.row + 18, max_row=cell.row + 18, min_col=cell.column + 13, max_col=cell.column + 13)
                grey_fill = PatternFill(start_color='FFF5F5F5', end_color='FFF5F5F5', fill_type='solid')

                for row_to_format in column_to_format:
                    for cell_to_format in row_to_format:
                        cell_to_format.fill = grey_fill
            else:
                pass

# Save the modified workbook
workbook.save(workbook_path)














import pandas as pd
from openpyxl.styles import PatternFill

def format_sheet_1(sheet):
    workbook_path = r".\Input\Mapping_File Copy.xlsx"
    df = pd.read_excel(workbook_path, sheet_name="Data_Edge")

    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == 'Syr Avg':
                target_column = sheet.cell(row=cell.row - 21, column=cell.column + 1).value

                try:
                    weighted_required = df.loc[df['Description'] == target_column, 'Weighted_required'].iloc[0]

                    if weighted_required == 'Yes':
                        column_to_format = sheet.iter_rows(min_row=cell.row - 18, max_row=cell.row,
                                                           min_col=cell.column + 6, max_col=cell.column + 6)

                        grey_fill = PatternFill(start_color='FFF5F5F5', end_color='FFF5F5F5', fill_type='solid')

                        for cell_in_row in column_to_format:
                            for cell_in in cell_in_row:
                                cell_in.fill = grey_fill
                except IndexError:
                    print(f"No matching 'Description' found for {target_column}")
                except Exception as e:
                    print(f"An error occurred: {str(e)}")

# Assuming you have a workbook and worksheet object
# workbook = openpyxl.load_workbook('your_workbook.xlsx')
# worksheet = workbook['Sheet1']
# format_sheet_1(worksheet)





import pandas as pd
from openpyxl.styles import PatternFill

def format_sheet_1(sheet):
    workbook_path = r".\Input\Mapping_File Copy.xlsx"
    df = pd.read_excel(workbook_path, sheet_name="Data_Edge")

    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == '5yr Avg':
                # Get the value 21 rows above and 1 column after
                target_value = sheet.cell(row=cell.row - 21, column=cell.column + 1).value

                # Check if this value exists in the 'Description' column of the DataFrame
                matching_rows = df[df['Description'] == target_value]

                if not matching_rows.empty:
                    weighted_required = matching_rows['Weighted_required'].iloc[0]

                    if weighted_required == 'Yes':
                        # Apply formatting
                        grey_fill = PatternFill(start_color='FFF5F5F5', end_color='FFF5F5F5', fill_type='solid')
                        for r in range(cell.row - 18, cell.row + 1):
                            target_cell = sheet.cell(row=r, column=cell.column + 6)
                            target_cell.fill = grey_fill
                else:
                    print(f"No matching 'Description' found for {target_value}")

# Usage:
# workbook = openpyxl.load_workbook('your_workbook.xlsx')
# worksheet = workbook['Sheet1']
# format_sheet_1(worksheet)









import pandas as pd
from openpyxl.styles import PatternFill

def format_sheet_1(sheet):
    workbook_path = r".\Input\Mapping_File Copy.xlsx"
    df = pd.read_excel(workbook_path, sheet_name="Data_Edge")

    grey_fill = PatternFill(start_color='FFF5F5F5', end_color='FFF5F5F5', fill_type="solid")

    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == "5yr Avg":
                target_value = sheet.cell(row=cell.row - 21, column=cell.column + 1).value
                matching_rows = df[df['Description'] == target_value]

                if not matching_rows.empty:
                    weighted_required = matching_rows['Weighted_required'].iloc[0]

                    if weighted_required == 'Yes':
                        for r in range(cell.row - 18, cell.row + 1):
                            for c in range(cell.column + 8, cell.column + 12):
                                sheet.cell(row=r, column=c).fill = grey_fill
                    elif weighted_required == 'No':
                        for r in range(cell.row - 18, cell.row + 1):
                            for c in range(cell.column + 6, cell.column + 10):
                                sheet.cell(row=r, column=c).fill = grey_fill

            elif cell.value == "5yr Avg":
                target_value = sheet.cell(row=cell.row - 21, column=cell.column + 1).value
                matching_rows = df[df['Description'] == target_value]

                if not matching_rows.empty:
                    weighted_required = matching_rows['Weighted_required'].iloc[0]

                    if weighted_required == 'Yes':
                        for r in range(cell.row - 18, cell.row + 1):
                            for c in range(cell.column + 15, cell.column + 19):
                                sheet.cell(row=r, column=c).fill = grey_fill
                    elif weighted_required == 'No':
                        for r in range(cell.row - 18, cell.row + 1):
                            for c in range(cell.column + 11, cell.column + 15):
                                sheet.cell(row=r, column=c).fill = grey_fill

# Usage:
# workbook = openpyxl.load_workbook('your_workbook.xlsx')
# worksheet = workbook['Sheet1']
# format_sheet_1(worksheet)






import pandas as pd
from openpyxl.styles import PatternFill

def format_sheet_1(sheet, df, curr_year):
    grey_fill = PatternFill(start_color='FFF5F5F5', end_color='FFF5F5F5', fill_type='solid')
    index_rows = [str(curr_year-1), str(curr_year), str(curr_year + 1), '5yr Avg']

    for row in sheet.iter_rows():
        for cell in row:
            if cell.value in index_rows:
                # Set different offsets based on the cell value
                if cell.value == '5yr Avg':
                    target_row_offset = 21
                    format_row_offset = 18
                else:
                    target_row_offset = 3
                    format_row_offset = 0

                target_value = sheet.cell(row=cell.row - target_row_offset, column=cell.column + 1).value
                matching_rows = df[df['Description'] == target_value]

                if not matching_rows.empty:
                    weighted_required = matching_rows['Weighted_required'].iloc[0]

                    if weighted_required == 'Yes':
                        for r in range(cell.row - format_row_offset, cell.row + 1):
                            for c in range(cell.column + 8, cell.column + 12):
                                sheet.cell(row=r, column=c).fill = grey_fill
                    elif weighted_required == 'No':
                        for r in range(cell.row - format_row_offset, cell.row + 1):
                            for c in range(cell.column + 6, cell.column + 10):
                                sheet.cell(row=r, column=c).fill = grey_fill

# Usage:
# workbook = openpyxl.load_workbook('your_workbook.xlsx')
# worksheet = workbook['Sheet1']
# df = pd.read_excel(r".\Input\Mapping_File Copy.xlsx", sheet_name="Data_Edge")
# curr_year = 2024  # Set this to your current year
# format_sheet_1(worksheet, df, curr_year)







import pandas as pd
from openpyxl.styles import PatternFill

def format_sheet_1(sheet, df, curr_year):
    grey_fill = PatternFill(start_color='FFF5F5F5', end_color='FFF5F5F5', fill_type='solid')
    index_rows = [str(curr_year-1), str(curr_year), str(curr_year + 1), '5yr Avg']

    # Define offsets for each index_row
    offsets = {
        str(curr_year-1): {'target': 8, 'format': 5},
        str(curr_year): {'target': 13, 'format': 10},
        str(curr_year+1): {'target': 18, 'format': 15},
        '5yr Avg': {'target': 21, 'format': 18}
    }

    for row in sheet.iter_rows():
        for cell in row:
            if cell.value in index_rows:
                target_row_offset = offsets[cell.value]['target']
                format_row_offset = offsets[cell.value]['format']

                target_value = sheet.cell(row=cell.row - target_row_offset, column=cell.column + 1).value
                matching_rows = df[df['Description'] == target_value]

                if not matching_rows.empty:
                    weighted_required = matching_rows['Weighted_required'].iloc[0]

                    if weighted_required == 'Yes':
                        for r in range(cell.row - format_row_offset, cell.row + 1):
                            for c in range(cell.column + 8, cell.column + 12):
                                sheet.cell(row=r, column=c).fill = grey_fill
                    elif weighted_required == 'No':
                        for r in range(cell.row - format_row_offset, cell.row + 1):
                            for c in range(cell.column + 6, cell.column + 10):
                                sheet.cell(row=r, column=c).fill = grey_fill

# Usage:
# workbook = openpyxl.load_workbook('your_workbook.xlsx')
# worksheet = workbook['Sheet1']
# df = pd.read_excel(r".\Input\Mapping_File Copy.xlsx", sheet_name="Data_Edge")
# curr_year = 2024  # Set this to your current year
# format_sheet_1(worksheet, df, curr_year)




import pandas as pd
from openpyxl.styles import Font
from datetime import datetime
from dateutil.relativedelta import relativedelta

def formatting_red_IFRS4Q(sheet):
    workbook_path = r".\Input\Mapping_File Copy.xlsx"
    df = pd.read_excel(workbook_path, sheet_name="Data_Edge")

    # Generate dates
    tzero_date = "2024-03-31"
    zero_date = datetime.strptime(tzero_date, "%Y-%m-%d")
    dates = []
    current_date = zero_date.replace(year=zero_date.year - 1)

    for _ in range(14):
        dates.append(current_date)
        current_date = (current_date + relativedelta(months=3)).replace(day=1) - relativedelta(days=1)

    formatted_dates = [date.strftime('%Y-%m-%d') for date in dates]

    red_font_color = 'FFFF0000'

    df['ISOCODES'] = df['ISOCODES'].astype(str)
    df['Description'] = df['Description'].astype(str)
    df['Prev_Data_Edge'] = pd.to_datetime(df['Prev_Data_Edge'])

    data_edge_dict = {(row['ISOCODES'], row['Description']): row['Prev_Data_Edge'] for _, row in df.iterrows()}

    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == '5yr Avg':
                target_value = sheet.cell(row=cell.row - 21, column=cell.column + 1).value
                matching_rows = df[df['Description'] == target_value]

                if not matching_rows.empty:
                    weighted_required = matching_rows['Weighted_required'].iloc[0]

                    if weighted_required == 'No':
                        isocodes = sheet.cell(row=cell.row - 21, column=cell.column + 8).value
                        checks = sheet.cell(row=cell.row - 22, column=cell.column + 7).value

                        prev_data_edge = data_edge_dict.get((str(isocodes), str(checks)))

                        if prev_data_edge is None:
                            continue

                        prev_data_edge_str = prev_data_edge.strftime('%Y-%m-%d')

                        if prev_data_edge_str not in formatted_dates:
                            continue

                        row_matched_with_date = formatted_dates.index(prev_data_edge_str)

                        range_to_change_font_color = sheet[
                            sheet.cell(row=cell.row - 18, column=cell.column).coordinate:
                            sheet.cell(row=cell.row - 21 + row_matched_with_date, column=cell.column + 5).coordinate
                        ]

                        new_font = Font(color=red_font_color, italic=True, name='Univers Next for HSBC Light')
                        for row in range_to_change_font_color:
                            for cell in row:
                                cell.font = new_font

# Usage:
# workbook = openpyxl.load_workbook('your_workbook.xlsx')
# worksheet = workbook['Sheet1']
# formatting_red_IFRS4Q(worksheet)
# workbook.save('your_workbook_updated.xlsx')











import pandas as pd
from openpyxl.styles import Font
from datetime import datetime
from dateutil.relativedelta import relativedelta

def formatting_red_IFRS4Q(sheet):
    workbook_path = r".\Input\Mapping_File Copy.xlsx"
    df = pd.read_excel(workbook_path, sheet_name="Data_Edge")

    tzero_date = "2024-03-31"
    zero_date = datetime.strptime(tzero_date, "%Y-%m-%d")

    # Generate dates
    dates = []
    current_date = zero_date.replace(year=zero_date.year - 1)
    for _ in range(14):
        dates.append(current_date)
        current_date = (current_date + relativedelta(months=3)).replace(day=1) - relativedelta(days=1)

    # Assign dates to specific row offsets
    date_row_offsets = [17, 16, 15, 14, 12, 11, 10, 9, 7, 6, 5, 4, 3, 2]
    date_mapping = dict(zip(date_row_offsets, dates))

    red_font_color = 'FFFF0000'

    df['ISOCODES'] = df['ISOCODES'].astype(str)
    df['Description'] = df['Description'].astype(str)
    df['Prev_Data_Edge'] = pd.to_datetime(df['Prev_Data_Edge'])

    data_edge_dict = {(row['ISOCODES'], row['Description']): row['Prev_Data_Edge'] for _, row in df.iterrows()}

    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == '5yr Avg':
                target_value = sheet.cell(row=cell.row - 21, column=cell.column + 1).value
                matching_rows = df[df['Description'] == target_value]

                if not matching_rows.empty:
                    weighted_required = matching_rows['Weighted_required'].iloc[0]

                    if weighted_required == 'No':
                        isocodes = sheet.cell(row=cell.row - 21, column=cell.column + 8).value
                        checks = sheet.cell(row=cell.row - 22, column=cell.column + 7).value

                        prev_data_edge = data_edge_dict.get((str(isocodes), str(checks)))

                        if prev_data_edge is None:
                            continue

                        # Find the matching row offset
                        matching_offset = None
                        for offset, date in date_mapping.items():
                            if date.date() == prev_data_edge.date():
                                matching_offset = offset
                                break

                        if matching_offset is None:
                            continue

                        range_to_change_font_color = sheet[
                            sheet.cell(row=cell.row - 18, column=cell.column).coordinate:
                            sheet.cell(row=cell.row - matching_offset, column=cell.column + 5).coordinate
                        ]

                        new_font = Font(color=red_font_color, italic=True, name='Univers Next for HSBC Light')
                        for row in range_to_change_font_color:
                            for cell in row:
                                cell.font = new_font

# Usage:
# workbook = openpyxl.load_workbook('your_workbook.xlsx')
# worksheet = workbook['Sheet1']
# formatting_red_IFRS4Q(worksheet)
# workbook.save('your_workbook_updated.xlsx')








import pandas as pd
from openpyxl.styles import Font
from datetime import datetime
from dateutil.relativedelta import relativedelta

def formatting_red_IFRS4Q(sheet):
    workbook_path = r".\Input\Mapping_File Copy.xlsx"
    df = pd.read_excel(workbook_path, sheet_name="Data_Edge")

    tzero_date = "2024-03-31"
    zero_date = datetime.strptime(tzero_date, "%Y-%m-%d")

    # Generate dates
    dates = []
    current_date = zero_date.replace(year=zero_date.year - 1)
    for _ in range(14):
        dates.append(current_date)
        current_date = (current_date + relativedelta(months=3)).replace(day=1) - relativedelta(days=1)

    # Assign dates to specific row offsets
    date_row_offsets = [17, 16, 15, 14, 12, 11, 10, 9, 7, 6, 5, 4, 3, 2]
    date_mapping = dict(zip(date_row_offsets, dates))

    red_font_color = 'FFFF0000'

    df['ISOCODES'] = df['ISOCODES'].astype(str)
    df['Description'] = df['Description'].astype(str)
    df['Prev_Data_Edge'] = pd.to_datetime(df['Prev_Data_Edge'])

    data_edge_dict = {(row['ISOCODES'], row['Description']): row['Prev_Data_Edge'] for _, row in df.iterrows()}

    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == '5yr Avg':
                target_value = sheet.cell(row=cell.row - 21, column=cell.column + 1).value
                matching_rows = df[df['Description'] == target_value]

                if not matching_rows.empty:
                    weighted_required = matching_rows['Weighted_required'].iloc[0]

                    if weighted_required == 'No':
                        isocodes = sheet.cell(row=cell.row - 21, column=cell.column + 8).value
                        checks = sheet.cell(row=cell.row - 22, column=cell.column + 7).value

                        prev_data_edge = data_edge_dict.get((str(isocodes), str(checks)))

                        if prev_data_edge is None:
                            continue

                        # Find the matching row offset
                        matching_offset = None
                        for offset, date in date_mapping.items():
                            if date.date() == prev_data_edge.date():
                                matching_offset = offset
                                break

                        if matching_offset is None:
                            continue

                        range_to_change_font_color = sheet[
                            sheet.cell(row=cell.row - 18, column=cell.column).coordinate:
                            sheet.cell(row=cell.row - matching_offset, column=cell.column + 5).coordinate
                        ]

                        new_font = Font(color=red_font_color, italic=True, name='Univers Next for HSBC Light')
                        for row in range_to_change_font_color:
                            for cell in row:
                                cell.font = new_font

# Usage:
# workbook = openpyxl.load_workbook('your_workbook.xlsx')
# worksheet = workbook['Sheet1']
# formatting_red_IFRS4Q(worksheet)
# workbook.save('your_workbook_updated.xlsx')






import pandas as pd
from openpyxl.styles import Font
from datetime import datetime
from dateutil.relativedelta import relativedelta

def formatting_red_IFRS4Q(sheet):
    workbook_path = r".\Input\Mapping_File Copy.xlsx"
    data_edge = pd.read_excel(workbook_path, sheet_name="Data_Edge")
    red_font_color = 'FFFF0000'

    data_edge['ISOCODES'] = data_edge['ISOCODES'].astype(str)
    data_edge['Description'] = data_edge['Description'].astype(str)
    data_edge['Prev_Data_Edge'] = pd.to_datetime(data_edge['Prev_Data_Edge'])

    data_edge_dict = {(row['ISOCODES'], row['Description']): row['Prev_Data_Edge'] for _, row in data_edge.iterrows()}

    # Generate dates
    tzero_date = "2024-03-31"
    zero_date = datetime.strptime(tzero_date, "%Y-%m-%d")
    dates = []
    current_date = zero_date.replace(year=zero_date.year - 1)
    for _ in range(14):
        dates.append(current_date)
        current_date = (current_date + relativedelta(months=3)).replace(day=1) - relativedelta(days=1)

    # Assign dates to specific row offsets
    date_row_offsets = [17, 16, 15, 14, 12, 11, 10, 9, 7, 6, 5, 4, 3, 2]
    date_mapping = dict(zip(date_row_offsets, dates))

    all_cells = list(sheet.iter_rows(values_only=True))
    target_cells = [(row_idx, col_idx) for row_idx, row in enumerate(all_cells, 1)
                    for col_idx, cell_value in enumerate(row, 1) if cell_value == '5yr Avg']

    for row, col in target_cells:
        isocodes = sheet.cell(row=row-21, column=col + 8).value
        checks = sheet.cell(row=row-22, column=col + 7).value
        prev_data_edge = data_edge_dict.get((str(isocodes), str(checks)))

        if prev_data_edge is None:
            continue

        prev_data_edge_str = prev_data_edge.strftime('%Y-%m-%d')

        # Find matching row offset
        matching_offset = None
        for offset, date in date_mapping.items():
            if date.strftime('%Y-%m-%d') == prev_data_edge_str:
                matching_offset = offset
                break

        if matching_offset is None:
            continue

        row_matched_with_date = row - matching_offset

        range_to_change_font_color = sheet[
            sheet.cell(row=row-18, column=col).coordinate:
            sheet.cell(row=row_matched_with_date, column=col + 5).coordinate
        ]

        new_font = Font(color=red_font_color, italic=True, name='Univers Next for HSBC Light')
        for row in range_to_change_font_color:
            for cell in row:
                cell.font = new_font

# Usage:
# workbook = openpyxl.load_workbook('your_workbook.xlsx')
# worksheet = workbook['Sheet1']
# formatting_red_IFRS4Q(worksheet)
# workbook.save('your_workbook_updated.xlsx')









import pandas as pd
from openpyxl.styles import Font
from datetime import datetime
from dateutil.relativedelta import relativedelta

def formatting_red_IFRS4Q(sheet):
    workbook_path = r".\Input\Mapping_File Copy.xlsx"
    data_edge = pd.read_excel(workbook_path, sheet_name="Data_Edge")
    red_font_color = 'FFFF0000'

    data_edge['ISOCODES'] = data_edge['ISOCODES'].astype(str)
    data_edge['Description'] = data_edge['Description'].astype(str)
    data_edge['Prev_Data_Edge'] = pd.to_datetime(data_edge['Prev_Data_Edge'])

    data_edge_dict = {(row['ISOCODES'], row['Description']): row['Prev_Data_Edge'] for _, row in data_edge.iterrows()}

    # Generate dates
    start_date = datetime(2023, 3, 31)
    dates = []
    for i in range(14):
        year = start_date.year + (i // 4)
        month = 3 + (3 * (i % 4))
        day = 30 if month in [6, 9] else 31
        dates.append(datetime(year, month, day))

    # Assign dates to specific row offsets
    date_row_offsets = [17, 16, 15, 14, 12, 11, 10, 9, 7, 6, 5, 4, 3, 2]
    date_mapping = dict(zip(date_row_offsets, dates))

    all_cells = list(sheet.iter_rows(values_only=True))
    target_cells = [(row_idx, col_idx) for row_idx, row in enumerate(all_cells, 1)
                    for col_idx, cell_value in enumerate(row, 1) if cell_value == '5yr Avg']

    for row, col in target_cells:
        isocodes = sheet.cell(row=row-21, column=col + 8).value
        checks = sheet.cell(row=row-22, column=col + 7).value
        prev_data_edge = data_edge_dict.get((str(isocodes), str(checks)))

        if prev_data_edge is None:
            continue

        prev_data_edge_str = prev_data_edge.strftime('%m/%d/%Y')

        # Find matching row offset
        matching_offset = None
        for offset, date in date_mapping.items():
            if date.strftime('%m/%d/%Y') == prev_data_edge_str:
                matching_offset = offset
                break

        if matching_offset is None:
            continue

        row_matched_with_date = row - matching_offset

        range_to_change_font_color = sheet[
            sheet.cell(row=row-18, column=col).coordinate:
            sheet.cell(row=row_matched_with_date, column=col + 5).coordinate
        ]

        new_font = Font(color=red_font_color, italic=True, name='Univers Next for HSBC Light')
        for row in range_to_change_font_color:
            for cell in row:
                cell.font = new_font

# Usage:
# workbook = openpyxl.load_workbook('your_workbook.xlsx')
# worksheet = workbook['Sheet1']
# formatting_red_IFRS4Q(worksheet)
# workbook.save('your_workbook_updated.xlsx')

import pandas as pd
from openpyxl.styles import Font
from datetime import datetime
from dateutil.relativedelta import relativedelta

def formatting_red_IFRS4Q(sheet):
    workbook_path = r".\Input\Mapping_File Copy.xlsx"
    data_edge = pd.read_excel(workbook_path, sheet_name="Data_Edge")
    red_font_color = 'FFFF0000'

    data_edge['ISOCODES'] = data_edge['ISOCODES'].astype(str)
    data_edge['Description'] = data_edge['Description'].astype(str)
    data_edge['Prev_Data_Edge'] = pd.to_datetime(data_edge['Prev_Data_Edge'])

    data_edge_dict = {(row['ISOCODES'], row['Description']): row['Prev_Data_Edge'] for _, row in data_edge.iterrows()}

    # Generate dates
    tzero_date = datetime(2024, 3, 31)
    dates = []
    current_date = tzero_date - relativedelta(years=1)
    for _ in range(14):
        dates.append(current_date)
        current_date += relativedelta(months=3)
        if current_date.month in [4, 7, 10]:
            current_date -= relativedelta(days=1)

    # Assign dates to specific row offsets
    date_row_offsets = [17, 16, 15, 14, 12, 11, 10, 9, 7, 6, 5, 4, 3, 2]
    date_mapping = dict(zip(date_row_offsets, dates))

    all_cells = list(sheet.iter_rows(values_only=True))
    target_cells = [(row_idx, col_idx) for row_idx, row in enumerate(all_cells, 1)
                    for col_idx, cell_value in enumerate(row, 1) if cell_value == '5yr Avg']

    for row, col in target_cells:
        isocodes = sheet.cell(row=row-21, column=col + 8).value
        checks = sheet.cell(row=row-22, column=col + 7).value
        prev_data_edge = data_edge_dict.get((str(isocodes), str(checks)))

        if prev_data_edge is None:
            continue

        prev_data_edge_str = prev_data_edge.strftime('%m/%d/%Y')

        # Find matching row offset
        matching_offset = None
        for offset, date in date_mapping.items():
            if date.strftime('%m/%d/%Y') == prev_data_edge_str:
                matching_offset = offset
                break

        if matching_offset is None:
            continue

        row_matched_with_date = row - matching_offset

        range_to_change_font_color = sheet[
            sheet.cell(row=row-18, column=col).coordinate:
            sheet.cell(row=row_matched_with_date, column=col + 5).coordinate
        ]

        new_font = Font(color=red_font_color, italic=True, name='Univers Next for HSBC Light')
        for row in range_to_change_font_color:
            for cell in row:
                cell.font = new_font

# Usage:
# workbook = openpyxl.load_workbook('your_workbook.xlsx')
# worksheet = workbook['Sheet1']
# formatting_red_IFRS4Q(worksheet)
# workbook.save('your_workbook_updated.xlsx')




import pandas as pd
from openpyxl.styles import Font
from datetime import datetime
from dateutil.relativedelta import relativedelta

def formatting_red_IFRS4Q(sheet):
    workbook_path = r".\Input\Mapping_File Copy.xlsx"
    data_edge = pd.read_excel(workbook_path, sheet_name="Data_Edge")
    red_font_color = 'FFFF0000'

    data_edge['ISOCODES'] = data_edge['ISOCODES'].astype(str)
    data_edge['Description'] = data_edge['Description'].astype(str)
    data_edge['Prev_Data_Edge'] = pd.to_datetime(data_edge['Prev_Data_Edge'])

    data_edge_dict = {(row['ISOCODES'], row['Description']): row['Prev_Data_Edge'] for _, row in data_edge.iterrows()}

    # Generate dates
    tzero_date = "2024-03-31"
    zero_date = datetime.strptime(tzero_date, "%Y-%m-%d")
    zero_date_1 = zero_date.replace(year=zero_date.year - 1)
    date1 = zero_date_1
    date2 = ((date1 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date3 = ((date2 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date4 = ((date3 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date5 = ((date4 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date6 = ((date5 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date7 = ((date6 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date8 = ((date7 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date9 = ((date8 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date10 = ((date9 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date11 = ((date10 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date12 = ((date11 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date13 = ((date12 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date14 = ((date13 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))

    dates = [date1, date2, date3, date4, date5, date6, date7, date8, date9, date10, date11, date12, date13, date14]

    # Assign dates to specific row offsets
    date_row_offsets = [17, 16, 15, 14, 12, 11, 10, 9, 7, 6, 5, 4, 3, 2]
    date_mapping = dict(zip(date_row_offsets, dates))

    all_cells = list(sheet.iter_rows(values_only=True))
    target_cells = [(row_idx, col_idx) for row_idx, row in enumerate(all_cells, 1)
                    for col_idx, cell_value in enumerate(row, 1) if cell_value == '5yr Avg']

    for row, col in target_cells:
        isocodes = sheet.cell(row=row-21, column=col + 8).value
        checks = sheet.cell(row=row-22, column=col + 7).value
        prev_data_edge = data_edge_dict.get((str(isocodes), str(checks)))

        if prev_data_edge is None:
            continue

        prev_data_edge_str = prev_data_edge.strftime('%m/%d/%Y')

        # Find matching row offset
        matching_offset = None
        for offset, date in date_mapping.items():
            if date.strftime('%m/%d/%Y') == prev_data_edge_str:
                matching_offset = offset
                break

        if matching_offset is None:
            continue

        row_matched_with_date = row - matching_offset

        range_to_change_font_color = sheet[
            sheet.cell(row=row-18, column=col).coordinate:
            sheet.cell(row=row_matched_with_date, column=col + 5).coordinate
        ]

        new_font = Font(color=red_font_color, italic=True, name='Univers Next for HSBC Light')
        for row in range_to_change_font_color:
            for cell in row:
                cell.font = new_font

# Usage:
# workbook = openpyxl.load_workbook('your_workbook.xlsx')
# worksheet = workbook['Sheet1']
# formatting_red_IFRS4Q(worksheet)
# workbook.save('your_workbook_updated.xlsx')








import pandas as pd
from openpyxl.styles import Font, Border, Side
from datetime import datetime
from dateutil.relativedelta import relativedelta

def formatting_red_IFRS4Q(sheet):
    workbook_path = r".\Input\Mapping_File Copy.xlsx"
    data_edge = pd.read_excel(workbook_path, sheet_name="Data_Edge")
    red_font_color = 'FFFF0000'

    data_edge['ISOCODES'] = data_edge['ISOCODES'].astype(str)
    data_edge['Description'] = data_edge['Description'].astype(str)
    data_edge['Prev_Data_Edge'] = pd.to_datetime(data_edge['Prev_Data_Edge'])

    data_edge_dict = {(row['ISOCODES'], row['Description']): row['Prev_Data_Edge'] for _, row in data_edge.iterrows()}

    # Generate dates
    tzero_date = "2024-03-31"
    zero_date = datetime.strptime(tzero_date, "%Y-%m-%d")
    zero_date_1 = zero_date.replace(year=zero_date.year - 1)
    date1 = zero_date_1
    date2 = ((date1 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date3 = ((date2 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date4 = ((date3 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date5 = ((date4 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date6 = ((date5 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date7 = ((date6 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date8 = ((date7 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date9 = ((date8 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date10 = ((date9 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date11 = ((date10 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date12 = ((date11 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date13 = ((date12 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date14 = ((date13 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))

    dates = [date1, date2, date3, date4, date5, date6, date7, date8, date9, date10, date11, date12, date13, date14]

    # Assign dates to specific row offsets
    date_row_offsets = [17, 16, 15, 14, 12, 11, 10, 9, 7, 6, 5, 4, 3, 2]
    date_mapping = dict(zip(date_row_offsets, dates))

    all_cells = list(sheet.iter_rows(values_only=True))
    target_cells = [(row_idx, col_idx) for row_idx, row in enumerate(all_cells, 1)
                    for col_idx, cell_value in enumerate(row, 1) if cell_value == '5yr Avg']

    for row, col in target_cells:
        isocodes = sheet.cell(row=row-21, column=col + 8).value
        checks = sheet.cell(row=row-22, column=col + 7).value
        prev_data_edge = data_edge_dict.get((str(isocodes), str(checks)))

        if prev_data_edge is None:
            continue

        prev_data_edge_str = prev_data_edge.strftime('%m/%d/%Y')

        # Find matching row offset
        matching_offset = None
        for offset, date in date_mapping.items():
            if date.strftime('%m/%d/%Y') == prev_data_edge_str:
                matching_offset = offset
                break

        if matching_offset is None:
            continue

        row_matched_with_date = row - matching_offset

        range_to_change_font_color = sheet[
            sheet.cell(row=row-18, column=col).coordinate:
            sheet.cell(row=row_matched_with_date, column=col + 5).coordinate
        ]

        new_font = Font(color=red_font_color, italic=True, name='Univers Next for HSBC Light')
        for row in range_to_change_font_color:
            for cell in row:
                cell.font = new_font

def red_marking(sheet, tzero_date, above_date, below_date):
    # Define the medium red border style
    medium_red_border = Side(style="medium", color='FF0000')

    # Generate dates
    zero_date = datetime.strptime(tzero_date, "%Y-%m-%d")
    zero_date_1 = zero_date.replace(year=zero_date.year - 1)
    date1 = zero_date_1
    date2 = ((date1 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date3 = ((date2 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date4 = ((date3 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date5 = ((date4 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date6 = ((date5 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date7 = ((date6 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date8 = ((date7 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date9 = ((date8 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date10 = ((date9 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date11 = ((date10 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date12 = ((date11 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date13 = ((date12 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date14 = ((date13 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))

    dates = [date1, date2, date3, date4, date5, date6, date7, date8, date9, date10, date11, date12, date13, date14]

    # Assign dates to specific row offsets
    date_row_offsets = [17, 16, 15, 14, 12, 11, 10, 9, 7, 6, 5, 4, 3, 2]
    date_mapping = dict(zip(date_row_offsets, dates))

    # Convert boundary dates to datetime objects
    above_date = datetime.strptime(above_date, "%Y-%m-%d")
    below_date = datetime.strptime(below_date, "%Y-%m-%d")

    # Find the rows for the boundary dates
    above_row = None
    below_row = None

    for offset, date in date_mapping.items():
        if date >= above_date and above_row is None:
            above_row = offset
        if date <= below_date:
            below_row = offset
        if above_row is not None and below_row is not None:
            break

    if above_row is None or below_row is None:
        return

    all_cells = list(sheet.iter_rows(values_only=True))
    target_cells = [(row_idx, col_idx) for row_idx, row in enumerate(all_cells, 1)
                    for col_idx, cell_value in enumerate(row, 1) if cell_value == '5yr Avg']

    for row, col in target_cells:
        start_cell = sheet.cell(row=row-above_row, column=col)
        end_cell = sheet.cell(row=row-below_row, column=col+5)

        for box_row in sheet[start_cell.coordinate:end_cell.coordinate]:
            for box_cell in box_row:
                if box_cell.row == start_cell.row:
                    box_cell.border = Border(top=medium_red_border, left=medium_red_border, right=medium_red_border)
                elif box_cell.row == end_cell.row:
                    box_cell.border = Border(bottom=medium_red_border, left=medium_red_border, right=medium_red_border)
                else:
                    box_cell.border = Border(left=medium_red_border, right=medium_red_border)

# Usage example:
# import openpyxl
#
# workbook = openpyxl.load_workbook('your_workbook.xlsx')
# worksheet = workbook['Sheet1']
#
# formatting_red_IFRS4Q(worksheet)
#
# tzero_date = "2024-03-31"
# above_date = "2023-06-30"
# below_date = "2024-03-31"
# red_marking(worksheet, tzero_date, above_date, below_date)
#
# workbook.save('your_workbook_updated.xlsx')







import pandas as pd
from openpyxl.styles import Border, Side
from datetime import datetime
from dateutil.relativedelta import relativedelta

def red_marking(sheet, tzero_date, user_inputs):
    # Define the medium red border style
    medium_red_border = Side(style="medium", color='FF0000')

    # Generate dates
    zero_date = datetime.strptime(tzero_date, "%Y-%m-%d")
    zero_date_1 = zero_date.replace(year=zero_date.year - 1)
    date1 = zero_date_1
    date2 = ((date1 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date3 = ((date2 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date4 = ((date3 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date5 = ((date4 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date6 = ((date5 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date7 = ((date6 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date8 = ((date7 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date9 = ((date8 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date10 = ((date9 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date11 = ((date10 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date12 = ((date11 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date13 = ((date12 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date14 = ((date13 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))

    dates = [date1, date2, date3, date4, date5, date6, date7, date8, date9, date10, date11, date12, date13, date14]

    # Assign dates to specific row offsets
    date_row_offsets = [17, 16, 15, 14, 12, 11, 10, 9, 7, 6, 5, 4, 3, 2]
    date_mapping = dict(zip(date_row_offsets, dates))

    # Extract dates from the first column, keeping track of their row numbers
    date_column = [date.strftime("%m/%d/%Y") for date in dates]
    date_rows = date_row_offsets

    datetime_index = pd.to_datetime(date_column, format="%m/%d/%Y", errors='coerce')

    # Get the boundary dates from user inputs
    above_date = pd.to_datetime(user_inputs[17], format='%Y-%m-%d', errors='coerce')
    below_date = pd.to_datetime(user_inputs[18], format='%Y-%m-%d', errors='coerce')

    # Find the rows for the boundary dates
    above_row = below_row = None
    for i, date in enumerate(datetime_index):
        if pd.notnull(date):
            if date >= above_date and above_row is None:
                above_row = date_rows[i]  # 4 cells above the matching date
            if date <= below_date:
                below_row = date_rows[i]  # Start with the row of the matching date
                # Check if there's a date after this one
                if i + 1 < len(datetime_index):
                    below_row = date_rows[i]  # Use the row of the current date
                else:
                    # If it's the last date, use the last row
                    below_row = date_rows[-1]
                break

    if above_row and below_row:
        for row in sheet.iter_rows():
            for cell in row:
                if cell.value == user_inputs[0]:
                    start_cell = sheet.cell(row=above_row, column=cell.column + 1)
                    end_cell = sheet.cell(row=below_row, column=cell.column + 1)
                    for box_row in sheet[start_cell.coordinate:end_cell.coordinate]:
                        for box_cell in box_row:
                            if box_cell.row == start_cell.row:
                                box_cell.border = Border(top=medium_red_border, left=medium_red_border, right=medium_red_border)
                            elif box_cell.row == end_cell.row:
                                box_cell.border = Border(bottom=medium_red_border, left=medium_red_border, right=medium_red_border)
                            else:
                                box_cell.border = Border(left=medium_red_border, right=medium_red_border)

# Usage example:
# import openpyxl
#
# workbook = openpyxl.load_workbook('your_workbook.xlsx')
# worksheet = workbook['Sheet1']
#
# tzero_date = "2024-03-31"
# user_inputs = [...] # Make sure to include the necessary inputs, especially at indices 0, 17, and 18
# red_marking(worksheet, tzero_date, user_inputs)
#
# workbook.save('your_workbook_updated.xlsx')








import pandas as pd
from openpyxl.styles import Border, Side
from datetime import datetime
from dateutil.relativedelta import relativedelta

def red_marking(sheet, tzero_date, user_inputs):
    # Define the medium red border style
    medium_red_border = Side(style="medium", color='FF0000')

    # Generate dates
    zero_date = datetime.strptime(tzero_date, "%Y-%m-%d")
    zero_date_1 = zero_date.replace(year=zero_date.year - 1)
    date1 = zero_date_1
    date2 = ((date1 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date3 = ((date2 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date4 = ((date3 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date5 = ((date4 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date6 = ((date5 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date7 = ((date6 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date8 = ((date7 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date9 = ((date8 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date10 = ((date9 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date11 = ((date10 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date12 = ((date11 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date13 = ((date12 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))
    date14 = ((date13 + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1))

    dates = [date1, date2, date3, date4, date5, date6, date7, date8, date9, date10, date11, date12, date13, date14]

    # Assign dates to specific row offsets
    date_row_offsets = [17, 16, 15, 14, 12, 11, 10, 9, 7, 6, 5, 4, 3, 2]
    date_mapping = dict(zip(date_row_offsets, dates))

    # Extract dates from the first column, keeping track of their row numbers
    date_column = [date.strftime("%m/%d/%Y") for date in dates]
    date_rows = date_row_offsets

    datetime_index = pd.to_datetime(date_column, format="%m/%d/%Y", errors='coerce')

    # Get the boundary dates from user inputs
    above_date = pd.to_datetime(user_inputs[17], format='%Y-%m-%d', errors='coerce')
    below_date = pd.to_datetime(user_inputs[18], format='%Y-%m-%d', errors='coerce')

    # Find the rows for the boundary dates
    above_row = below_row = None
    for i, date in enumerate(datetime_index):
        if pd.notnull(date):
            if date >= above_date and above_row is None:
                above_row = date_rows[i]  # 4 cells above the matching date
            if date <= below_date:
                below_row = date_rows[i]  # Start with the row of the matching date
                # Check if there's a date after this one
                if i + 1 < len(datetime_index):
                    below_row = date_rows[i]  # Use the row of the current date
                else:
                    # If it's the last date, use the last row
                    below_row = date_rows[-1]
                break

    if above_row and below_row:
        for row in sheet.iter_rows():
            for cell in row:
                if cell.value == user_inputs[0]:
                    start_cell = sheet.cell(row=above_row, column=cell.column + 1)
                    end_cell = sheet.cell(row=below_row, column=cell.column + 1)
                    for box_row in sheet[start_cell.coordinate:end_cell.coordinate]:
                        for box_cell in box_row:
                            if box_cell.row == start_cell.row:
                                box_cell.border = Border(top=medium_red_border, left=medium_red_border, right=medium_red_border)
                            elif box_cell.row == end_cell.row:
                                box_cell.border = Border(bottom=medium_red_border, left=medium_red_border, right=medium_red_border)
                            else:
                                box_cell.border = Border(left=medium_red_border, right=medium_red_border)

# Usage example:
# import openpyxl
#
# workbook = openpyxl.load_workbook('your_workbook.xlsx')
# worksheet = workbook['Sheet1']
#
# tzero_date = "2024-03-31"
# user_inputs = [...] # Make sure to include the necessary inputs, especially at indices 0, 17, and 18
# red_marking(worksheet, tzero_date, user_inputs)
#
# workbook.save('your_workbook_updated.xlsx')










import pandas as pd
from openpyxl.styles import Border, Side
from datetime import datetime
from dateutil.relativedelta import relativedelta

def red_marking(sheet, tzero_date, user_inputs):
    # Define the medium red border style
    medium_red_border = Side(style="medium", color='FF0000')

    # Generate dates
    zero_date = datetime.strptime(tzero_date, "%Y-%m-%d")
    zero_date_1 = zero_date.replace(year=zero_date.year - 1)
    dates = [zero_date_1]
    for _ in range(13):
        dates.append(((dates[-1] + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1)))

    # Assign dates to specific row offsets (relative to '5yr Avg' row)
    date_row_offsets = [17, 16, 15, 14, 12, 11, 10, 9, 7, 6, 5, 4, 3, 2]
    date_mapping = dict(zip(date_row_offsets, dates))

    # Convert user input dates to datetime
    above_date = pd.to_datetime(user_inputs[17], format='%Y-%m-%d', errors='coerce')
    below_date = pd.to_datetime(user_inputs[18], format='%Y-%m-%d', errors='coerce')

    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == '5yr Avg':
                avg_row = cell.row
                avg_col = cell.column

                # Find the rows for the boundary dates
                above_offset = next((offset for offset, date in date_mapping.items() if date >= above_date), None)
                below_offset = next((offset for offset, date in reversed(date_mapping.items()) if date <= below_date), None)

                if above_offset is not None and below_offset is not None:
                    start_row = avg_row - above_offset
                    end_row = avg_row - below_offset

                    # Apply red border
                    for box_row in range(start_row, end_row + 1):
                        for box_col in range(avg_col + 1, avg_col + 6):  # 5 columns to the right
                            box_cell = sheet.cell(row=box_row, column=box_col)
                            if box_row == start_row:
                                box_cell.border = Border(top=medium_red_border, left=medium_red_border, right=medium_red_border)
                            elif box_row == end_row:
                                box_cell.border = Border(bottom=medium_red_border, left=medium_red_border, right=medium_red_border)
                            else:
                                box_cell.border = Border(left=medium_red_border, right=medium_red_border)

# Usage example:
# import openpyxl
#
# workbook = openpyxl.load_workbook('your_workbook.xlsx')
# worksheet = workbook['Sheet1']
#
# tzero_date = "2024-03-31"
# user_inputs = [...] # Make sure to include the necessary inputs, especially at indices 17 and 18
# red_marking(worksheet, tzero_date, user_inputs)
#
# workbook.save('your_workbook_updated.xlsx')




import pandas as pd
from openpyxl.styles import Border, Side
from datetime import datetime
from dateutil.relativedelta import relativedelta

def red_marking(sheet, tzero_date, user_inputs):
    # Define the border styles
    medium_red_border = Side(style="medium", color='FF0000')
    thin_white_border = Side(style="thin", color='FFFFFF')

    # Generate dates
    zero_date = datetime.strptime(tzero_date, "%Y-%m-%d")
    zero_date_1 = zero_date.replace(year=zero_date.year - 1)
    dates = [zero_date_1]
    for _ in range(13):
        dates.append(((dates[-1] + relativedelta(months=3)).replace(day=1) + relativedelta(months=1, days=-1)))

    # Assign dates to specific row offsets (relative to '5yr Avg' row)
    date_row_offsets = [17, 16, 15, 14, 12, 11, 10, 9, 7, 6, 5, 4, 3, 2]
    date_mapping = dict(zip(date_row_offsets, dates))

    # Convert user input dates to datetime
    above_date = pd.to_datetime(user_inputs[17], format='%Y-%m-%d', errors='coerce')
    below_date = pd.to_datetime(user_inputs[18], format='%Y-%m-%d', errors='coerce')

    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == '5yr Avg':
                avg_row = cell.row
                avg_col = cell.column

                # Find the rows for the boundary dates
                above_offset = next((offset for offset, date in date_mapping.items() if date >= above_date), None)
                below_offset = next((offset for offset, date in reversed(date_mapping.items()) if date <= below_date), None)

                if above_offset is not None and below_offset is not None:
                    start_row = avg_row - above_offset
                    end_row = avg_row - below_offset

                    # Apply borders to cells in the red box
                    for box_row in range(start_row, end_row + 1):
                        box_cell = sheet.cell(row=box_row, column=avg_col)
                        if box_row == start_row:
                            box_cell.border = Border(top=medium_red_border, left=medium_red_border, right=medium_red_border, bottom=thin_white_border)
                        elif box_row == end_row:
                            box_cell.border = Border(bottom=medium_red_border, left=medium_red_border, right=medium_red_border, top=thin_white_border)
                        else:
                            box_cell.border = Border(left=medium_red_border, right=medium_red_border, top=thin_white_border, bottom=thin_white_border)

# Usage example remains the same







for i, j, k, l, m in zip(q1, q2, q3, q4, q5):
        for a, b, c, d, e in zip(i, j, k, l, m):
            for row in sheet.iter_rows():
                for cell in row:
                    if cell.value == user_inputs[0]:
                        if (sheet.cell(row=cell.row + 2, column=cell.column).value == a and
                            sheet.cell(row=cell.row + 3, column=cell.column).value == b and
                            sheet.cell(row=cell.row + 4, column=cell.column).value == c and
                            sheet.cell(row=cell.row + 5, column=cell.column).value == d and
                            sheet.cell(row=cell.row + 6, column=cell.column).value == e):

                            # Find matching description
                            trans_variable = col_list[0]  # Assuming all columns have the same trans_variable
                            match = df[(df['Trans_variable'] == trans_variable) & (df['ISOCODES'] == Isocode)]
                            if not match.empty:
                                description = match['Description'].values[0]
                                sheet.cell(row=cell.row - 1, column=cell.column).value = description
                                sheet.cell(row=cell.row - 1, column=cell.column).font = Font(color='00000000', bold=True, size=9, name='Univers Next for HSBC Light')
                                break








def desc(sheet, isocode):
    country_list = [isocode]
    col_list = (Table_List["MEV"].loc[Table_List.Country == isocode]).tolist()

    for col in col_list:
        q1, q2, q3, q4, q5 = [], [], [], [], []
        for frame in All:
            for row in frame.itertuples():
                if row.ISOCODES == isocode:
                    if row.date == datetime.strptime(str(curr_year - 1) + "-03-31 00:00:00", "%Y-%m-%d %H:%M:%S"):
                        q1.append(round(getattr(row, col), 1))
                    elif row.date == datetime.strptime(str(curr_year - 1) + "-06-30 00:00:00", "%Y-%m-%d %H:%M:%S"):
                        q2.append(round(getattr(row, col), 1))
                    elif row.date == datetime.strptime(str(curr_year - 1) + "-09-30 00:00:00", "%Y-%m-%d %H:%M:%S"):
                        q3.append(round(getattr(row, col), 1))
                    elif row.date == datetime.strptime(str(curr_year - 1) + "-12-31 00:00:00", "%Y-%m-%d %H:%M:%S"):
                        q4.append(round(getattr(row, col), 1))
                    elif row.date == datetime.strptime(str(curr_year) + "-03-31 00:00:00", "%Y-%m-%d %H:%M:%S"):
                        q5.append(round(getattr(row, col), 1))

        for i, j, k, l, m in zip(q1, q2, q3, q4, q5):
            for a, b, c, d, e in zip(i, j, k, l, m):
                for row in sheet.iter_rows():
                    for cell in row:
                        if cell.value == user_inputs[0]:
                            match_count = 0
                            if sheet.cell(row=cell.row + 3, column=cell.column).value == a:
                                match_count += 1
                            if sheet.cell(row=cell.row + 4, column=cell.column).value == b:
                                match_count += 1
                            if sheet.cell(row=cell.row + 5, column=cell.column).value == c:
                                match_count += 1
                            if sheet.cell(row=cell.row + 6, column=cell.column).value == d:
                                match_count += 1
                            if sheet.cell(row=cell.row + 7, column=cell.column).value == e:
                                match_count += 1

                            if match_count >= 3:
                                # Find matching description
                                trans_variable = col_list[0]  # Assuming all columns have the same trans_variable
                                match = df[(df['Trans_variable'] == trans_variable) & (df['ISOCODES'] == isocode)]
                                if not match.empty:
                                    description = match['Description'].values[0]
                                    sheet.cell(row=cell.row - 1, column=cell.column).value = description
                                    sheet.cell(row=cell.row - 1, column=cell.column).font = Font(color='00000000', bold=True, size=9, name='Univers Next for HSBC Light')
                                    break  # Break the inner loop once a match is found

    return sheet






def desc(sheet, isocode):
    country_list = [isocode]
    col_list = (Table_List["MEV"].loc[Table_List.Country == isocode]).tolist()

    q1, q2, q3, q4, q5 = [], [], [], [], []
    for col in col_list:
        col_q1, col_q2, col_q3, col_q4, col_q5 = [], [], [], [], []
        for frame in All:
            for row in frame.itertuples():
                if row.ISOCODES == isocode:
                    if row.date == datetime.strptime(str(curr_year - 1) + "-03-31 00:00:00", "%Y-%m-%d %H:%M:%S"):
                        col_q1.append(round(getattr(row, col), 1))
                    elif row.date == datetime.strptime(str(curr_year - 1) + "-06-30 00:00:00", "%Y-%m-%d %H:%M:%S"):
                        col_q2.append(round(getattr(row, col), 1))
                    elif row.date == datetime.strptime(str(curr_year - 1) + "-09-30 00:00:00", "%Y-%m-%d %H:%M:%S"):
                        col_q3.append(round(getattr(row, col), 1))
                    elif row.date == datetime.strptime(str(curr_year - 1) + "-12-31 00:00:00", "%Y-%m-%d %H:%M:%S"):
                        col_q4.append(round(getattr(row, col), 1))
                    elif row.date == datetime.strptime(str(curr_year) + "-03-31 00:00:00", "%Y-%m-%d %H:%M:%S"):
                        col_q5.append(round(getattr(row, col), 1))
        q1.append(col_q1)
        q2.append(col_q2)
        q3.append(col_q3)
        q4.append(col_q4)
        q5.append(col_q5)

    for i, j, k, l, m in zip(q1, q2, q3, q4, q5):
        for a, b, c, d, e in zip(i, j, k, l, m):
            for row in sheet.iter_rows():
                for cell in row:
                    if cell.value == user_inputs[0]:
                        match_count = 0
                        if sheet.cell(row=cell.row + 3, column=cell.column).value == a:
                            match_count += 1
                        if sheet.cell(row=cell.row + 4, column=cell.column).value == b:
                            match_count += 1
                        if sheet.cell(row=cell.row + 5, column=cell.column).value == c:
                            match_count += 1
                        if sheet.cell(row=cell.row + 6, column=cell.column).value == d:
                            match_count += 1
                        if sheet.cell(row=cell.row + 7, column=cell.column).value == e:
                            match_count += 1

                        if match_count >= 3:
                            # Find matching description
                            trans_variable = col_list[0]  # Assuming all columns have the same trans_variable
                            match = df[(df['Trans_variable'] == trans_variable) & (df['ISOCODES'] == isocode)]
                            if not match.empty:
                                description = match['Description'].values[0]
                                sheet.cell(row=cell.row - 1, column=cell.column).value = description
                                sheet.cell(row=cell.row - 1, column=cell.column).font = Font(color='00000000', bold=True, size=9, name='Univers Next for HSBC Light')
                                break  # Break the inner loop once a match is found

    return sheet











scenarios_offsets = [(2, 1, user_inputs[3]), (2, 2, user_inputs[4]), (2, 3, user_inputs[5]), (2, 4, user_inputs[6]), (2, 8, user_inputs[3]), (2, 9, user_inputs[4]), (2, 10, user_inputs[5]), (2, 11, user_inputs[6])]

for r_offset, c_offset, text in scenarios_offsets:
    cell = sheet.cell(row=row + r_offset, column=col + c_offset)
    cell.value = text
    cell.alignment = Alignment(wrap_text=True, vertical='center', horizontal='center')
    cell.font = Font(color="FF0000", name='Univers Next for HSBC Light', bold=True)






















from django.shortcuts import render
from django.http import JsonResponse
import pandas as pd
import json
import numpy as np

def mi_chart(request):
    # Define row and column names
    row_names = [
        'Gross Balance ($ MM)', 'Net Balance ($ MM)', 'Net Balance Proportion S1',
        'Net Balance Proportion S2', 'Net Balance Proportion S3', 'ECL ($ MM)',
        'ECL Original ($ MM)', 'ECL Rate', 'Loss at WO ($ MM)', 'Loss at WO Original ($ MM)',
        'LIC ($ MM)', 'LIC Original ($ MM)', 'LIC overlay ($ MM)', 'LIC Rate',
        'Coverage ratio', 'PD', 'LGD', 'EAD ($ MM)', 'RWA ($ MM)', 'RWA Original ($ MM)',
        'RWA Overlay ($ MM)', 'RWA Density', 'EL($ MM)', 'EL Overlay ($ MM)', 'EL Density'
    ]
    column_names = ['T0', 'T1', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7', 'T8', 'T9', 'T10', 'T11', 'T12']

    # Create sample DataFrame
    df = pd.DataFrame(np.random.rand(len(row_names), len(column_names)),
                      index=row_names, columns=column_names)

    # Dropdown options
    dropdown_options = {
        'Organisational_unit_level_1': ['Unit 1', 'Unit 2', 'Unit 3'],
        'Organisational_unit_level_2': ['Sub-unit A', 'Sub-unit B', 'Sub-unit C'],
        'Organisational_unit_level_3': ['Team X', 'Team Y', 'Team Z'],
        'Country_of_Exposure': ['USA', 'UK', 'Germany', 'France'],
        'Asset_class': ['Equity', 'Fixed Income', 'Commodities'],
        'Product_Type': ['Type 1', 'Type 2', 'Type 3'],
        'Basel_Approach': ['Approach A', 'Approach B', 'Approach C'],
        'ST_scenario': column_names
    }

    if request.method == 'POST':
        selected_items = json.loads(request.POST.get('selectedItems'))
        selected_scenarios = selected_items.get('ST_scenario', [])

        if selected_scenarios:
            filtered_df = df[selected_scenarios]
        else:
            filtered_df = df

        table_html = filtered_df.to_html(classes='table table-striped')
        return JsonResponse({'table_html': table_html})

    else:
        context = {
            'initial_table_html': df.to_html(classes='table table-striped'),
            **{f'{key}_list': value for key, value in dropdown_options.items()},
            'ST_scenario_combo': dropdown_options['ST_scenario']
        }
        return render(request, 'mi_chart.html', context)









<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MI Chart</title>
    <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>
    {% csrf_token %}
    <style>
        .dropdowns-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        .multiselect {
            width: 200px;
        }
    </style>
</head>
<body>
    <div class="container mt-5">
        <h1>MI Chart</h1>

        <div class="dropdowns-container">
            <select class="multiselect" name="Organisational_unit_level_1" multiple>
                {% for option in Organisational_unit_level_1_list %}
                    <option value="{{ option }}">{{ option }}</option>
                {% endfor %}
            </select>
            <select class="multiselect" name="Organisational_unit_level_2" multiple>
                {% for option in Organisational_unit_level_2_list %}
                    <option value="{{ option }}">{{ option }}</option>
                {% endfor %}
            </select>
            <select class="multiselect" name="Organisational_unit_level_3" multiple>
                {% for option in Organisational_unit_level_3_list %}
                    <option value="{{ option }}">{{ option }}</option>
                {% endfor %}
            </select>
            <select class="multiselect" name="Country_of_Exposure" multiple>
                {% for option in Country_of_Exposure_list %}
                    <option value="{{ option }}">{{ option }}</option>
                {% endfor %}
            </select>
            <select class="multiselect" name="Asset_class" multiple>
                {% for option in Asset_class_list %}
                    <option value="{{ option }}">{{ option }}</option>
                {% endfor %}
            </select>
            <select class="multiselect" name="Product_Type" multiple>
                {% for option in Product_Type_list %}
                    <option value="{{ option }}">{{ option }}</option>
                {% endfor %}
            </select>
            <select class="multiselect" name="Basel_Approach" multiple>
                {% for option in Basel_Approach_list %}
                    <option value="{{ option }}">{{ option }}</option>
                {% endfor %}
            </select>
            <select class="multiselect" name="ST_scenario" multiple>
                {% for option in ST_scenario_combo %}
                    <option value="{{ option }}">{{ option }}</option>
                {% endfor %}
            </select>
        </div>
        <div id="table-container">
            {{ initial_table_html|safe }}
        </div>
    </div>
    <script>
    $(document).ready(function() {
        $(".multiselect").select2({
            placeholder: 'Select options',
            closeOnSelect: false,
            allowClear: true
        });
        function updateTable() {
            var selectedItems = {};
            $('.multiselect').each(function() {
                var dropdownName = $(this).attr('name');
                var selected = $(this).select2('data');
                selectedItems[dropdownName] = selected.map(item => item.text);
            });
            $.ajax({
                url: '{% url "mi_chart" %}',
                method: 'POST',
                data: {
                    selectedItems: JSON.stringify(selectedItems),
                    csrfmiddlewaretoken: $('input[name=csrfmiddlewaretoken]').val()
                },
                success: function(response) {
                    $('#table-container').html(response.table_html);
                },
                error: function(xhr, status, error) {
                    console.error('Error updating table:', error);
                }
            });
        }
        $('.multiselect').on('change', updateTable);
    });
    </script>
</body>
</html>












import os
import json
import pandas as pd
from django.shortcuts import render
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt

# Assume these are defined elsewhere or imported
from .utils import get_folders, get_subfolders, read_excel_files, process_lic_data, process_rwa_data, filter_dataframe, calculate_metrics

FOLDER_PATH = "path/to/your/excel/files"  # Replace with your actual path

def dashboard(request):
    folders = get_folders()
    selected_folder = request.GET.get("folder", None)
    selected_subfolder = request.GET.get("subfolder", None)
    subfolders = get_subfolders(selected_folder) if selected_folder else []

    context = {
        "folders": folders,
        "subfolders": subfolders,
        "selected_folder": selected_folder,
        "selected_subfolder": selected_subfolder,
    }
    return render(request, 'mi_templates/dashboard.html', context)

@csrf_exempt
def mi_chart(request):
    # Define row and column names
    row_names = ['Gross Balance ($ MM)', 'Net Balance ($ MM)', 'Net Balance Proportion S1', 'Net Balance Proportion S2',
                 'Net Balance Proportion S3', 'ECL ($ MM)', 'ECL Original ($ MM)', 'ECL Rate', 'Loss at WO ($ MM)',
                 'Loss at WO Original ($ MM)', 'LIC ($ MM)', 'LIC Original ($ MM)', 'LIC overlay ($ MM)', 'LIC Rate',
                 'Coverage ratio', 'PD', 'LGD', 'EAD ($ MM)', 'RWA ($ MM)', 'RWA Original ($ MM)', 'RWA Overlay ($ MM)',
                 'RWA Density', 'EL($ MM)', 'EL Overlay ($ MM)', 'EL Density']
    column_names = ['T0', 'T1', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7', 'T8', 'T9', 'T10', 'T11', 'T12']

    # Initialize DataFrames
    table_df = pd.DataFrame(index=row_names)
    table_df1 = pd.DataFrame(index=row_names, columns=column_names)

    # Get folder and subfolder from GET parameters
    selected_folder = request.GET.get("folder")
    selected_subfolder = request.GET.get("subfolder")

    if selected_folder and selected_subfolder:
        folder_path = os.path.join(FOLDER_PATH, selected_folder, selected_subfolder)
        excel_files = [f for f in os.listdir(folder_path) if f.endswith(".xlsx")]

        # Read Excel files and process data
        lic_hbap_first_run, lic_hbap_last_run, lpact_hbap_data, lic_non_hbap_first_run, lic_non_hbap_last_run, \
        lpact_non_hbap_data, rwa_hbap_first_run, rwa_hbap_last_run, rwa_non_hbap_first_run, rwa_non_hbap_last_run, \
        lic_views_previous, rwa_views_previous = read_excel_files(folder_path, excel_files)

        # Process LIC data
        lic_df = process_lic_data(lic_hbap_first_run, lic_hbap_last_run, lpact_hbap_data,
                                  lic_non_hbap_first_run, lic_non_hbap_last_run, lpact_non_hbap_data)

        # Process RWA data
        rwa_df = process_rwa_data(rwa_hbap_first_run, rwa_hbap_last_run,
                                  rwa_non_hbap_first_run, rwa_non_hbap_last_run)

        # Combine with previous views
        lic_df = pd.concat([lic_df, lic_views_previous])
        rwa_df = pd.concat([rwa_df, rwa_views_previous])

        # Standardize scenario names
        lic_df["scenario"] = lic_df["scenario"].replace('Annual cyclical scenario', 'Stress')
        rwa_df["scenario"] = rwa_df["scenario"].replace('Annual cyclical scenario', 'Stress')

        # Get unique values for dropdown options
        dropdown_options = {
            'Organisational_unit_level_1': lic_df["Organisational_unit_level_1"].unique().tolist(),
            'Organisational_unit_level_2': lic_df["Organisational_unit_level_2"].unique().tolist(),
            'Organisational_unit_level_3': lic_df["Organisational_unit_level_3"].unique().tolist(),
            'Country_of_Exposure': lic_df["Country_of_Exposure"].unique().tolist(),
            'Asset_class': lic_df["Asset_class"].unique().tolist(),
            'Product_Type': lic_df["Product_Type"].unique().tolist(),
            'Basel_Approach': lic_df["Basel_Approach"].unique().tolist(),
            'ST_scenario': [f"{st}-{scenario}" for st in lic_df['ST'].unique() for scenario in lic_df['scenario'].unique()]
        }

        if request.method == 'POST':
            selected_items = json.loads(request.POST.get('selectedItems'))
            filtered_lic_df = filter_dataframe(lic_df, selected_items)
            filtered_rwa_df = filter_dataframe(rwa_df, selected_items)

            # Calculate metrics and populate table_df1
            for st_scenario in selected_items.get('ST_scenario', []):
                st, scenario = st_scenario.split('-')
                table_df1 = calculate_metrics(filtered_lic_df, filtered_rwa_df, st, scenario, table_df1)

            # Concatenate results
            table_df = pd.concat([table_df, table_df1], axis=1)
            table_html = table_df.to_html(classes="table table-striped table-bordered", index=True)
            return JsonResponse({'table_html': table_html})
        else:
            context = {
                'initial_table_html': table_df.to_html(classes='table table-striped'),
                **dropdown_options
            }
            return render(request, 'mi_templates/mi_chart.html', context)
    else:
        # Handle case when folder or subfolder is not selected
        return render(request, 'mi_templates/error.html', {'error': 'Folder or subfolder not selected'})




















<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MI Chart</title>
    <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>
    {% csrf_token %}
    <style>
        body {
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
        }
        .dropdowns-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
        }
        .dropdown-wrapper {
            flex: 1;
            min-width: 200px;
        }
        .dropdown-label {
            font-weight: bold;
            margin-bottom: 5px;
        }
        .select2-container {
            width: 100% !important;
        }
        .select2-container--default .select2-selection--multiple {
            border-radius: 4px;
            border: 1px solid #ced4da;
        }
        .select2-container--default .select2-selection--multiple .select2-selection__choice {
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
        }
        #table-container table {
            width: 100%;
            border-collapse: collapse;
        }
        #table-container th, #table-container td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        #table-container th, #table-container .row-index {
            background-color: #B22222;
            color: white;
        }
        #table-container .row-index {
            font-weight: bold;
        }
        .table-responsive {
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <div class="container mt-5">
        <h1>MI Chart</h1>
        <div class="dropdowns-container">
            {% for dropdown in dropdowns %}
            <div class="dropdown-wrapper">
                <div class="dropdown-label">{{ dropdown.name }}</div>
                <select class="multiselect" name="{{ dropdown.name }}" multiple>
                    {% for option in dropdown.options %}
                    <option value="{{ option }}">{{ option }}</option>
                    {% endfor %}
                </select>
            </div>
            {% endfor %}
        </div>
        <div class="table-responsive" id="table-container">
            {{ initial_table_html|safe }}
        </div>
    </div>

    <script>
        $(document).ready(function() {
            $(".multiselect").select2({
                placeholder: 'Select options',
                closeOnSelect: false,
                allowClear: true
            });

            function updateTable() {
                var selectedItems = {};
                $('.multiselect').each(function() {
                    var dropdownName = $(this).attr('name');
                    var selected = $(this).select2('data');
                    selectedItems[dropdownName] = selected.map(item => item.text);
                });

                $.ajax({
                    url: '{% url "mi_chart" %}',
                    method: 'POST',
                    data: {
                        selectedItems: JSON.stringify(selectedItems),
                        csrfmiddlewaretoken: $('input[name=csrfmiddlewaretoken]').val()
                    },
                    success: function(response) {
                        $('#table-container').html(response.table_html);
                    },
                    error: function(xhr, status, error) {
                        console.error('Error updating table:', error);
                    }
                });
            }

            $('.multiselect').on('change', updateTable);
        });
    </script>
</body>
</html>






<div class="container">
    <h2>MI Chart</h2>

    <div class="row">
        {% for dropdown_name, options in dropdown_options.items %}
        <div class="col-md-3 mb-3">
            <label for="{{ dropdown_name }}">{{ dropdown_name|title|replace:'_',' ' }}</label>
            <select id="{{ dropdown_name }}" name="{{ dropdown_name }}" class="form-control select2" multiple>
                {% for option in options %}
                <option value="{{ option }}">{{ option }}</option>
                {% endfor %}
            </select>
        </div>
        {% endfor %}
    </div>

    <div id="tableContainer">
        <table id="miTable" class="table table-striped">
            <thead>
                <tr>
                    <th></th>
                    <th colspan="6" class="text-center">Base Scenario</th>
                    <th colspan="6" class="text-center">Stress Scenario</th>
                    <th colspan="6" class="text-center">Another Scenario</th>
                </tr>
                <tr>
                    <th>Metric</th>
                    <th>T0</th><th>T1</th><th>T2</th><th>T3</th><th>T4</th><th>T5</th>
                    <th>T0</th><th>T1</th><th>T2</th><th>T3</th><th>T4</th><th>T5</th>
                    <th>T0</th><th>T1</th><th>T2</th><th>T3</th><th>T4</th><th>T5</th>
                </tr>
            </thead>
            <tbody>
                <!-- Table body will be populated dynamically -->
            </tbody>
        </table>
    </div>
</div>

<style>
    .select2-container {
        width: 100% !important;
    }
    .select2-selection--multiple {
        min-height: 38px !important;
    }
    label {
        font-weight: bold;
        margin-bottom: 5px;
    }
    #miTable th, #miTable td {
        text-align: center;
        vertical-align: middle;
    }
    #miTable thead th {
        background-color: #f8f9fa;
    }
</style>

<script>
$(document).ready(function() {
    $('.select2').select2({
        placeholder: "Select options",
        allowClear: true
    });

    // AJAX call to update table based on selections
    $('select').on('change', function() {
        var selectedItems = {};
        $('select').each(function() {
            selectedItems[$(this).attr('name')] = $(this).val();
        });

        $.ajax({
            url: '{% url "mi_chart" %}',
            type: 'POST',
            data: {
                selectedItems: JSON.stringify(selectedItems),
                csrfmiddlewaretoken: '{{ csrf_token }}'
            },
            success: function(response) {
                $('#tableContainer').html(response.table_html);
            }
        });
    });
});
</script>









def mi_chart(request):
    # ... (previous code remains the same)

    if request.method == 'POST':
        selected_items = json.loads(request.POST.get('selectedItems'))
        selected_scenarios = selected_items.get('ST_scenario', [])

        if selected_scenarios:
            filtered_df = df[selected_scenarios]
        else:
            filtered_df = df

        # Create a new DataFrame with the desired structure
        new_df = pd.DataFrame(index=filtered_df.index)
        for i, scenario in enumerate(['Base Scenario', 'Stress Scenario', 'Another Scenario']):
            if i < len(selected_scenarios):
                scenario_data = filtered_df[selected_scenarios[i]].rename(columns={col: f'{scenario} {col}' for col in filtered_df.columns})
                new_df = pd.concat([new_df, scenario_data], axis=1)

        table_html = new_df.to_html(classes='table table-striped', escape=False)

        # Modify the table HTML to include merged headers
        soup = BeautifulSoup(table_html, 'html.parser')
        thead = soup.find('thead')
        new_header_row = soup.new_tag('tr')
        new_header_row.append(soup.new_tag('th'))  # Empty cell for 'Metric'
        for scenario in ['Base Scenario', 'Stress Scenario', 'Another Scenario']:
            th = soup.new_tag('th', colspan="6", class_="text-center")
            th.string = scenario
            new_header_row.append(th)
        thead.insert(0, new_header_row)

        return JsonResponse({'table_html': str(soup)})

    else:
        context = {
            'initial_table_html': df.to_html(classes='table table-striped'),
            'dropdown_options': dropdown_options
        }
        return render(request, 'mi_chart.html', context)










<div class="container">
    <h2>MI Chart</h2>

    <div class="row">
        <div class="col-md-3 mb-3">
            <label for="Organisational_unit_level_1">Organisational Unit Level 1</label>
            <select id="Organisational_unit_level_1" name="Organisational_unit_level_1" class="form-control select2" multiple>
                {% for option in Organisational_unit_level_1_list %}
                <option value="{{ option }}">{{ option }}</option>
                {% endfor %}
            </select>
        </div>

        <div class="col-md-3 mb-3">
            <label for="Organisational_unit_level_2">Organisational Unit Level 2</label>
            <select id="Organisational_unit_level_2" name="Organisational_unit_level_2" class="form-control select2" multiple>
                {% for option in Organisational_unit_level_2_list %}
                <option value="{{ option }}">{{ option }}</option>
                {% endfor %}
            </select>
        </div>

        <div class="col-md-3 mb-3">
            <label for="Organisational_unit_level_3">Organisational Unit Level 3</label>
            <select id="Organisational_unit_level_3" name="Organisational_unit_level_3" class="form-control select2" multiple>
                {% for option in Organisational_unit_level_3_list %}
                <option value="{{ option }}">{{ option }}</option>
                {% endfor %}
            </select>
        </div>

        <div class="col-md-3 mb-3">
            <label for="Country_of_Exposure">Country of Exposure</label>
            <select id="Country_of_Exposure" name="Country_of_Exposure" class="form-control select2" multiple>
                {% for option in Country_of_Exposure_list %}
                <option value="{{ option }}">{{ option }}</option>
                {% endfor %}
            </select>
        </div>

        <div class="col-md-3 mb-3">
            <label for="Asset_class">Asset Class</label>
            <select id="Asset_class" name="Asset_class" class="form-control select2" multiple>
                {% for option in Asset_class_list %}
                <option value="{{ option }}">{{ option }}</option>
                {% endfor %}
            </select>
        </div>

        <div class="col-md-3 mb-3">
            <label for="Product_Type">Product Type</label>
            <select id="Product_Type" name="Product_Type" class="form-control select2" multiple>
                {% for option in Product_Type_list %}
                <option value="{{ option }}">{{ option }}</option>
                {% endfor %}
            </select>
        </div>

        <div class="col-md-3 mb-3">
            <label for="Basel_Approach">Basel Approach</label>
            <select id="Basel_Approach" name="Basel_Approach" class="form-control select2" multiple>
                {% for option in Basel_Approach_list %}
                <option value="{{ option }}">{{ option }}</option>
                {% endfor %}
            </select>
        </div>

        <div class="col-md-3 mb-3">
            <label for="ST_scenario">ST Scenario</label>
            <select id="ST_scenario" name="ST_scenario" class="form-control select2" multiple>
                {% for option in ST_scenario_combo %}
                <option value="{{ option }}">{{ option }}</option>
                {% endfor %}
            </select>
        </div>
    </div>

    <div id="tableContainer">
        <table id="miTable" class="table table-striped">
            <thead>
                <tr>
                    <th></th>
                    <th colspan="6" class="text-center">Base Scenario</th>
                    <th colspan="6" class="text-center">Stress Scenario</th>
                    <th colspan="6" class="text-center">Another Scenario</th>
                </tr>
                <tr>
                    <th>Metric</th>
                    <th>T0</th><th>T1</th><th>T2</th><th>T3</th><th>T4</th><th>T5</th>
                    <th>T0</th><th>T1</th><th>T2</th><th>T3</th><th>T4</th><th>T5</th>
                    <th>T0</th><th>T1</th><th>T2</th><th>T3</th><th>T4</th><th>T5</th>
                </tr>
            </thead>
            <tbody>
                <!-- Table body will be populated dynamically -->
            </tbody>
        </table>
    </div>
</div>

<style>
    .select2-container {
        width: 100% !important;
    }
    .select2-selection--multiple {
        min-height: 38px !important;
    }
    label {
        font-weight: bold;
        margin-bottom: 5px;
    }
    #miTable th, #miTable td {
        text-align: center;
        vertical-align: middle;
    }
    #miTable thead th {
        background-color: #f8f9fa;
    }
</style>

<script>
$(document).ready(function() {
    $('.select2').select2({
        placeholder: "Select options",
        allowClear: true
    });

    // AJAX call to update table based on selections
    $('select').on('change', function() {
        var selectedItems = {};
        $('select').each(function() {
            selectedItems[$(this).attr('name')] = $(this).val();
        });

        $.ajax({
            url: '{% url "mi_chart" %}',
            type: 'POST',
            data: {
                selectedItems: JSON.stringify(selectedItems),
                csrfmiddlewaretoken: '{{ csrf_token }}'
            },
            success: function(response) {
                $('#tableContainer').html(response.table_html);
            }
        });
    });
});
</script>














<div class="dashboard">
    <div class="dropdown-container">
        <div class="dropdown-wrapper">
            <label for="Organisational_unit_level_1">Organisational Unit Level 1</label>
            <select id="Organisational_unit_level_1" name="Organisational_unit_level_1" class="custom-select" multiple>
                {% for option in Organisational_unit_level_1_list %}
                <option value="{{ option }}">{{ option }}</option>
                {% endfor %}
            </select>
        </div>
        <div class="dropdown-wrapper">
            <label for="Organisational_unit_level_2">Organisational Unit Level 2</label>
            <select id="Organisational_unit_level_2" name="Organisational_unit_level_2" class="custom-select" multiple>
                {% for option in Organisational_unit_level_2_list %}
                <option value="{{ option }}">{{ option }}</option>
                {% endfor %}
            </select>
        </div>
        <div class="dropdown-wrapper">
            <label for="Organisational_unit_level_3">Organisational Unit Level 3</label>
            <select id="Organisational_unit_level_3" name="Organisational_unit_level_3" class="custom-select" multiple>
                {% for option in Organisational_unit_level_3_list %}
                <option value="{{ option }}">{{ option }}</option>
                {% endfor %}
            </select>
        </div>
        <div class="dropdown-wrapper">
            <label for="Country_of_Exposure">Country of Exposure</label>
            <select id="Country_of_Exposure" name="Country_of_Exposure" class="custom-select" multiple>
                {% for option in Country_of_Exposure_list %}
                <option value="{{ option }}">{{ option }}</option>
                {% endfor %}
            </select>
        </div>
        <div class="dropdown-wrapper">
            <label for="Asset_class">Asset Class</label>
            <select id="Asset_class" name="Asset_class" class="custom-select" multiple>
                {% for option in Asset_class_list %}
                <option value="{{ option }}">{{ option }}</option>
                {% endfor %}
            </select>
        </div>
        <div class="dropdown-wrapper">
            <label for="Product_Type">Product Type</label>
            <select id="Product_Type" name="Product_Type" class="custom-select" multiple>
                {% for option in Product_Type_list %}
                <option value="{{ option }}">{{ option }}</option>
                {% endfor %}
            </select>
        </div>
        <div class="dropdown-wrapper">
            <label for="Basel_Approach">Basel Approach</label>
            <select id="Basel_Approach" name="Basel_Approach" class="custom-select" multiple>
                {% for option in Basel_Approach_list %}
                <option value="{{ option }}">{{ option }}</option>
                {% endfor %}
            </select>
        </div>
        <div class="dropdown-wrapper">
            <label for="ST_scenario">ST Scenario</label>
            <select id="ST_scenario" name="ST_scenario" class="custom-select" multiple>
                {% for option in ST_scenario_combo %}
                <option value="{{ option }}">{{ option }}</option>
                {% endfor %}
            </select>
        </div>
    </div>

    <div id="tableContainer">
        <table id="miTable" class="table table-striped">
            <thead>
                <tr>
                    <th></th>
                    <th colspan="6" class="text-center">Base Scenario</th>
                    <th colspan="6" class="text-center">Stress Scenario</th>
                    <th colspan="6" class="text-center">Another Scenario</th>
                </tr>
                <tr>
                    <th>Metric</th>
                    <th>T0</th><th>T1</th><th>T2</th><th>T3</th><th>T4</th><th>T5</th>
                    <th>T0</th><th>T1</th><th>T2</th><th>T3</th><th>T4</th><th>T5</th>
                    <th>T0</th><th>T1</th><th>T2</th><th>T3</th><th>T4</th><th>T5</th>
                </tr>
            </thead>
            <tbody>
                <!-- Table body will be populated dynamically -->
            </tbody>
        </table>
    </div>
</div>

<style>
    .dashboard {
        display: flex;
        flex-direction: column;
        height: 100vh;
        padding: 20px;
    }

    .dropdown-container {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
        margin-bottom: 20px;
    }

    .dropdown-wrapper {
        flex: 1;
        min-width: 200px;
    }

    label {
        display: block;
        margin-bottom: 5px;
        font-weight: bold;
    }

    .custom-select {
        width: 100%;
        padding: 10px;
        border: 2px solid #d63031;
        border-radius: 5px;
        background-color: #fab1a0;
        color: #2d3436;
        transition: all 0.3s ease;
    }

    .custom-select:focus {
        border-color: #e17055;
        background-color: #ff7675;
    }

    .custom-select option {
        background-color: #fff;
        color: #2d3436;
    }

    #tableContainer {
        flex-grow: 1;
        overflow-y: auto;
    }

    #miTable {
        width: 100%;
    }

    #miTable th, #miTable td {
        text-align: center;
        vertical-align: middle;
    }

    #miTable thead th {
        background-color: #f8f9fa;
        position: sticky;
        top: 0;
    }
</style>

<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>
<link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />

<script>
$(document).ready(function() {
    $('.custom-select').select2({
        placeholder: "Select options",
        allowClear: true,
        theme: "classic"
    });

    // AJAX call to update table based on selections
    $('.custom-select').on('change', function() {
        var selectedItems = {};
        $('.custom-select').each(function() {
            selectedItems[$(this).attr('name')] = $(this).val();
        });

        $.ajax({
            url: '{% url "mi_chart" %}',
            type: 'POST',
            data: {
                selectedItems: JSON.stringify(selectedItems),
                csrfmiddlewaretoken: '{{ csrf_token }}'
            },
            success: function(response) {
                $('#tableContainer').html(response.table_html);
            }
        });
    });
});
</script>





















<style>
  /* ... (previous styles remain unchanged) ... */

  .dropdown-wrapper {
    display: flex;
    flex-direction: column;
    margin-right: 40px;
    width: 300px;
  }

  .dropdown-label {
    font-size: 14px;
    font-weight: bold;
    margin-bottom: 5px;
    color: #333;
  }

  .multiselect {
    width: 100%;
    padding: 12px 15px;
    font-size: 16px;
    border: 1px solid #ccc;
    border-radius: 5px;
    background-color: #fff;
    color: #333;
    outline: none;
    transition: border-color 0.3s ease;
  }

  .multiselect:focus {
    border-color: #4a90e2;
    box-shadow: 0 0 5px rgba(74, 144, 226, 0.5);
  }

  /* ... (remaining styles unchanged) ... */
</style>

<div class="dashboard">
  <div class="container mt-5">
    <h1>MI Chart</h1>
    <div class="dropdowns-container">
      <div class="dropdown-wrapper">
        <label class="dropdown-label" for="Organisational_unit_level_1">Organisational Unit Level 1</label>
        <select class="multiselect" name="Organisational_unit_level_1" multiple>
          {% for option in Organisational_unit_level_1_list %}
            <option value="{{ option }}">{{ option }}</option>
          {% endfor %}
        </select>
      </div>

      <div class="dropdown-wrapper">
        <label class="dropdown-label" for="Organisational_unit_level_2">Organisational Unit Level 2</label>
        <select class="multiselect" name="Organisational_unit_level_2" multiple>
          {% for option in Organisational_unit_level_2_list %}
            <option value="{{ option }}">{{ option }}</option>
          {% endfor %}
        </select>
      </div>

      <div class="dropdown-wrapper">
        <label class="dropdown-label" for="Organisational_unit_level_3">Organisational Unit Level 3</label>
        <select class="multiselect" name="Organisational_unit_level_3" multiple>
          {% for option in Organisational_unit_level_3_list %}
            <option value="{{ option }}">{{ option }}</option>
          {% endfor %}
        </select>
      </div>

      <div class="dropdown-wrapper">
        <label class="dropdown-label" for="Country_of_Exposure">Country of Exposure</label>
        <select class="multiselect" name="Country_of_Exposure" multiple>
          {% for option in Country_of_Exposure_list %}
            <option value="{{ option }}">{{ option }}</option>
          {% endfor %}
        </select>
      </div>
    </div>
  </div>
</div>









<style>
  /* ... (previous styles remain unchanged) ... */

  .dropdowns-container {
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    align-items: flex-start;
    overflow-x: auto;
    white-space: nowrap;
    padding: 15px 0;
    margin: 35px 0;
  }

  .dropdown-wrapper {
    display: inline-block;
    vertical-align: top;
    margin-right: 20px;
    width: 250px;
    min-width: 250px;
  }

  .dropdown-label {
    font-size: 14px;
    font-weight: bold;
    margin-bottom: 5px;
    color: #333;
    white-space: normal;
  }

  .multiselect {
    width: 100%;
    padding: 12px 15px;
    font-size: 16px;
    border: 1px solid #ccc;
    border-radius: 5px;
    background-color: #fff;
    color: #333;
    outline: none;
    transition: border-color 0.3s ease;
  }

  .multiselect:focus {
    border-color: #4a90e2;
    box-shadow: 0 0 5px rgba(74, 144, 226, 0.5);
  }

  /* ... (remaining styles unchanged) ... */
</style>

<div class="dashboard">
  <div class="container mt-5">
    <h1>MI Chart</h1>
    <div class="dropdowns-container">
      <div class="dropdown-wrapper">
        <label class="dropdown-label" for="Organisational_unit_level_1">Organisational Unit Level 1</label>
        <select class="multiselect" name="Organisational_unit_level_1" multiple>
          {% for option in Organisational_unit_level_1_list %}
            <option value="{{ option }}">{{ option }}</option>
          {% endfor %}
        </select>
      </div>

      <div class="dropdown-wrapper">
        <label class="dropdown-label" for="Organisational_unit_level_2">Organisational Unit Level 2</label>
        <select class="multiselect" name="Organisational_unit_level_2" multiple>
          {% for option in Organisational_unit_level_2_list %}
            <option value="{{ option }}">{{ option }}</option>
          {% endfor %}
        </select>
      </div>

      <div class="dropdown-wrapper">
        <label class="dropdown-label" for="Organisational_unit_level_3">Organisational Unit Level 3</label>
        <select class="multiselect" name="Organisational_unit_level_3" multiple>
          {% for option in Organisational_unit_level_3_list %}
            <option value="{{ option }}">{{ option }}</option>
          {% endfor %}
        </select>
      </div>

      <div class="dropdown-wrapper">
        <label class="dropdown-label" for="Country_of_Exposure">Country of Exposure</label>
        <select class="multiselect" name="Country_of_Exposure" multiple>
          {% for option in Country_of_Exposure_list %}
            <option value="{{ option }}">{{ option }}</option>
          {% endfor %}
        </select>
      </div>
    </div>
  </div>
</div>





















<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MI Chart</title>
    <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>
    {% csrf_token %}
    <style>
        body {
            background-color: #87CEEB;
            font-family: Arial, sans-serif;
            overflow-x: hidden;
        }
        .logo {
            position: absolute;
            top: 0.1px;
            right: 10px;
            width: 90px;
        }
        .dropdowns-container {
            display: flex;
            flex-wrap: nowrap;
            overflow-x: auto;
            padding: 15px 0;
            margin: 35px 0;
        }
        .dropdown-wrapper {
            flex: 0 0 auto;
            width: 250px;
            margin-right: 20px;
        }
        .dropdown-label {
            display: block;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 5px;
            color: #333;
        }
        .multiselect {
            width: 100%;
            padding: 10px 15px;
            font-size: 16px;
            border: 1px solid #ccc;
            border-radius: 5px;
            background-color: #fff;
            color: #333;
            outline: none;
            transition: border-color 0.3s ease;
        }
        .multiselect:focus {
            border-color: #4a90e2;
            box-shadow: 0 0 5px rgba(74, 144, 226, 0.5);
        }
        .dashboard {
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding: 20px;
        }
        .select2-container {
            width: 100% !important;
        }
        .select2-container--default .select2-selection--multiple {
            border-radius: 15px;
        }
        .select2-container--default .select2-selection--multiple .select2-selection__choice {
            background-color: #A9A9A9;
            width: 200%;
            color: white;
            border: 5px solid #A9A9A9;
            border-radius: 50px;
            cursor: default;
            float: left;
            margin-right: 5px;
            margin-top: 5px;
            padding: 0 5px;
        }
        .select2-container--default .select2-selection--multiple .select2-selection__rendered {
            background-color: #008B8B;
            border-radius: 55px;
            padding: 15px;
        }
        .select2-container--default.select2-container--focus .select2-selection--multiple {
            border-color: #A9A9A9;
        }
        #selectedItems {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #A9A9A9;
            border-radius: 5px;
            background-color: #fff;
        }
        .select2-container--default .select2-selection--multiple .select2-search__field::placeholder {
            color: white;
            font-weight: bold;
        }
        #table-container table {
            width: 200%;
            border-collapse: collapse;
        }
        #table-container th, #table-container td {
            border: 4px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        #table-container th, #table-container .row-index {
            background-color: #B22222;
            color: white;
        }
        #table-container .row-index {
            font-weight: bold;
        }
        .table-responsive {
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <div class="dashboard">
        <div class="container mt-5">
            <h1>MI Chart</h1>
            <div class="dropdowns-container">
                <div class="dropdown-wrapper">
                    <label class="dropdown-label" for="Organisational_unit_level_1">Organisational Unit Level 1</label>
                    <select class="multiselect" name="Organisational_unit_level_1" multiple>
                        {% for option in Organisational_unit_level_1_list %}
                            <option value="{{ option }}">{{ option }}</option>
                        {% endfor %}
                    </select>
                </div>

                <div class="dropdown-wrapper">
                    <label class="dropdown-label" for="Organisational_unit_level_2">Organisational Unit Level 2</label>
                    <select class="multiselect" name="Organisational_unit_level_2" multiple>
                        {% for option in Organisational_unit_level_2_list %}
                            <option value="{{ option }}">{{ option }}</option>
                        {% endfor %}
                    </select>
                </div>

                <div class="dropdown-wrapper">
                    <label class="dropdown-label" for="Organisational_unit_level_3">Organisational Unit Level 3</label>
                    <select class="multiselect" name="Organisational_unit_level_3" multiple>
                        {% for option in Organisational_unit_level_3_list %}
                            <option value="{{ option }}">{{ option }}</option>
                        {% endfor %}
                    </select>
                </div>

                <div class="dropdown-wrapper">
                    <label class="dropdown-label" for="Country_of_Exposure">Country of Exposure</label>
                    <select class="multiselect" name="Country_of_Exposure" multiple>
                        {% for option in Country_of_Exposure_list %}
                            <option value="{{ option }}">{{ option }}</option>
                        {% endfor %}
                    </select>
                </div>

                <div class="dropdown-wrapper">
                    <label class="dropdown-label" for="Asset_class">Asset Class</label>
                    <select class="multiselect" name="Asset_class" multiple>
                        {% for option in Asset_class_list %}
                            <option value="{{ option }}">{{ option }}</option>
                        {% endfor %}
                    </select>
                </div>

                <div class="dropdown-wrapper">
                    <label class="dropdown-label" for="Product_Type">Product Type</label>
                    <select class="multiselect" name="Product_Type" multiple>
                        {% for option in Product_Type_list %}
                            <option value="{{ option }}">{{ option }}</option>
                        {% endfor %}
                    </select>
                </div>

                <div class="dropdown-wrapper">
                    <label class="dropdown-label" for="Basel_Approach">Basel Approach</label>
                    <select class="multiselect" name="Basel_Approach" multiple>
                        {% for option in Basel_Approach_list %}
                            <option value="{{ option }}">{{ option }}</option>
                        {% endfor %}
                    </select>
                </div>

                <div class="dropdown-wrapper">
                    <label class="dropdown-label" for="ST_scenario">ST Scenario</label>
                    <select class="multiselect" name="ST_scenario" multiple>
                        {% for option in ST_scenario_combo %}
                            <option value="{{ option }}">{{ option }}</option>
                        {% endfor %}
                    </select>
                </div>
            </div>

            <div class="table-responsive" id="table-container">
                {{ initial_table_html|safe }}
            </div>
        </div>
    </div>

    <script>
        $(document).ready(function() {
            $(".multiselect").select2({
                placeholder: "Select options",
                closeOnSelect: false,
                allowClear: true
            });

            function updateTable() {
                var selectedItems = {};
                $('.multiselect').each(function() {
                    var dropdownName = $(this).attr('name');
                    var selected = $(this).select2("data");
                    selectedItems[dropdownName] = selected.map(item => item.text);
                });

                $.ajax({
                    url: "{% url 'mi_chart' %}",
                    method: "POST",
                    data: {
                        selectedItems: JSON.stringify(selectedItems),
                        csrfmiddlewaretoken: $('input[name=csrfmiddlewaretoken]').val()
                    },
                    success: function(response) {
                        $('#table-container').html(response.table_html);
                    },
                    error: function(xhr, status, error) {
                        console.error("Error updating table:", error);
                    }
                });
            }

            $('.multiselect').on('change', updateTable);
        });
    </script>
</body>
</html>













# After creating table_df1 for each scenario, but before converting to HTML

# Create a list to store DataFrames for each scenario
scenario_dfs = []

for st, scenario in list1:
    # Your existing code to create table_df1 for each scenario
    # ...

    # Rename columns to include the scenario
    table_df1.columns = pd.MultiIndex.from_product([[f"{st}-{scenario}"], table_df1.columns])
    scenario_dfs.append(table_df1)

# Combine all scenario DataFrames
table_df = pd.concat(scenario_dfs, axis=1)

# Create the top-level header for ST_scenarios
st_scenario_header = pd.MultiIndex.from_product([
    [f"{st}-{scenario.split('-')[0]}" for st, scenario in list1],
    [''] * len(column_names)
])

# Combine the ST_scenario header with the existing column names
table_df.columns = pd.MultiIndex.from_arrays([
    st_scenario_header,
    table_df.columns.get_level_values(1)
])

# Convert to HTML
table_html = table_df.to_html(classes="table table-striped table-bordered", index=True)

# Modify the HTML to merge cells in the top header row
from bs.BeautifulSoup import BeautifulSoup

soup = BeautifulSoup(table_html, 'html.parser')
header_row = soup.find('thead').find_all('tr')[0]
current_scenario = None
current_colspan = 0

for th in header_row.find_all('th')[1:]:  # Skip the first th (index)
    if th.string != '':
        if current_scenario:
            current_scenario['colspan'] = str(current_colspan)
        current_scenario = th
        current_colspan = 1
    else:
        th.decompose()
        current_colspan += 1

if current_scenario:
    current_scenario['colspan'] = str(current_colspan)

# Convert back to string
table_html = str(soup)

return JsonResponse({'table_html': table_html})










if request.method == 'POST':
    selected_items = json.loads(request.POST.get('selectedItems'))
    Product_Type_selected = selected_items.get('Product_Type', [])
    Basel_Approach_selected = selected_items.get('Basel_Approach', [])
    ST_scenario_selected = selected_items.get('ST_scenario', [])

    list1 = []
    for st in ST_scenario_selected:
        list1.append(st.split('-'))

    table_df = pd.DataFrame(index=row_names)

    for x in list1:
        scenario = x[1]
        projection_period_range = [8]
        for col in column_names:
            if col == "T1":
                projection_period_range = [1, 2, 3, 4]
            # ... (rest of your existing code for creating table_df1)

        if table_df1.loc["EAD ($ MM)"][col] == 0:
            table_df1.loc["EL Density"][col] = 0
        else:
            table_df1.loc["EL Density"][col] = str(round((table_df1.loc["EL($ MM)"][col] / table_df1.loc["EAD ($ MM)"][col]) * 100, 2)) + "%"

        # Create a MultiIndex for columns with ST scenario as the top level
        table_df1.columns = pd.MultiIndex.from_product([[scenario], table_df1.columns])

        table_df = pd.concat([table_df, table_df1], axis=1)

    # Create a new top-level index with 'ST_scenario_selected' spanning all columns
    new_index = pd.MultiIndex.from_product([['ST_scenario_selected'], table_df.columns.get_level_values(0).unique()])
    table_df.columns = new_index.append(table_df.columns)

    # Sort the column levels to put 'ST_scenario_selected' at the top
    table_df = table_df.sort_index(axis=1, level=0)

    table_html = table_df.to_html(classes="table table-striped table-bordered", index=True)

    return JsonResponse({"table_html": table_html})
else:
    # ... (rest of your existing code for the GET request)





























if request.method == 'POST':
    selected_items = json.loads(request.POST.get('selectedItems'))
    Product_Type_selected = selected_items.get('Product_Type', [])
    Basel_Approach_selected = selected_items.get('Basel_Approach', [])
    ST_scenario_selected = selected_items.get('ST_scenario', [])

    list1 = []
    for st in ST_scenario_selected:
        list1.append(st.split('-'))

    table_df = pd.DataFrame(index=row_names)

    for x in list1:
        scenario = x[1]
        projection_period_range = [8]
        for col in column_names:
            if col == "T1":
                projection_period_range = [1, 2, 3, 4]
            # ... (rest of your existing code for creating table_df1)

        if table_df1.loc["EAD ($ MM)"][col] == 0:
            table_df1.loc["EL Density"][col] = 0
        else:
            table_df1.loc["EL Density"][col] = str(round((table_df1.loc["EL($ MM)"][col] / table_df1.loc["EAD ($ MM)"][col]) * 100, 2)) + "%"

        # Create a MultiIndex for columns with ST scenario as the top level
        table_df1.columns = pd.MultiIndex.from_product([[scenario], table_df1.columns])

        table_df = pd.concat([table_df, table_df1], axis=1)

    # Create a new top-level index for 'ST_scenario_selected'
    top_level = ['ST_scenario_selected'] * len(table_df.columns)
    mid_level = table_df.columns.get_level_values(0)
    bottom_level = table_df.columns.get_level_values(1)

    # Create new MultiIndex
    new_columns = pd.MultiIndex.from_arrays([top_level, mid_level, bottom_level])
    table_df.columns = new_columns

    table_html = table_df.to_html(classes="table table-striped table-bordered", index=True)

    return JsonResponse({"table_html": table_html})
else:
    # ... (rest of your existing code for the GET request)if request.method == 'POST':
    selected_items = json.loads(request.POST.get('selectedItems'))
    Product_Type_selected = selected_items.get('Product_Type', [])
    Basel_Approach_selected = selected_items.get('Basel_Approach', [])
    ST_scenario_selected = selected_items.get('ST_scenario', [])

    list1 = []
    for st in ST_scenario_selected:
        list1.append(st.split('-'))

    table_df = pd.DataFrame(index=row_names)

    for x in list1:
        scenario = x[1]
        projection_period_range = [8]
        for col in column_names:
            if col == "T1":
                projection_period_range = [1, 2, 3, 4]
            # ... (rest of your existing code for creating table_df1)

        if table_df1.loc["EAD ($ MM)"][col] == 0:
            table_df1.loc["EL Density"][col] = 0
        else:
            table_df1.loc["EL Density"][col] = str(round((table_df1.loc["EL($ MM)"][col] / table_df1.loc["EAD ($ MM)"][col]) * 100, 2)) + "%"

        # Create a MultiIndex for columns with ST scenario as the top level
        table_df1.columns = pd.MultiIndex.from_product([[scenario], table_df1.columns])

        table_df = pd.concat([table_df, table_df1], axis=1)

    # Create a new top-level index for 'ST_scenario_selected'
    top_level = ['ST_scenario_selected'] * len(table_df.columns)
    mid_level = table_df.columns.get_level_values(0)
    bottom_level = table_df.columns.get_level_values(1)

    # Create new MultiIndex
    new_columns = pd.MultiIndex.from_arrays([top_level, mid_level, bottom_level])
    table_df.columns = new_columns

    table_html = table_df.to_html(classes="table table-striped table-bordered", index=True)

    return JsonResponse({"table_html": table_html})
else:
    # ... (rest of your existing code for the GET request)







    table_df.columns = pd.MultiIndex.from_product([['ST_scenario_selected'], table_df.columns.get_level_values(0), table_df.columns.get_level_values(1)])
