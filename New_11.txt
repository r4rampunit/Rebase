def complexscoreval(self):
    """
    Complex score evaluation function for model validation
    Performs backtesting and generates Excel output with multiple sheets
    """
    import pandas as pd
    import numpy as np
    from dateutil import relativedelta
    from sklearn.metrics import mean_absolute_percentage_error
    import warnings
    warnings.filterwarnings('ignore')
    
    # Date conversions
    actualsStartDateD = self.str2date(self.actualsStartDate)
    inSample_startDate = self.str2date(self.cycleInfo['inSample_startDate'])
    inSample_endDate = self.str2date(self.cycleInfo['inSample_endDate'])
    outSample_startDate = self.str2date(self.cycleInfo['outSample_startDate'])
    J0DateD = self.str2date(self.cycleInfo['J0Date'])
    endProjectionsDateD = self.str2date(self.cycleInfo['endProjectionsDate'])
    
    # Variable setup
    dependentTransform = self.depVarName + self.depVarTransform
    depVarData_1 = self.depVarData[[self.depVarName]]
    
    # Transform variables
    transformedVariables = []
    for var in range(len(self.indepVarNames)):
        transformedVariables.append(self.indepVarNames[var] + self.indepVarTransform[var])
    
    # Build model data
    model_build_df = pd.merge(self.depVarData, 
                             self.cycleInfo['MVData'][0][self.indepVarNames], 
                             how='left', left_index=True, right_index=True)
    
    # Add month column for quarterly filtering
    model_build_df['month'] = pd.DatetimeIndex(model_build_df.index).month
    
    # Filter for quarterly data if needed
    if self.outputDataFormat.lower() == 'quarterly':
        model_build_df = model_build_df[model_build_df['month'].isin([3, 6, 9, 12])]
    
    # Remove month column
    model_build_df = model_build_df.drop(['month'], axis=1)
    
    # Calculate market share
    indep_var = self.indepVarNames[0]  # Assuming first independent variable
    model_build_df['market_share'] = model_build_df[self.depVarName] / (model_build_df[indep_var] * 10**9)
    
    # Get baseline market share (recent 4 quarters before J0Date)
    j0_idx = model_build_df.index.get_loc(J0DateD, method='ffill')
    baseline_start_idx = max(0, j0_idx - 3)
    baseline_mkt_share = model_build_df.iloc[baseline_start_idx:j0_idx+1]['market_share'].mean()
    
    # Generate predictions for out-of-sample period
    out_sample_data = model_build_df.loc[outSample_startDate:endProjectionsDateD].copy()
    out_sample_data['pred'] = baseline_mkt_share * out_sample_data[indep_var] * 10**9
    
    # Calculate absolute percentage error
    out_sample_data['ape'] = np.abs((out_sample_data['pred'] / out_sample_data[self.depVarName]) - 1)
    
    # Get 9-quarter projection period (from J0Date)
    j0_out_idx = out_sample_data.index.get_loc(J0DateD, method='ffill')
    nine_q_end_idx = min(len(out_sample_data) - 1, j0_out_idx + 8)  # 9 quarters including J0Date
    
    nine_q_data = out_sample_data.iloc[j0_out_idx:nine_q_end_idx+1]
    
    # Calculate metrics
    forecast_sum = nine_q_data['pred'].sum()
    actual_sum = nine_q_data[self.depVarName].sum()
    accuracy_test = abs(forecast_sum / actual_sum - 1) if actual_sum != 0 else np.nan
    
    # Correlation calculations
    # Full series correlation
    correlation_full = model_build_df[self.depVarName].corr(model_build_df[indep_var])
    
    # In-sample correlation (model development period)
    in_sample_data = model_build_df.loc[inSample_startDate:inSample_endDate]
    correlation_in = in_sample_data[self.depVarName].corr(in_sample_data[indep_var])
    
    # Correlation change
    correlation_change = (correlation_full / correlation_in - 1) if correlation_in != 0 else np.nan
    
    # Determine RAG status
    def determine_rag_status(accuracy_test, correlation_change, model_type="complex"):
        """Determine RAG status based on accuracy and correlation"""
        correl_rag = "Green"
        if abs(correlation_change) > 0.5:
            correl_rag = "Red"
        elif abs(correlation_change) > 0.3:
            correl_rag = "Amber"
        
        stat_rag = "Green"
        if accuracy_test > 0.4:
            stat_rag = "Red"
        elif accuracy_test > 0.25:
            stat_rag = "Amber"
        
        if correl_rag == "Green" and stat_rag == "Green":
            final_rag = "Green"
        elif correl_rag == "Red" or stat_rag == "Red":
            final_rag = "Red"
        else:
            final_rag = "Amber"
        
        return correl_rag, stat_rag, final_rag
    
    correl_rag, stat_rag, final_rag = determine_rag_status(accuracy_test, correlation_change)
    
    # Create output DataFrames
    
    # 1. Test Results sheet
    test_results_df = pd.DataFrame({
        'GMIS_ID': [self.GMIS],
        'Dependent_Variable_Name': [self.depVarName],
        'Independent_Variable_Names': [str(self.indepVarNames)],
        'Model_Score_Methodology': [self.modelScoremethodology],
        'Correlation_Change': [correlation_change],
        'Accuracy_Test': [accuracy_test]
    })
    
    # 2. Model Specifications sheet
    model_specs_df = pd.DataFrame({
        'Variable': ['GMIS_ID', 'Dependent_Variable_Name', 'Independent_Variable_Names', 
                    'Model_Score_Methodology', 'Filename'],
        'Value': [self.GMIS, self.depVarName, str(self.indepVarNames), 
                 self.modelScoremethodology, f"{self.GMIS}_{self.depVarName}_validation.xlsx"]
    })
    
    # 3. RAG Assessment sheet
    rag_df = pd.DataFrame({
        'Metric': ['Correlation_RAG', 'Accuracy_RAG', 'Assessment_RAG'],
        'Status': [correl_rag, stat_rag, final_rag]
    })
    
    # 4. Detailed Calculations sheet (like your Excel logic)
    detailed_calc_df = model_build_df.copy()
    detailed_calc_df['market_share'] = detailed_calc_df[self.depVarName] / (detailed_calc_df[indep_var] * 10**9)
    
    # Add predictions and APE for out-of-sample period
    detailed_calc_df['forecast'] = np.nan
    detailed_calc_df['ape'] = np.nan
    
    # Fill forecasts for out-of-sample period
    out_sample_mask = (detailed_calc_df.index >= outSample_startDate) & (detailed_calc_df.index <= endProjectionsDateD)
    detailed_calc_df.loc[out_sample_mask, 'forecast'] = (baseline_mkt_share * 
                                                        detailed_calc_df.loc[out_sample_mask, indep_var] * 10**9)
    detailed_calc_df.loc[out_sample_mask, 'ape'] = np.abs((detailed_calc_df.loc[out_sample_mask, 'forecast'] / 
                                                          detailed_calc_df.loc[out_sample_mask, self.depVarName]) - 1)
    
    # Add summary statistics
    summary_stats = pd.DataFrame({
        'Metric': ['Forecast_Sum_9Q', 'Actual_Sum_9Q', 'Accuracy_Test', 
                  'Correlation_Full', 'Correlation_InSample', 'Correlation_Change',
                  'Baseline_Market_Share'],
        'Value': [forecast_sum, actual_sum, accuracy_test,
                 correlation_full, correlation_in, correlation_change,
                 baseline_mkt_share]
    })
    
    # Create filename
    filename = f"{self.GMIS}_{self.depVarName}_validation_{pd.Timestamp.now().strftime('%Y%m%d')}.xlsx"
    
    # Write to Excel with multiple sheets
    try:
        with pd.ExcelWriter(filename, engine='openpyxl') as writer:
            # Write all sheets
            rag_df.to_excel(writer, sheet_name='RAG', index=False)
            test_results_df.to_excel(writer, sheet_name='Test_Results', index=False)
            model_specs_df.to_excel(writer, sheet_name='Model_Specifications', index=False)
            detailed_calc_df.to_excel(writer, sheet_name='Detailed_Calculations', index=True)
            summary_stats.to_excel(writer, sheet_name='Summary_Statistics', index=False)
        
        print(f"Validation results saved to: {filename}")
        
    except Exception as e:
        print(f"Error saving Excel file: {str(e)}")
    
    # Create return dictionary similar to your original function structure
    model_details_dict = {
        'GMIS_ID': self.GMIS,
        'Dependent_Variable_Name': self.depVarName,
        'Independent_Variable_Names': self.indepVarNames,
        'Model_Score_Methodology': self.modelScoremethodology,
        'Accuracy_Test': accuracy_test,
        'Correlation_Change': correlation_change,
        'Correlation_RAG': correl_rag,
        'Accuracy_RAG': stat_rag,
        'Final_RAG': final_rag,
        'Filename': filename
    }
    
    return (None, test_results_df, None, None, None, None, None, None, 
            detailed_calc_df, model_details_dict, None, None, None, None, None, 
            None, correl_rag, stat_rag, final_rag, filename)










class Complex(ModelSpec):
    def __init__(self, order, executionStatus, Portfolio, GMIS, modelSegment, modelSubsegment, LOB, modelType, modelScoremethodology, cycleInfo, depVarData, depVarName, depVarTransform, indepVarNames, indepVarTransform, modelEq, Fcst_Moving_Avg, Fcst_Moving_Avg_Period, actualsStartDate, modelDataFormat, outputDataFormat, modelscriptpath):
        super().__init__(order, executionStatus, Portfolio, GMIS, modelSegment, modelSubsegment, LOB, modelType, modelScoremethodology, cycleInfo, depVarData, depVarName, depVarTransform, indepVarNames, indepVarTransform, modelEq, Fcst_Moving_Avg, Fcst_Moving_Avg_Period, actualsStartDate, modelDataFormat, outputDataFormat)
        self.modelscriptpath = modelscriptpath
        
        # Main execution logic
        if self.cycleInfo['Objective'][0] == "Validation":
            print('Running complexscoreval for validation')
            self.projections = self.complexscoreval()
        else:
            print('Running complexscore for projections')
            self.projections = self.complexscore()
    
    def complexscore(self):
        # Your existing complexscore implementation
        actualsStartDateD = self.str2date(self.actualsStartDate)
        inSample_startDate = self.str2date(self.cycleInfo['inSample_startDate'])
        inSample_endDate = self.str2date(self.cycleInfo['inSample_endDate'])
        outSample_startDate = self.str2date(self.cycleInfo['outSample_startDate'])
        J0DateD = self.str2date(self.cycleInfo['J0Date'])
        endProjectionsDateD = self.str2date(self.cycleInfo['endProjectionsDate'])
        
        # ... rest of your existing complexscore code ...
        # (I'll keep the implementation you provided)
        
        return ds_4  # your existing return
    
    def complexscoreval(self):
    """
    Complex score evaluation function for model validation
    Performs backtesting and generates Excel output with multiple sheets
    """
    import pandas as pd
    import numpy as np
    from dateutil import relativedelta
    from sklearn.metrics import mean_absolute_percentage_error
    import warnings
    warnings.filterwarnings('ignore')
    
    # Date conversions
    actualsStartDateD = self.str2date(self.actualsStartDate)
    inSample_startDate = self.str2date(self.cycleInfo['inSample_startDate'])
    inSample_endDate = self.str2date(self.cycleInfo['inSample_endDate'])
    outSample_startDate = self.str2date(self.cycleInfo['outSample_startDate'])
    J0DateD = self.str2date(self.cycleInfo['J0Date'])
    endProjectionsDateD = self.str2date(self.cycleInfo['endProjectionsDate'])
    
    # Variable setup
    dependentTransform = self.depVarName + self.depVarTransform
    depVarData_1 = self.depVarData[[self.depVarName]]
    
    # Transform variables
    transformedVariables = []
    for var in range(len(self.indepVarNames)):
        transformedVariables.append(self.indepVarNames[var] + self.indepVarTransform[var])
    
    # Build model data
    model_build_df = pd.merge(self.depVarData, 
                             self.cycleInfo['MVData'][0][self.indepVarNames], 
                             how='left', left_index=True, right_index=True)
    
    # Add month column for quarterly filtering
    model_build_df['month'] = pd.DatetimeIndex(model_build_df.index).month
    
    # Filter for quarterly data if needed
    if self.outputDataFormat.lower() == 'quarterly':
        model_build_df = model_build_df[model_build_df['month'].isin([3, 6, 9, 12])]
    
    # Remove month column
    model_build_df = model_build_df.drop(['month'], axis=1)
    
    # Calculate market share
    indep_var = self.indepVarNames[0]  # Assuming first independent variable
    model_build_df['market_share'] = model_build_df[self.depVarName] / (model_build_df[indep_var] * 10**9)
    
    # Get baseline market share (recent 4 quarters before J0Date)
    j0_idx = model_build_df.index.get_loc(J0DateD, method='ffill')
    baseline_start_idx = max(0, j0_idx - 3)
    baseline_mkt_share = model_build_df.iloc[baseline_start_idx:j0_idx+1]['market_share'].mean()
    
    # Generate predictions for out-of-sample period
    out_sample_data = model_build_df.loc[outSample_startDate:endProjectionsDateD].copy()
    out_sample_data['pred'] = baseline_mkt_share * out_sample_data[indep_var] * 10**9
    
    # Calculate absolute percentage error
    out_sample_data['ape'] = np.abs((out_sample_data['pred'] / out_sample_data[self.depVarName]) - 1)
    
    # Get 9-quarter projection period (from J0Date)
    j0_out_idx = out_sample_data.index.get_loc(J0DateD, method='ffill')
    nine_q_end_idx = min(len(out_sample_data) - 1, j0_out_idx + 8)  # 9 quarters including J0Date
    
    nine_q_data = out_sample_data.iloc[j0_out_idx:nine_q_end_idx+1]
    
    # Calculate metrics
    forecast_sum = nine_q_data['pred'].sum()
    actual_sum = nine_q_data[self.depVarName].sum()
    accuracy_test = abs(forecast_sum / actual_sum - 1) if actual_sum != 0 else np.nan
    
    # Correlation calculations
    # Full series correlation
    correlation_full = model_build_df[self.depVarName].corr(model_build_df[indep_var])
    
    # In-sample correlation (model development period)
    in_sample_data = model_build_df.loc[inSample_startDate:inSample_endDate]
    correlation_in = in_sample_data[self.depVarName].corr(in_sample_data[indep_var])
    
    # Correlation change
    correlation_change = (correlation_full / correlation_in - 1) if correlation_in != 0 else np.nan
    
    # Determine RAG status
    def determine_rag_status(accuracy_test, correlation_change, model_type="complex"):
        """Determine RAG status based on accuracy and correlation"""
        correl_rag = "Green"
        if abs(correlation_change) > 0.5:
            correl_rag = "Red"
        elif abs(correlation_change) > 0.3:
            correl_rag = "Amber"
        
        stat_rag = "Green"
        if accuracy_test > 0.4:
            stat_rag = "Red"
        elif accuracy_test > 0.25:
            stat_rag = "Amber"
        
        if correl_rag == "Green" and stat_rag == "Green":
            final_rag = "Green"
        elif correl_rag == "Red" or stat_rag == "Red":
            final_rag = "Red"
        else:
            final_rag = "Amber"
        
        return correl_rag, stat_rag, final_rag
    
    correl_rag, stat_rag, final_rag = determine_rag_status(accuracy_test, correlation_change)
    
    # Create output DataFrames
    
    # 1. Test Results sheet
    test_results_df = pd.DataFrame({
        'GMIS_ID': [self.GMIS],
        'Dependent_Variable_Name': [self.depVarName],
        'Independent_Variable_Names': [str(self.indepVarNames)],
        'Model_Score_Methodology': [self.modelScoremethodology],
        'Correlation_Change': [correlation_change],
        'Accuracy_Test': [accuracy_test]
    })
    
    # 2. Model Specifications sheet
    model_specs_df = pd.DataFrame({
        'Variable': ['GMIS_ID', 'Dependent_Variable_Name', 'Independent_Variable_Names', 
                    'Model_Score_Methodology', 'Filename'],
        'Value': [self.GMIS, self.depVarName, str(self.indepVarNames), 
                 self.modelScoremethodology, f"{self.GMIS}_{self.depVarName}_validation.xlsx"]
    })
    
    # 3. RAG Assessment sheet
    rag_df = pd.DataFrame({
        'Metric': ['Correlation_RAG', 'Accuracy_RAG', 'Assessment_RAG'],
        'Status': [correl_rag, stat_rag, final_rag]
    })
    
    # 4. Detailed Calculations sheet (like your Excel logic)
    detailed_calc_df = model_build_df.copy()
    detailed_calc_df['market_share'] = detailed_calc_df[self.depVarName] / (detailed_calc_df[indep_var] * 10**9)
    
    # Add predictions and APE for out-of-sample period
    detailed_calc_df['forecast'] = np.nan
    detailed_calc_df['ape'] = np.nan
    
    # Fill forecasts for out-of-sample period
    out_sample_mask = (detailed_calc_df.index >= outSample_startDate) & (detailed_calc_df.index <= endProjectionsDateD)
    detailed_calc_df.loc[out_sample_mask, 'forecast'] = (baseline_mkt_share * 
                                                        detailed_calc_df.loc[out_sample_mask, indep_var] * 10**9)
    detailed_calc_df.loc[out_sample_mask, 'ape'] = np.abs((detailed_calc_df.loc[out_sample_mask, 'forecast'] / 
                                                          detailed_calc_df.loc[out_sample_mask, self.depVarName]) - 1)
    
    # Add summary statistics
    summary_stats = pd.DataFrame({
        'Metric': ['Forecast_Sum_9Q', 'Actual_Sum_9Q', 'Accuracy_Test', 
                  'Correlation_Full', 'Correlation_InSample', 'Correlation_Change',
                  'Baseline_Market_Share'],
        'Value': [forecast_sum, actual_sum, accuracy_test,
                 correlation_full, correlation_in, correlation_change,
                 baseline_mkt_share]
    })
    
    # Create filename
    filename = f"{self.GMIS}_{self.depVarName}_validation_{pd.Timestamp.now().strftime('%Y%m%d')}.xlsx"
    
    # Write to Excel with multiple sheets
    try:
        with pd.ExcelWriter(filename, engine='openpyxl') as writer:
            # Write all sheets
            rag_df.to_excel(writer, sheet_name='RAG', index=False)
            test_results_df.to_excel(writer, sheet_name='Test_Results', index=False)
            model_specs_df.to_excel(writer, sheet_name='Model_Specifications', index=False)
            detailed_calc_df.to_excel(writer, sheet_name='Detailed_Calculations', index=True)
            summary_stats.to_excel(writer, sheet_name='Summary_Statistics', index=False)
        
        print(f"Validation results saved to: {filename}")
        
    except Exception as e:
        print(f"Error saving Excel file: {str(e)}")
    
    # Create return dictionary similar to your original function structure
    model_details_dict = {
        'GMIS_ID': self.GMIS,
        'Dependent_Variable_Name': self.depVarName,
        'Independent_Variable_Names': self.indepVarNames,
        'Model_Score_Methodology': self.modelScoremethodology,
        'Accuracy_Test': accuracy_test,
        'Correlation_Change': correlation_change,
        'Correlation_RAG': correl_rag,
        'Accuracy_RAG': stat_rag,
        'Final_RAG': final_rag,
        'Filename': filename
    }
    
    return (None, test_results_df, None, None, None, None, None, None, 
            detailed_calc_df, model_details_dict, None, None, None, None, None, 
            None, correl_rag, stat_rag, final_rag, filename)