import os
import pandas as pd
from concurrent.futures import ThreadPoolExecutor
import dask.dataframe as dd
from functools import partial
import numpy as np

def read_single_excel(file_path):
    """Optimized function to read a single Excel file"""
    try:
        # Read with optimized settings
        df = pd.read_excel(
            file_path,
            engine='openpyxl',
            dtype_backend='pyarrow',  # Use PyArrow backend for better performance
            engine_kwargs={'options': {'string_storage': 'pyarrow'}},
            dtype={
                # Define common column types - adjust based on your data
                'float_columns': 'float32',
                'int_columns': 'int32',
                'date_columns': 'datetime64[ns]',
                'text_columns': 'category'
            }
        )
        return os.path.basename(file_path), df
    except Exception as e:
        print(f"Error reading {file_path}: {str(e)}")
        return os.path.basename(file_path), pd.DataFrame()

def read_excel_files(folder_name, subfolder_name):
    """Read multiple Excel files in parallel with optimizations"""
    folder_path = os.path.join(FOLDER_PATH, folder_name, subfolder_name)
    excel_files = [f for f in os.listdir(folder_path) if f.endswith(('.xlsx', '.xls'))]
    
    # Create list of file paths
    file_paths = [os.path.join(folder_path, excel_file) for excel_file in excel_files]
    
    # Initialize dictionary for dataframes
    dataframes = {}
    
    # Use ThreadPoolExecutor with optimal number of workers
    with ThreadPoolExecutor(max_workers=6) as executor:  # 6 workers for 12 files
        # Submit all file reading tasks
        future_to_file = {executor.submit(read_single_excel, file_path): file_path 
                         for file_path in file_paths}
        
        # Collect results as they complete
        for future in future_to_file:
            try:
                filename, df = future.result()
                if not df.empty:
                    dataframes[filename] = df
            except Exception as e:
                print(f"Error processing {future_to_file[future]}: {str(e)}")
    
    return dataframes