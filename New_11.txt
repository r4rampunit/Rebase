src/gemini_liquidity_models/liquidity_impact_calculation/calculation_config.py (CORRECTED)
from dataclasses import dataclass
from typing import Dict, List

@dataclass
class CalculationConfig:
    asset_row_mappings: Dict[str, List[int]]
    liability_row_mappings: Dict[str, List[int]]
    facility_row_mappings: Dict[str, List[int]]
    assumption_row_indices: Dict[str, int]
    
    @classmethod
    def get_default_config(cls):
        return cls(
            asset_row_mappings={
                'IWPB - Premier': list(range(3, 19)),  # Excel rows 6-21 = Python 3-18
                'IWPB - Private Banking': list(range(19, 22)),  # Excel rows 22-24 = Python 19-21
                'CIB Loans': list(range(23, 44)),  # Excel rows 26-47 = Python 23-44
                'UST - HTM': [51],  # Excel row 54 = Python 51
                'Level 1 - MBS - HTM': [50],  # Excel row 53 = Python 50
                'Level 1 Other - HTM': [52],  # Excel row 55 = Python 52
                'Level 2A - MBS - HTM': [54],  # Excel row 57 = Python 54
                'Level 2A - Other - HTM': [55],  # Excel row 58 = Python 55
                'UST - AFS': [60],  # Excel row 63 = Python 60
                'Level 1 - MBS - AFS': [59],  # Excel row 62 = Python 59
                'Level 1 Other - AFS': [61],  # Excel row 64 = Python 61
                'Level 2A- MBS - AFS': [63],  # Excel row 66 = Python 63
                'Level 2A- Other AFS': [64],  # Excel row 67 = Python 64
                'Liquid Equities': [83],  # Excel row 86 = Python 83
                'Illiquid Trading Assets': [87],  # Excel row 90 = Python 87
                'MSS - Loans': [91]  # Excel row 94 = Python 91
            },
            liability_row_mappings={
                'IWPB - Premier': [97],  # Excel row 100 = Python 97
                'PB - Personal': [105],  # Excel row 108 = Python 105
                'PB - Commercial - Financial': [110],  # Excel row 113 = Python 110
                'PB - Commercial - Non Financial': [115],  # Excel row 118 = Python 115
                'PB - Other': [120],  # Excel row 123 = Python 120
                'SME': [199],  # Excel row 202 = Python 199
                'Other (GPS)': [205],  # Excel row 208 = Python 205
                'Brokered - Committed': [210],  # Excel row 213 = Python 210
                'Brokered - Uncommitted': [211],  # Excel row 214 = Python 211
                'ISV': [212],  # Excel row 215 = Python 212
                'Innovation Banking': [215],  # Excel row 218 = Python 215
                'Other (CIB)': [218],  # Excel row 221 = Python 218
                'Structured CDs': [127],  # Excel row 130 = Python 127
                'Wholesale CDs': [136],  # Excel row 139 = Python 136
                'Equity': [222]  # Excel row 225 = Python 222
            },
            facility_row_mappings={
                'Mortgage commitments': [247],  # Excel row 250 = Python 247
                'Retail commitments': [250]  # Excel row 253 = Python 250
            },
            assumption_row_indices={
                'UST - HTM': 0,  # Row 3 in assumptions = index 0
                'Level 1 - MBS - HTM': 1,  
                'Level 1 Other - HTM': 2,  
                'Level 2A - MBS - HTM': 3,  
                'Level 2A - Other - HTM': 4,  
                'Illiquid': 5,  
                'UST - AFS': 6,  
                'Level 1 - MBS - AFS': 7,  
                'Level 1 Other - AFS': 8,  
                'Level 2A- MBS - AFS': 9,  
                'Level 2A- Other AFS': 10,  
                'Liquid Equities': 11,  
                'IWPB - Premier': 12,  
                'PB - Personal': 13,  
                'PB - Commercial - Financial': 14,  
                'PB - Commercial - Non Financial': 15,  
                'PB - Other': 16,  
                'Corp - Operational': 17,  
                'Corp - Non Operational': 18,  
                'NBFI - Operational': 19,  
                'NBFI - Non Operational': 20,  
                'Banks - Operational': 21,  
                'Banks - Non Operational': 22,  
                'SME': 23,  
                'Other (GPS)': 24,  
                'Brokered - Committed': 25,  
                'Brokered - Uncommitted': 26,  
                'ISV': 27,  
                'Innovation Banking': 28,  
                'Other (CIB)': 29,  
                'Credit1': 31,  
                'Liquidity1': 32,  
                'Credit2': 33,  
                'Liquidity2': 34,  
                'Credit3': 35,  
                'Liquidity3': 36,  
                'Mortgage commitments': 37,  
                'Retail commitments': 38  
            }
        )
And update the utils/excel_utils.py to ensure proper column naming:
import polars as pl
from openpyxl import load_workbook, Workbook
from openpyxl.styles import Font
from datetime import datetime
from typing import Dict, List, Tuple

class ExcelReader:
    
    @staticmethod
    def read_sheet(file_path: str, sheet_name: str, header_row: int = 2) -> Tuple[pl.DataFrame, List[str]]:
        wb = load_workbook(file_path, data_only=True)
        ws = wb[sheet_name]
        
        headers = []
        date_columns = []
        date_indices = []
        
        # Read from row 2 (header_row)
        for idx, cell in enumerate(ws[header_row], start=0):
            if cell.value:
                # Check if it's a date
                if isinstance(cell.value, datetime):
                    col_name = cell.value.strftime('%d-%b-%y')
                    if idx >= 8:  # Column I onwards (0-based index 8)
                        date_columns.append(col_name)
                        date_indices.append(idx)
                    headers.append(col_name)
                else:
                    # Regular column name
                    col_name = str(cell.value).replace(' ', '_').replace('.', '')
                    headers.append(col_name)
        
        data = []
        # Read data starting from row 3
        for row in ws.iter_rows(min_row=3, values_only=True):
            if row and row[0] is not None:
                row_dict = {}
                for col_idx, value in enumerate(row[:len(headers)]):
                    if col_idx < len(headers):
                        header = headers[col_idx]
                        if value is None:
                            value = 0.0 if col_idx in date_indices else ""
                        elif col_idx in date_indices:
                            # Handle numeric values in date columns
                            if isinstance(value, (int, float)):
                                value = float(value)
                            else:
                                try:
                                    value = float(str(value).replace(',', ''))
                                except:
                                    value = 0.0
                        else:
                            value = str(value) if value is not None else ""
                        row_dict[header] = value
                data.append(row_dict)
        
        wb.close()
        
        if not data:
            return pl.DataFrame(), date_columns
            
        df = pl.DataFrame(data)
        
        # Ensure date columns are float
        for date_col in date_columns:
            if date_col in df.columns:
                df = df.with_columns(pl.col(date_col).cast(pl.Float64))
        
        # Remove base date from date_columns list for output
        if '31-Dec-24' in date_columns:
            date_columns.remove('31-Dec-24')
        
        return df, date_columns

 