import pandas as pd
import numpy as np
import datetime
import re
import copy
import itertools
import statistics
from math import sqrt
from datetime import timedelta
from dateutil.relativedelta import relativedelta
from statsmodels.tsa.ar_model import AutoReg
from statsmodels.tsa.stattools import adfuller, coint
import statsmodels.stats.stattools as sms
from scipy import stats
from sklearn.metrics import mean_squared_error
import matplotlib.pyplot as plt
import seaborn as sns
import docx
from openpyxl import load_workbook
from collections import OrderedDict
from scipy.stats import shapiro

class LinearReg(ModelSpec):
    def __init__(self, order, executionStatus, Portfolio, GMIS, modelSegment, modelSubsegment, LOB, 
                 modelType, modelScoremethodology, cycleInfo, depVarData, depVarName, depVarTransform, 
                 indepVarNames, indepVarTransform, modelEq, Fcst_Moving_Avg, Fcst_Moving_Avg_Period, 
                 actualsStartDate, modelDataFormat, outputDataFormat):
        
        super().__init__(order, executionStatus, Portfolio, GMIS, modelSegment, modelSubsegment, LOB, 
                        modelType, modelScoremethodology, cycleInfo, depVarData, depVarName, depVarTransform, 
                        indepVarNames, indepVarTransform, modelEq, Fcst_Moving_Avg, Fcst_Moving_Avg_Period, 
                        actualsStartDate, modelDataFormat, outputDataFormat)
        
        self.projections = self.LINscoring()
        
        excel_loc = r'C:\Users\45363901\PycharmProjects\pythonProject\Modelytics_Prod_Code\Input Files\Model Details for Validation.xlsx'
        self.model_val_dict = self.load_model_val_dict(excel_loc)
        print('Model_val_dict')
        print(self.model_val_dict)
        print("Self.GMIS")
        print(self.GMIS)
        print(type(self.GMIS))
        
        df = pd.read_excel(excel_loc)
        
        def extract_number(gmis_id):
            if isinstance(gmis_id, str):
                return "".join(re.findall(r'\d+', gmis_id))
            return str(gmis_id)
        
        self_gmis_numeric = extract_number(self.GMIS)
        df['GMIS_ID_numeric'] = df['GMIS_ID'].apply(extract_number)
        matching_df = df[df['GMIS_ID_numeric'] == self_gmis_numeric]
        
        print(self.model_val_dict['validation_required'])
        
        if self.cycleInfo['Objective'][0] == "Validation":
            print('self.cycleInfo')
            print(self.cycleInfo['Objective'])
            print('yes')
            self.projections = self.LINscoreval()
        else:
            print('self.cycleInfo')
            print(self.cycleInfo['Objective'])
            print("No nothing")
            self.projections = self.LINscoring()

    def load_model_val_dict(self, excel_loc):
        df = pd.read_excel(excel_loc)
        
        def extract_number(gmis_id):
            if isinstance(gmis_id, str):
                return "".join(re.findall(r'\d+', gmis_id))
            return str(gmis_id)
        
        self_gmis_numeric = extract_number(self.GMIS)
        df['GMIS_ID_numeric'] = df['GMIS_ID'].apply(extract_number)
        matching_df = df[df['GMIS_ID_numeric'] == self_gmis_numeric]
        model_val_dict = matching_df.iloc[0].to_dict()
        return model_val_dict

    def LINscoreval(self):
        if len(self.indepVarNames) != len(self.indepVarTransform):
            print('\n\n\nError! Not all independent variables details are provided!\n\n\n')
        
        if len(self.cycleInfo['scenarios']) != len(self.cycleInfo['MVData']):
            print('\n\n\nError! Not all scenario details are provided!\n\n\n')
        
        # change strings to dates
        actualsStartDateD = self.str2date(self.actualsStartDate)
        JODateD = self.str2date(self.cycleInfo['Jumpoff'])
        endProjectionsDateD = self.str2date(self.cycleInfo['endProjectionsDate'])
        
        series_type = "Actual"  # CORRECTED: Added missing assignment
        
        transformedVariables = []
        for var in range(len(self.indepVarNames)):
            transformedVariables.append(self.indepVarNames[var] + self.indepVarTransform[var])
        
        dependentTransform = self.depVarName + self.depVarTransform
        self.indepVarNames.append('month')  # add month to be able to transform monthly to quarterly data later
        
        ds_4 = []
        ds_6 = []
        depVarData_1 = self.depVarData[[self.depVarName]]  # select applicable dependent variable from the dependent variable data
        
        # calculate projections for each scenario
        for scen in range(len(self.cycleInfo['MVData'])):
            df = self.cycleInfo['MVData'][scen]
            unique_indep = copy.deepcopy(self.indepVarNames)
            unique_indep = list(set(unique_indep))
            MVData_1 = df[unique_indep].copy()  # select only independent variables and month
            
            # independent variables and month
            ds_1 = pd.merge(MVData_1, depVarData_1, how='left', left_index=True, right_index=True)
            ds_1 = ds_1.loc[:, ~ds_1.columns.duplicated()].copy()
            
            # perform independent variables transformations
            if self.modelDataFormat.lower() == 'quarterly':
                for ii in range(len(self.indepVarTransform)):
                    ds_1 = self.transformIndepDataMtoQ(ds_1, self.indepVarNames[ii], self.indepVarTransform[ii])
            elif self.modelDataFormat.lower() == 'monthly':
                for jj in range(len(self.indepVarTransform)):
                    ds_1 = self.transformIndepData(ds_1, self.indepVarNames[jj], self.indepVarTransform[jj])
            else:
                print('\n\n\nError! Incorrectly defined date format!\n\n\n')
                return
            
            cols = list(ds_1.columns)
            ds_1 = ds_1[cols[0:-len(self.indepVarNames)] + cols[-len(self.indepVarNames) + 1:] + cols[-len(self.indepVarNames):-len(self.indepVarNames) + 1]]
            
            # perform dependent variables transformations
            if self.modelDataFormat.lower() == 'quarterly':
                ds_1 = self.transformDepDataMtoQ(ds_1, self.depVarName, self.depVarTransform)
            elif self.modelDataFormat.lower() == 'monthly':
                ds_1 = self.transformDepDataM(ds_1, self.depVarName, self.depVarTransform)
            else:
                print('\n\n\nError! Incorrectly defined date format!\n\n\n')
                return
            
            ds_1 = ds_1.loc[actualsStartDateD:]  # data after actualsStartDate
            ds_1 = ds_1.loc[:endProjectionsDateD]  # data till endProjectionsDate
            
            # take month-end values if transforming to appropriate data format
            if self.outputDataFormat.lower() == 'quarterly':
                ds_1 = ds_1.loc[ds_1['month'].isin([3, 6, 9, 12])]
            elif self.outputDataFormat.lower() != 'monthly':
                print('\n\n\nError! Incorrectly defined outputDataFormat #2\n\n\n')
                return
            
            # apply model to the data
            if self.coefficient_estimation == "Yes":
                y_train = ds_1[[self.depVarName + self.depVarTransform]]
                x_train = ds_1[transformedVariables]
                start_date = pd.to_datetime(self.first_histqtr).date()
                y_train = y_train[start_date: JODateD + timedelta(days=1)]
                x_train = x_train[start_date: JODateD + timedelta(days=1)]
                
                if self.hasIntercept == 1:
                    model = AutoReg(y_train, 0, trend='c', exog=x_train, old_names=False).fit()
                else:
                    model = AutoReg(y_train, 0, trend='n', exog=x_train, old_names=False).fit()
                
                coeff = model.params.to_frame()
                self.modelEq = ""
                for el in coeff.index:
                    if el == "const":
                        if coeff[0][el] < 0:
                            self.modelEq = self.modelEq + "-" + str(abs(coeff[0][el]))
                        else:
                            self.modelEq = self.modelEq + "+" + str(coeff[0][el])
                    else:
                        if coeff[0][el] < 0:
                            self.modelEq = self.modelEq + "-" + str(abs(coeff[0][el])) + "*" + el
                        else:
                            self.modelEq = self.modelEq + "+" + str(coeff[0][el]) + "*" + el
                
                print("The Model Equation post Coefficient Reestimation: " + self.modelEq)
            
            ds_1['pred'] = ds_1.eval(self.modelEq)
            
            if self.jumpoff_adjustment_9qtr == "Yes":
                print("HallaBol")
                nine_qtr_before_jo = JODateD + relativedelta(months=-24)
                nine_qtr_before_jo = nine_qtr_before_jo.replace(day=28) + timedelta(days=4)
                nine_qtr_before_jo = nine_qtr_before_jo - timedelta(days=nine_qtr_before_jo.day)
                
                start_date = self.first_histqtr
                print('start_date')
                print(start_date)
                ds_1_copy = ds_1.copy()
                print(ds_1_copy.to_string())
                
                if self.modelDataFormat.lower() == 'quarterly' and self.outputDataFormat.lower() == 'quarterly':
                    ds_1_copy = self.transformBackDepDataQQ(ds_1_copy, self.depVarName, self.depVarTransform, start_date, 'pred')
                elif self.modelDataFormat.lower() == 'monthly' and self.outputDataFormat.lower() == 'monthly':
                    ds_1_copy = self.transformBackDepDataMM(ds_1_copy, self.depVarName, self.depVarTransform, start_date, 'pred')
                elif self.modelDataFormat.lower() == 'monthly' and self.outputDataFormat.lower() == 'quarterly':
                    ds_1_copy = self.transformBackDepDataMQ(ds_1_copy, self.depVarName, self.depVarTransform, start_date, 'pred')
                elif self.modelDataFormat.lower() == 'quarterly' and self.outputDataFormat.lower() == 'monthly':
                    ds_1_copy = self.transformBackDepDataQM(ds_1_copy, self.depVarName, self.depVarTransform, start_date, 'pred')
                    ds_1_copy.loc[ds_1_copy['month'].isin([1, 2, 4, 5, 7, 8, 10, 11]), ['pred', self.depVarName + '_pred']] = np.nan
                else:
                    print('\n\n\nIncorrectly defined outputDataFormat or modelDataFormat! #3\n\n\n')
                    return
                
                ds_1_copy = ds_1_copy.set_index('date')
                ds_1_copy['delta'] = ds_1_copy[self.depVarName] - ds_1_copy[self.depVarName + '_pred']
                nine_qtr_mean = ds_1_copy[nine_qtr_before_jo: JODateD]['delta'].mean()
            
            ds_1.loc[:JODateD + timedelta(days=1), 'pred'] = np.nan
            ds_1.loc[JODateD, 'pred'] = ds_1[self.depVarName][JODateD]
            
            print('ds_1_main')
            print(ds_1.to_string())
            
            if self.modelDataFormat.lower() == 'quarterly' and self.outputDataFormat.lower() == 'quarterly':
                ds_1 = self.transformBackDepDataQQ(ds_1, self.depVarName, self.depVarTransform, JODateD, 'pred')
            elif self.modelDataFormat.lower() == 'monthly' and self.outputDataFormat.lower() == 'monthly':
                ds_1 = self.transformBackDepDataMM(ds_1, self.depVarName, self.depVarTransform, JODateD, 'pred')
            elif self.modelDataFormat.lower() == 'monthly' and self.outputDataFormat.lower() == 'quarterly':
                ds_1 = self.transformBackDepDataMQ(ds_1, self.depVarName, self.depVarTransform, JODateD, 'pred')
            elif self.modelDataFormat.lower() == 'quarterly' and self.outputDataFormat.lower() == 'monthly':
                ds_1 = self.transformBackDepDataQM(ds_1, self.depVarName, self.depVarTransform, JODateD, '_pred')
                ds_1.loc[ds_1['month'].isin([1, 2, 4, 5, 7, 8, 10, 11]), ['pred', self.depVarName + '_pred']] = np.nan
            else:
                print('\n\n\nIncorrectly defined outputDataFormat or modelDataFormat! #3\n\n\n')
                return
            
            ds_1 = ds_1.drop(['month'], axis=1)  # remove month column
            print('ds_1_main_post')
            print(ds_1.to_string())
            
            ds_5 = ds_1.copy()
            ds_6.append(ds_5)
            
            ds_1 = ds_1.set_index('date')
            
            if self.jumpoff_adjustment_9qtr == "Yes":
                ds_1[self.depVarName + '_pred'] = ds_1[self.depVarName + '_pred'] + nine_qtr_mean
                ds_1.loc[JODateD, self.depVarName + '_pred'] = ds_1[self.depVarName][JODateD]
            
            ds_1 = ds_1.T
            ds_1 = ds_1.reset_index()
            ds_1 = ds_1.rename(columns={'index': 'Variable_Mnemonic'})
            
            ds_1['Execution_Order'] = self.order
            ds_1['Execution_Status'] = self.executionStatus
            ds_1['Timestamp'] = datetime.datetime.today().strftime('%Y%m%d%H%M%S')
            ds_1['Cycle'] = self.cycleInfo['cycle']
            ds_1['Type'] = self.cycleInfo['type']
            ds_1['Year'] = self.cycleInfo['year']
            ds_1['Scenario'] = self.cycleInfo['scenarios'][scen]
            ds_1['Jumpoff'] = self.cycleInfo['Jumpoff']
            ds_1['Portfolio'] = self.Portfolio
            ds_1['GMIS_ID'] = self.GMIS
            ds_1['Segment'] = self.modelSegment
            ds_1['Subsegment'] = self.modelSubsegment
            ds_1['LOB'] = self.LOB
            ds_1['Model_Type'] = self.modelType
            
            ds_1.loc[ds_1['Variable_Mnemonic'].isin(self.indepVarNames), 'Projection'] = 'MV'
            ds_1.loc[ds_1['Variable_Mnemonic'].isin(transformedVariables), 'Projection'] = 'MV_transformed'
            ds_1.loc[ds_1['Variable_Mnemonic'] == self.depVarName, 'Projection'] = 'Actual'
            ds_1.loc[ds_1['Variable_Mnemonic'] == dependentTransform, 'Projection'] = 'Actual_transformed'
            ds_1.loc[ds_1['Variable_Mnemonic'] == 'pred', 'Variable_Mnemonic'] = dependentTransform + '_pred'
            ds_1.loc[ds_1['Variable_Mnemonic'] == dependentTransform + '_pred', 'Projection'] = 'Model_transformed'
            ds_1.loc[ds_1['Variable_Mnemonic'] == self.depVarName + '_pred', 'Projection'] = 'Model'
            
            ds_1['Details'] = dependentTransform + '_Model'
            for var in range(len(self.indepVarTransform)):
                ds_1.loc[ds_1['Variable_Mnemonic'] == self.indepVarNames[var] + self.indepVarTransform[var], 'Details'] = self.indepVarTransform[var]
            
            ds_1.loc[ds_1['Projection'] == 'Actual_transformed', 'Details'] = self.depVarTransform
            
            ds_1['Frequency'] = ""  # CORRECTED: Added missing assignment
            if self.outputDataFormat.lower() == 'quarterly':
                ds_1['Frequency'] = 'Quarterly'
            else:
                for var in range(len(self.indepVarTransform)):
                    ds_1.loc[ds_1['Variable_Mnemonic'] == self.indepVarNames[var], 'Frequency'] = self.cycleInfo['MVDataFormat'].capitalize()
                    ds_1.loc[ds_1['Variable_Mnemonic'] == self.indepVarNames[var] + self.indepVarTransform[var], 'Frequency'] = self.cycleInfo['MVDataFormat'].capitalize()
                
                ds_1.loc[ds_1['Projection'].isin(['Actual', 'Actual_transformed', 'Model', 'Final']), 'Frequency'] = self.modelDataFormat.capitalize()
                ds_1.loc[ds_1['Projection'] == 'Model_transformed', 'Frequency'] = self.outputDataFormat.capitalize()
            
            if self.Fcst_Moving_Avg.lower() == 'yes':
                ds_1 = self.maSmoothing([ds_1], self.Fcst_Moving_Avg_Period, [self.cycleInfo['scenarios'][scen]], self.modelDataFormat.lower(), self.outputDataFormat.lower())[0]
            
            ds_1 = ds_1.append(ds_1.tail(1), ignore_index=True)
            ds_1.loc[ds_1.index[-1], 'Projection'] = 'Final'
            
            cols = list(ds_1.columns)
            ds_1 = ds_1[cols[-16:] + cols[0:-16]]
            
            ds_4.append(ds_1)
        
        self.indepVarNames.remove('month')
        print(ds_4)

        # CORRECTED: Added missing function definitions
        def StringToListConvert(string):
            li = list(string.split(","))
            return li

        def create_list(ls):
            ls = [x.strip("*") for x in ls]
            return ls

        def model_details(filename):
            model_file = pd.read_excel(filename)
            model_details_list = model_file.to_dict("index")
            return model_details_list

        def r_squared(y_actual, y_pred):
            y_bar = y_actual.mean()
            ss_tot = ((y_actual - y_bar) ** 2).sum()
            ss_res = ((y_actual - y_pred) ** 2).sum()
            return 1 - (ss_res/ss_tot)

        def mean_absolute_percentage_error(y_actual, y_pred):
            actual = np.array(y_actual)
            prediction = np.array(y_pred)
            mape = np.mean(np.abs((actual - prediction) / actual))
            return mape

        def absolute_percentage_error(y_actual, y_pred):
            y_actual, y_pred = np.array(y_actual), np.array(y_pred)
            ape = (np.abs((y_actual - y_pred) / y_actual))
            return ape

        def correlation_calc(dep_var, indep_vars):
            try:
                var = []
                corr_val = []
                for col in indep_vars.columns:
                    var.append(col)
                    indep_var = indep_vars[[col]]
                    df_comb = pd.concat([dep_var, indep_var], axis=1)
                    correlation_val = df_comb.corr(method='pearson')
                    corr_val.append(correlation_val[dep_var.columns[0]][col])
                
                corr_dict = {'Variable': var, 'correlation': corr_val}
                corr_df = pd.DataFrame(corr_dict)
                return corr_df
            except Exception as e:
                print(f"Exception ---- {e}")
                return pd.DataFrame()

        actual_start_date = datetime.datetime.strptime(self.model_val_dict["Actuals_Start_Date"], "%Y-%m-%d").date()
        inSample_startDate = datetime.datetime.strptime(self.model_val_dict["FirstHistQtr"], "%Y-%m-%d").date()
        inSample_endDate = datetime.datetime.strptime(self.model_val_dict["LastHistQtr"], "%Y-%m-%d").date()
        outSample_startDate = datetime.datetime.strptime(self.model_val_dict["FirstOutSampleDt"], "%Y-%m-%d").date()
        outSample_endDate = datetime.datetime.strptime(self.model_val_dict["JumpOffDt"], "%Y-%m-%d").date()
        last_forecast_dt = datetime.datetime.strptime(self.model_val_dict["LastForecastQtr"], "%Y-%m-%d").date()
        
        transformDep = self.model_val_dict["Dependent_Variable_Transform"][2:-2]
        transformDep_list = StringToListConvert(self.model_val_dict["Dependent_Variable_Transform"][2:-2])
        indep_Var_List = StringToListConvert(self.model_val_dict["Independent_Variable_Names"][1:-1])
        transform_Indep_List = StringToListConvert(self.model_val_dict["Independent_Variable_Transform"][1:-1])
        transform_ind_list = StringToListConvert(self.model_val_dict["Independent_Variable_Transform"][2:-2])
        model_class = self.model_val_dict["Model Class"]
        ns_model_type = self.model_val_dict["Non Stat Model Type"]
        indep_var_raw_1 = self.model_val_dict["Independent_Variable_Names"]
        
        model_data = []
        model_data_columns = []
        target_column = []
        feature_columns = []
        
        final_df = pd.concat(ds_6, ignore_index=True, axis=0)
        print('final_df')
        print(final_df)
        
        model_data_df = final_df
        model_data_columns = final_df.columns
        target_column = [self.depVarName + self.depVarTransform]
        feature_columns = []
        for names, trans in zip(self.indepVarNames, self.indepVarTransform):
            feature_columns.append(names + trans)
        
        model_data_df1 = model_data_df.set_index("date").sort_index()
        model_build_df = pd.DataFrame()
        
        if isinstance(indep_var_raw_1, str) and len(indep_var_raw_1) > 2:
            indep_Var_List = StringToListConvert(indep_var_raw_1[1:-1])
        else:
            print('')
            indep_var_list = []
        
        modelBackTransformList = []
        
        if self.modelDataFormat.lower() == "quarterly":
            cutoff_date = (datetime.datetime.strptime(str(inSample_endDate), "%Y-%m-%d") + relativedelta(months=3)).date()
        elif self.modelDataFormat.lower() == "monthly":
            cutoff_date = (datetime.datetime.strptime(str(inSample_endDate), "%Y-%m-%d") + relativedelta(months=1)).date()

        if self.modelDataFormat.lower() == 'quarterly':
            model_data_df["date"] = pd.to_datetime(model_data_df['date'])
            model_data_df["Month"] = model_data_df["date"].dt.month
            model_data_df["Day"] = model_data_df["date"].dt.day
            model_data_df["Days_in_month"] = model_data_df["date"].dt.days_in_month
            model_data_df["Diff"] = model_data_df["Days_in_month"] - model_data_df["Day"]
            model_data_df = model_data_df.loc[model_data_df['Month'].isin([3, 6, 9, 12])]
            model_data_df = model_data_df[model_data_df["Diff"] == 0]
            del model_data_df['Month']
            del model_data_df['Day']
            del model_data_df['Days_in_month']
            del model_data_df['Diff']
        else:
            model_data_df = model_data_df
        
        if self.indepVarNames[-5:] == "_flag":  # CORRECTED: Fixed syntax
            feature_columns += [self.indepVarNames + self.depVarTransform]
        else:
            feature_columns += [self.indepVarNames + self.depVarTransform]
        
        if series_type == "Actual":
            train_model_data_df = model_data_df1[inSample_startDate: inSample_endDate]
            train_model_data_df1 = train_model_data_df.dropna(axis=0)
            test_model_data_df = model_data_df1[inSample_startDate:outSample_endDate]
        elif series_type == "Full":
            train_model_data_df = model_data_df1[inSample_startDate:outSample_endDate]
            train_model_data_df1 = train_model_data_df.dropna(axis=0)
            test_model_data_df = model_data_df1[inSample_startDate:outSample_endDate]
        
        test_model_data_df = test_model_data_df.dropna(subset=feature_columns)
        x_train = train_model_data_df[feature_columns]
        y_train = train_model_data_df[target_column]
        x_test = test_model_data_df[feature_columns]
        
        ar_lag = int(self.model_val_dict["AR_Lag_Term"][1:-1] if self.model_val_dict["AR_Lag_Term"][1:-1] != '' else 0)
        
        if self.hasIntercept == 1:
            model = AutoReg(y_train, lags=ar_lag, trend='c', exog=x_train, old_names=False)
        else:
            model = AutoReg(y_train, lags=ar_lag, trend='n', exog=x_train, old_names=False)
        
        model_estimate = model.fit()
        print(model_estimate.summary())
        
        predictions = model_estimate.get_prediction(exog=x_train, start=x_train.index[0], end=len(x_test.index) - 1, exog_oos=x_test)
        y_test_predictions = pd.Series(predictions.predicted_mean)
        
        y_95 = predictions.conf_int(alpha=0.05)
        y_95_df = pd.DataFrame(y_95)
        y_95_df.columns = ["lc195", "uc195"]
        
        y_90 = predictions.conf_int(alpha=0.1)
        y_90_df = pd.DataFrame(y_90)
        y_90_df.columns = ["lc190", "uc190"]
        
        y_test_column = target_column[0] + "_pred"
        test_model_data_final = test_model_data_df.assign(**{y_test_column: y_test_predictions})
        model_data_df1[y_test_column] = test_model_data_final[y_test_column]
        
        model_data_df1.index = pd.to_datetime(model_data_df1.index)
        y_95_df.index = pd.to_datetime(y_95_df.index)
        y_90_df.index = pd.to_datetime(y_90_df.index)
        test_model_data_final.index = pd.to_datetime(test_model_data_final.index)
        
        model_data_df1 = pd.concat([model_data_df1, y_95_df, y_90_df], axis=1)
        test_model_data_final = pd.concat([test_model_data_final, y_95_df, y_90_df], axis=1)
        
        depVar = self.depVarName + "Q"
        if self.modelDataFormat.lower() == 'quarterly':
            depVar = self.depVarName + "Q"
            modelBackTransformList.append(self.transformBackDepDataQQ(model_data_df1, depVar, self.depVarTransform, test_model_data_final.index.values[0], '_pred').iloc[:, -1].tolist())
            modelBackTransformList.append(self.transformBackDepConIntQQ(model_data_df1, depVar, self.depVarTransform, test_model_data_final.index.values[0], 'lc195').iloc[:, -1].tolist())
            modelBackTransformList.append(self.transformBackDepConIntQQ(model_data_df1, depVar, self.depVarTransform, test_model_data_final.index.values[0], 'uc195').iloc[:, -1].tolist())
            modelBackTransformList.append(self.transformBackDepConIntQQ(model_data_df1, depVar, self.depVarTransform, test_model_data_final.index.values[0], 'lc190').iloc[:, -1].tolist())
            modelBackTransformList.append(self.transformBackDepConIntQQ(model_data_df1, depVar, self.depVarTransform, test_model_data_final.index.values[0], 'uc190').iloc[:, -1].tolist())
        else:
            modelBackTransformList.append(self.transformBackDepDataMM(model_data_df1, self.depVarName, self.depVarTransform, test_model_data_final.index.values[0], '_pred').iloc[:, -1].tolist())
            modelBackTransformList.append(self.transformBackDepConIntMM(model_data_df1, depVar, self.depVarTransform, test_model_data_final.index.values[0], 'lc195').iloc[:, -1].tolist())
            modelBackTransformList.append(self.transformBackDepConIntMM(model_data_df1, depVar, self.depVarTransform, test_model_data_final.index.values[0], 'uc195').iloc[:, -1].tolist())
            modelBackTransformList.append(self.transformBackDepConIntMM(model_data_df1, depVar, self.depVarTransform, test_model_data_final.index.values[0], 'lc190').iloc[:, -1].tolist())
            modelBackTransformList.append(self.transformBackDepConIntMM(model_data_df1, depVar, self.depVarTransform, test_model_data_final.index.values[0], 'uc190').iloc[:, -1].tolist())
        
        modelBackTransformData = list(map(list, itertools.zip_longest(*modelBackTransformList, fillvalue=None)))
        model_build_df2 = pd.DataFrame(modelBackTransformData, index=model_data_df1.index, columns=[self.depVarName + "_pred", "lc195_pred", "uc195_pred", "lc190_pred", "uc190_pred"])
        model_build_df = pd.concat([model_data_df1, model_build_df2], axis=1)
        model_build_df = model_build_df.replace(r'^\s*, np.nan, regex=True)
        
        projections = self.projections
        projections = projections.iloc[:, np.r_[16:len(projections.columns) - 1]].set_index("Variable_Mnemonic").T
        projections = projections.loc[:, ~projections.columns.duplicated()]
        projections_copy = projections.copy()
        projections_copy = projections_copy[[depVar, depVar + "_pred"]]
        
        actual_y = projections_copy.iloc[:projections_copy.index.get_loc(outSample_endDate, method="ffill") + 1][depVar]
        pred_y = projections_copy.iloc[:projections_copy.index.get_loc(outSample_endDate, method="ffill") + 1][depVar + "_pred"]
        
        y_actual_in = projections_copy.iloc[:projections_copy.index.get_loc(inSample_endDate, method="ffill") + 1][depVar]
        y_pred_in = projections_copy.iloc[:projections_copy.index.get_loc(inSample_endDate, method="ffill") + 1][depVar + "_pred"]
        
        y_actual_out = projections_copy.iloc[projections_copy.index.get_loc(cutoff_date, method="bfill"): projections_copy.index.get_loc(outSample_endDate, method="ffill") + 1][depVar]
        y_pred_out = projections_copy.iloc[projections_copy.index.get_loc(cutoff_date, method="bfill"): projections_copy.index.get_loc(outSample_endDate, method="ffill") + 1][depVar + "_pred"]
        
        projections["APE"] = np.abs((projections[depVar] - projections[depVar+"_pred"]) / projections[depVar])
        
        ape_out = absolute_percentage_error(y_actual_out, y_pred_out)
        mape = mean_absolute_percentage_error(actual_y, pred_y)
        mape_in = mean_absolute_percentage_error(y_actual_in, y_pred_in)
        mape_out = mean_absolute_percentage_error(y_actual_out, y_pred_out)
        
        mse = mean_squared_error(actual_y, pred_y)
        mse_in = mean_squared_error(y_actual_in, y_pred_in)
        mse_out = mean_squared_error(y_actual_out, y_pred_out)
        
        rmse = np.sqrt(mse)
        rmse_in = np.sqrt(mse_in)
        rmse_out = np.sqrt(mse_out)
        
        rmspe = (np.sqrt(np.mean(np.square(((actual_y) - (pred_y)) / (actual_y))))) * 100
        rmspe_in = (np.sqrt(np.mean(np.square(((y_actual_in) - (y_pred_in)) / (y_actual_in))))) * 100
        rmspe_out = (np.sqrt(np.mean(np.square(((y_actual_out) - (y_pred_out)) / (y_actual_out))))) * 100
        
        results = {"GMIS_ID": self.GMIS, 'DepVar': self.depVarName, "IndepVar": str([x.strip("*") for x in indep_Var_List]), 
                  'Model_Equation': self.modelEq, 'MAPE': mape, 'RMSPE': rmspe, 'MSE': mse, 'RMSE': rmse,
                  "MAPE_in": mape_in, 'RMSPE_in': rmspe_in, 'MSE_in': mse_in, 'RMSE_in': rmse_in,
                  'MAPE_out': mape_out, 'RMSPE_out': rmspe_out, 'MSE_out': mse_out, 'RMSE_out': rmse_out}
        
        df_results = pd.DataFrame([results])
        df_actuals_projections, actual_results, mape_in_actuals, ape_out_actuals = projections, df_results, mape_in, ape_out

        def Model_statistics(model_name, model_id, model_type, series_type):
            y_actual = model_data_df1.iloc[:model_data_df1.index.get_loc(outSample_endDate, method="ffill") + 1][depVar]
            y_pred = model_data_df1.iloc[:model_data_df1.index.get_loc(outSample_endDate, method="ffill") + 1][depVar + "_pred"]
            
            y_actual_in = model_data_df1.iloc[:model_data_df1.index.get_loc(inSample_endDate, method="ffill") + 1][depVar]
            y_pred_in = model_data_df1.iloc[:model_data_df1.index.get_loc(inSample_endDate, method="ffill") + 1][depVar + "_pred"]
            
            y_actual_out = model_data_df1.iloc[model_data_df1.index.get_loc(cutoff_date, method="bfill"):model_data_df1.index.get_loc(outSample_endDate, method="ffill") + 1][depVar]
            y_pred_out = model_data_df1.iloc[model_data_df1.index.get_loc(cutoff_date, method="bfill"):model_data_df1.index.get_loc(outSample_endDate, method="ffill") + 1][depVar + "_pred"]
            
            y_full = model_data_df1.iloc[:model_data_df1.index.get_loc(outSample_endDate, method="ffill") + 1][depVar]
            x_full = model_data_df1.iloc[:model_data_df1.index.get_loc(outSample_endDate, method="ffill") + 1][[x.strip("*") for x in indep_Var_List]]
            
            y_in = model_data_df1.iloc[:model_data_df1.index.get_loc(inSample_endDate, method="ffill") + 1][depVar]
            x_in = model_data_df1.iloc[:model_data_df1.index.get_loc(inSample_endDate, method="ffill") + 1][[x.strip("*") for x in indep_Var_List]]
            
            y_out = model_data_df1.iloc[model_data_df1.index.get_loc(cutoff_date, method="bfill"):model_data_df1.index.get_loc(outSample_endDate, method="ffill") + 1][depVar]
            x_out = model_data_df1.iloc[model_data_df1.index.get_loc(cutoff_date, method="bfill"):model_data_df1.index.get_loc(outSample_endDate, method="ffill") + 1][[x.strip("*") for x in indep_Var_List]]
            
            df_model_params = model_estimate.params.to_frame()
            df_model_pValues = model_estimate.pvalues.to_frame()
            df_model_stdError = model_estimate.bse.to_frame()
            df_model_tStat = model_estimate.tvalues.to_frame()
            
            df_model_details = pd.concat([df_model_params, df_model_pValues, df_model_stdError, df_model_tStat], axis=1)
            df_model_details.columns = ["COEFFICIENTS", "P-VALUES", "STANDARD ERROR", "T-STATISTICS"]
            
            df_model_details["APE"] = absolute_percentage_error(y_actual=model_data_df1[depVar], y_pred=model_data_df1[depVar + "_pred"])
            
            sw_test_normality_pval = shapiro(model_estimate.resid)[1]
            bp_hetero_test_pval = model_estimate.test_heteroskedasticity('breakvar')[0][1]
            dw_autocorr_test_stat = sms.durbin_watson(model_estimate.resid)
            
            r_sq = r_squared(y_full.iloc[:, 0], model_estimate.fittedvalues)
            
            feature_columns_adj = indep_Var_List
            k = len(feature_columns_adj)
            n = len(model_data_df1.iloc[model_data_df1.index.get_loc(model_data_df1.index.values[0]):-1])
            adj_r_sq = 1 - (1 - r_sq) * (n - 1) / (n - k - 1)
            
            mape_in = mean_absolute_percentage_error(y_actual_in, y_pred_in)
            mape_out = mean_absolute_percentage_error(y_actual_out, y_pred_out)
            
            mse_in = mean_squared_error(y_actual_in, y_pred_in)
            mse_out = mean_squared_error(y_actual_out, y_pred_out)
            
            rmse_in = sqrt(mean_squared_error(y_actual_in, y_pred_in))
            rmse_out = sqrt(mean_squared_error(y_actual_out, y_pred_out))
            
            rmspe_in = (np.sqrt(np.mean(np.square((y_actual_in - y_pred_in) / y_actual_in)))) * 100
            rmspe_out = (np.sqrt(np.mean(np.square((y_actual_out - y_pred_out) / y_actual_out)))) * 100
            
            correl_full = correlation_calc(dep_var=y_full, indep_vars=x_full)
            correl_in = correlation_calc(dep_var=y_in, indep_vars=x_in)
            correl_out = correlation_calc(dep_var=y_out, indep_vars=x_out)
            
            correl_full.rename(columns={"correlation": "correlation_full"}, inplace=True)
            correl_in.rename(columns={"correlation": "correlation_in"}, inplace=True)
            correl_out.rename(columns={"correlation": "correlation_out"}, inplace=True)
            
            correal = pd.concat([correl_full, correl_in["correlation_in"], correl_out["correlation_out"]], join="inner", axis=1)
            
            df_model_details["Rsquare"] = r_sq
            df_model_details["ADJRsq"] = adj_r_sq
            df_model_details["MAPE_in"] = mape_in
            df_model_details["RMSPE_in"] = rmspe_in
            df_model_details["MSE_in"] = mse_in
            df_model_details["RMSE_in"] = rmse_in
            df_model_details["MAPE_out"] = mape_out
            df_model_details["RMSPE_out"] = rmspe_out
            df_model_details["MSE_out"] = mse_out
            df_model_details["RMSE_out"] = rmse_out
            df_model_details["AutoCorrel_DW"] = dw_autocorr_test_stat
            df_model_details["Normality_pvalue"] = sw_test_normality_pval
            df_model_details["Normality_test"] = "Shapiro Wilk"
            df_model_details["Hetero_pvalue"] = bp_hetero_test_pval
            df_model_details["Hetero_desc"] = "Breusch-Pagan"
            
            df_model_details["y Actual In-Sample Mean"] = y_actual_in.mean()
            df_model_details["y Actual Out-Sample Mean"] = y_actual_out.mean()
            df_model_details["y Actual Full Mean"] = y_actual.mean()
            df_model_details["y Actual In-Sample St. Dev"] = statistics.stdev(y_actual_in)
            df_model_details["y Actual Out-Sample St.Dev"] = statistics.stdev(y_actual_out)
            df_model_details["y Actual Full St.Dev"] = statistics.stdev(y_actual)
            df_model_details["y Pred In-Sample Mean"] = y_pred_in.mean()
            df_model_details["y Pred Out-Sample Mean"] = y_pred_out.mean()
            df_model_details["y Pred Full Mean"] = y_pred.mean()
            df_model_details["y Pred In-Sample St.Dev"] = statistics.stdev(y_pred_in)
            df_model_details["y Pred Out-Sample St.Dev"] = statistics.stdev(y_pred_out)
            df_model_details["y Pred Full St.Dev"] = statistics.stdev(y_pred)
            
            df_model_details = df_model_details.reset_index().rename(columns={'index': 'Variable'})
            df_model_details = df_model_details.merge(correal, left_on=["Variable"], right_on=["Variable"], how="left")
            
            model_stat_df = model_build_df.dropna()
            
            if (series_type == "Actual") or (series_type == "Revised"):
                dep_adf, dep_trans_adf, residual_adf = OrderedDict(), OrderedDict(), OrderedDict()
                dep_adf["GIMS_ID"], dep_trans_adf["GIMS_ID"], residual_adf["GIMS_ID"] = self.GMIS, self.GMIS, self.GMIS
                dep_adf["Dependent_Variable_Name"], dep_trans_adf["Dependent_Variable_Name"], residual_adf["Dependent_Variable_Name"] = depVar, depVar, depVar
                dep_adf["Independent_Variable_Names"], dep_trans_adf["Independent_Variable_Names"], residual_adf["Independent_Variable_Names"] = str([x.strip("*") for x in indep_Var_List]), str([x.strip("*") for x in indep_Var_List]), str([x.strip("*") for x in indep_Var_List])
                dep_adf["Model_Score_Methodology"], dep_trans_adf["Model_Score_Methodology"], residual_adf["Model_Score_Methodology"] = self.modelScoremethodology, self.modelScoremethodology, self.modelScoremethodology
                dep_adf["Series_Type"], dep_trans_adf["Series_Type"], residual_adf["Series_Type"] = series_type, series_type, series_type
                dep_adf["variable"], dep_trans_adf["variable"], residual_adf["variable"] = depVar, f"{depVar}({transformDep})", "residual"
                
                for regression in ["nc", "c", "ct"]:
                    for maxlag in [0, 1, 2]:
                        model_dep = model_build_df.iloc[0:model_build_df.index.get_loc(inSample_endDate, method="nearest") + 1][depVar].dropna()
                        model_dep_trans = model_build_df.iloc[0:model_build_df.index.get_loc(inSample_endDate, method="nearest") + 1][depVar + transformDep].dropna()
                        
                        dep_adf[f"Stationarity_{regression}{str(maxlag)}_t"] = adfuller(model_dep, maxlag=maxlag, regression=regression, autolag=None)[0]
                        dep_adf[f"Stationarity_{regression}{str(maxlag)}_pVal"] = adfuller(model_dep, maxlag=maxlag, regression=regression, autolag=None)[1]
                        
                        dep_trans_adf[f"Stationarity_{regression}{str(maxlag)}_t"] = adfuller(model_dep_trans, maxlag=maxlag, regression=regression, autolag=None)[0]
                        dep_trans_adf[f"Stationarity_{regression}{str(maxlag)}_pVal"] = adfuller(model_dep_trans, maxlag=maxlag, regression=regression, autolag=None)[1]
                        
                        residual_adf[f"Stationarity_{regression}{str(maxlag)}_t"] = adfuller(model_estimate.resid.dropna(), maxlag=maxlag, regression=regression, autolag=None)[0]
                        residual_adf[f"Stationarity_{regression}{str(maxlag)}_pVal"] = adfuller(model_estimate.resid.dropna(), maxlag=maxlag, regression=regression, autolag=None)[1]
                
                df_dep_adf = pd.DataFrame([dep_adf])
                df_dep_trans_adf = pd.DataFrame([dep_trans_adf])
                df_residuals = pd.DataFrame([residual_adf])
                dep_stationarity = pd.concat([df_dep_adf, df_dep_trans_adf, df_residuals])
                
                indep_stationarity = pd.DataFrame()
                for indepVar, transformIndep in zip(indep_Var_List, transform_Indep_List):
                    indep_adf, indep_trans_adf = OrderedDict(), OrderedDict()
                    indep_adf["GIMS_ID"], indep_trans_adf["GIMS_ID"] = self.GMIS, self.GMIS
                    indep_adf["Dependent_Variable_Name"], indep_trans_adf["Dependent_Variable_Name"] = depVar, depVar
                    indep_adf["Independent_Variable_Names"], indep_trans_adf["Independent_Variable_Names"] = str([x.strip("*") for x in indep_Var_List]), str([x.strip("*") for x in indep_Var_List])
                    indep_adf["Model_Score_Methodology"], indep_trans_adf["Model_Score_Methodology"] = self.modelScoremethodology, self.modelScoremethodology
                    indep_adf["Series_Type"], indep_trans_adf["Series_Type"] = series_type, series_type
                    indepVar = indepVar[1:-1]
                    transformIndep = transformIndep[1:-1]
                    indep_adf["variable"], indep_trans_adf["variable"] = indepVar, f"{indepVar}({transformIndep})"
                    
                    for regression in ['nc', 'c', 'ct']:
                        for maxlag in [0, 1, 2]:
                            model_indep = model_build_df.iloc[0:model_build_df.index.get_loc(inSample_endDate, method="nearest") + 1][indepVar].dropna()
                            model_indep_trans = model_build_df.iloc[0:model_build_df.index.get_loc(inSample_endDate, method="nearest") + 1][indepVar + transformIndep].dropna()
                            
                            indep_adf[f"Stationarity_{regression}{str(maxlag)}_t"] = adfuller(model_indep, maxlag=maxlag, regression=regression, autolag=None)[0]
                            indep_adf[f"Stationarity_{regression}{str(maxlag)}_pVal"] = adfuller(model_indep, maxlag=maxlag, regression=regression, autolag=None)[1]
                            
                            indep_trans_adf[f"Stationarity_{regression}{str(maxlag)}_t"] = adfuller(model_indep_trans, maxlag=maxlag, regression=regression, autolag=None)[0]
                            indep_trans_adf[f"Stationarity_{regression}{str(maxlag)}_pVal"] = adfuller(model_indep_trans, maxlag=maxlag, regression=regression, autolag=None)[1]
                    
                    df_indep_adf = pd.DataFrame([indep_adf])
                    df_indep_trans_adf = pd.DataFrame([indep_trans_adf])
                    indep_stationarity = pd.concat([indep_stationarity, df_indep_adf, df_indep_trans_adf])
                
                stationarity_tests = pd.concat([dep_stationarity, indep_stationarity])
                
                model_stat_df = model_build_df.dropna()
                eg_test = OrderedDict()
                eg_test["GIMS_ID"] = self.GMIS
                eg_test["Dependent_Variable_Name"] = depVar
                eg_test["Independent_Variable_Names"] = str([x.strip("*") for x in indep_Var_List])
                eg_test["Model_Score_Methodology"] = self.modelScoremethodology
                eg_test["Series_Type"] = series_type
                
                for regression in ['nc', 'c', 'ct']:
                    for maxlag in [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]:
                        model_dep_coint = model_stat_df.iloc[0:model_stat_df.index.get_loc(inSample_endDate, method="nearest") + 1][depVar + self.depVarTransform]
                        model_indep_coint = model_stat_df.iloc[0:model_stat_df.index.get_loc(inSample_endDate, method="nearest") + 1][feature_columns]
                        
                        eg_test[f"EG_Coint_{regression}{maxlag}_t"] = coint(model_dep_coint, model_indep_coint, trend=regression, maxlag=maxlag, autolag=None)[0]
                        eg_test[f"EG_Coint_{regression}{maxlag}_pVal"] = coint(model_dep_coint, model_indep_coint, trend=regression, maxlag=maxlag, autolag=None)[1]
                
                df_eg = pd.DataFrame([eg_test])
                
            elif series_type == "Full":
                # Keep existing Full series_type code as is
                dep_adf, dep_trans_adf, residual_adf = OrderedDict(), OrderedDict(), OrderedDict()
                dep_adf["GIMS_ID"], dep_trans_adf["GIMS_ID"], residual_adf["GIMS_ID"] = self.GMIS, self.GMIS, self.GMIS
                dep_adf["Dependent_Variable_Name"], dep_trans_adf["Dependent_Variable_Name"], residual_adf["Dependent_Variable_Name"] = depVar, depVar, depVar
                dep_adf["Independent_Variable_Names"], dep_trans_adf["Independent_Variable_Names"], residual_adf["Independent_Variable_Names"] = str([x.strip("*") for x in indep_Var_List]), str([x.strip("*") for x in indep_Var_List]), str([x.strip("*") for x in indep_Var_List])
                dep_adf["Model_Score_Methodology"], dep_trans_adf["Model_Score_Methodology"], residual_adf["Model_Score_Methodology"] = self.modelScoremethodology, self.modelScoremethodology, self.modelScoremethodology
                dep_adf["Series_Type"], dep_trans_adf["Series_Type"], residual_adf["Series_Type"] = series_type, series_type, series_type
                dep_adf["variable"], dep_trans_adf["variable"], residual_adf["variable"] = depVar, f"{depVar}({self.depVarTransform})", "residual"
                
                for regression in ["nc", "c", "ct"]:
                    for maxlag in [0, 1, 2]:
                        model_dep = model_build_df[[depVar]].dropna()
                        model_dep_trans = model_build_df[[depVar + self.depVarTransform]].dropna()
                        
                        dep_adf[f"Stationarity_{regression}{str(maxlag)}_t"] = adfuller(model_dep, maxlag=maxlag, regression=regression, autolag=None)[0]
                        dep_adf[f"Stationarity_{regression}{str(maxlag)}_pVal"] = adfuller(model_dep, maxlag=maxlag, regression=regression, autolag=None)[1]
                        
                        dep_trans_adf[f"Stationarity_{regression}{str(maxlag)}_t"] = adfuller(model_dep_trans, maxlag=maxlag, regression=regression, autolag=None)[0]
                        dep_trans_adf[f"Stationarity_{regression}{str(maxlag)}_pVal"] = adfuller(model_dep_trans, maxlag=maxlag, regression=regression, autolag=None)[1]
                        
                        residual_adf[f"Stationarity_{regression}{str(maxlag)}_t"] = adfuller(model_estimate.resid.dropna(), maxlag=maxlag, regression=regression, autolag=None)[0]
                        residual_adf[f"Stationarity_{regression}{str(maxlag)}_pVal"] = adfuller(model_estimate.resid.dropna(), maxlag=maxlag, regression=regression, autolag=None)[1]
                
                df_dep_adf = pd.DataFrame([dep_adf])
                df_dep_trans_adf = pd.DataFrame([dep_trans_adf])
                df_residuals = pd.DataFrame([residual_adf])
                dep_stationarity = pd.concat([df_dep_adf, df_dep_trans_adf, df_residuals])
                
                indep_stationarity = pd.DataFrame()
                for indepVar, transformIndep in zip(indep_Var_List, transform_Indep_List):
                    indep_adf, indep_trans_adf = OrderedDict(), OrderedDict()
                    indep_adf["GIMS_ID"], indep_trans_adf["GIMS_ID"] = self.GMIS, self.GMIS
                    indep_adf["Dependent_Variable_Name"], indep_trans_adf["Dependent_Variable_Name"] = depVar, depVar
                    indep_adf["Independent_Variable_Names"], indep_trans_adf["Independent_Variable_Names"] = str([x.strip("*") for x in indep_Var_List]), str([x.strip("*") for x in indep_Var_List])
                    indep_adf["Model_Score_Methodology"], indep_trans_adf["Model_Score_Methodology"] = self.modelScoremethodology, self.modelScoremethodology
                    indep_adf["Series_Type"], indep_trans_adf["Series_Type"] = series_type, series_type
                    indepVar = indepVar[1:-1]
                    transformIndep = transformIndep[1:-1]
                    indep_adf["variable"], indep_trans_adf["variable"] = indepVar, f"{indepVar}({transformIndep})"
                    
                    for regression in ['nc', 'c', 'ct']:
                        for maxlag in [0, 1, 2]:
                            model_indep = model_build_df[[indepVar]].dropna()
                            model_indep_trans = model_build_df[[indepVar + transformIndep]].drop