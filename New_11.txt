<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Upload Excel File</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-image: url('/static/chart_3.jfif'); /* Specify your background image URL */
            background-size: cover;
            background-position: center;
            color: white;
        }
        .container {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        .box {
            width: 500px;
            height: 280px;
            margin: 30px;
            padding: 30px;
            border-radius: 10px;
            background-color: rgba(0, 0, 0, 0.5); /* Semi-transparent black background */
            text-align: center;
        }
        .box h2 {
            font-weight: bold;
        }
        .box p {
            font-weight: bold;
            margin-top: 10px;
        }
        .button {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #007bff; /* Blue color, adjust as needed */
            color: white;
            border: 2px solid white; /* White border */
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .button:hover {
            background-color: #0056b3; /* Darker shade of blue on hover */
        }.logo {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 100px; /* Adjust width as needed */
            height: auto;
        }.file-input {
            display: inline-block;
            padding: 15px 30px;
            background-color: #007bff; /* Blue background color */
            color: white;
            border: 2px solid white; /* White border */
            border-radius: 5px;
            font-size: 18px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .file-input:hover {
            background-color: #0056b3; /* Darker shade of blue on hover */
        }.upload-form {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 50px;
        }.upload-button {
            margin-top: 20px;
            padding: 15px 30px;
            background-color: #007bff; /* Blue background color */
            color: white;
            border: 2px solid white; /* White border */
            border-radius: 5px;
            font-size: 18px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .upload-button:hover {
            background-color: #28a745; /* Green background color on hover */
        }
    </style>
</head>
<body>
    <img src="/static/logo_1.jfif" alt="Logo" class="logo">
    <h1>Upload Excel File</h1>
    <div class="container">
        <div class="box">
            <h1>Upload Excel File</h1>
    <form method="post" enctype="multipart/form-data" class="upload-form">
        {% csrf_token %}
        <input type="file" name="excel_file" accept=".xlsx, .xls" class="file-input">
        <button type="submit" class="upload-button">Upload</button>
    </form>
        </div>
    </div>
    <form method="post" enctype="multipart/form-data" action="dashboard" id="uploadForm" style="display: none;"></form>
</body>
</html>







































<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Dashboard</title>
    <!-- Plotly.js -->
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        /* Add your CSS styles here */
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-image: url('/static/chart_3.jfif'); /* Specify the URL of your background image */
            background-size: cover;
            background-position: center;
            color: black; /* Set text color to black */
        }

        /* Table styles */
        .table {
            border-collapse: collapse;
            overflow-x: auto; /* Enable horizontal scrolling */
        }

        th, td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #ddd;
            font-weight: bold; /* Make column names bold */
        }

        th {
            background-color: red; /* Set column headers background color */
            color: white; /* Set column headers text color */
        }

        tr:nth-child(even) {
            background-color: #f2f2f2; /* Light green background for even rows */
        }

        tr:hover {
            background-color: #ddd; /* Darker green background on hover */
        }


        h1 {
            text-align: center;
            margin-top: 30px;
        }
        .dashboard-container {
            border: 1px solid #ccc; /* Light gray border */
            border-radius: 5px; /* Rounded corners */
            padding: 20px;
            margin: 20px auto;
            max-width: 1450px; /* Limit width for better readability */
            background: url('/static/chart_2.jfif') no-repeat center center fixed, #ccc; /* Background image and gray color */
            background-size: cover;
            background-color: #ccc; /* White background */
            overflow-x: auto; /* Ensure content doesn't overflow (consider removing if needed) */
        }
        .dropdown-container label {
            font-size: 20px; /* Increase font size */
            font-weight: bold; /* Make font bold */
            color: black; /* Set text color to black */
        }

        .dropdown-container select {
            font-size: 18px; /* Increase font size */
        }

        .dropdown-container select:hover {
            border-color: #0056b3; /* Darker shade of blue on hover */
        }

        .dropdown-container select:focus {
            outline: none; /* Remove default focus outline */
            border-color: #0056b3; /* Darker shade of blue when focused */
        }

        input[type="submit"] {
            padding: 3.5px 18px; /* Adjust padding */
            font-size: 18px; /* Increase font size */
            font-weight: bold; /* Make font bold */
            color: black; /* Set text color to black */
            background-color: #007bff; /* Blue background color */
            border: 2px solid white; /* Blue border */
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        input[type="submit"]:hover {
            background-color: #0056b3; /* Darker shade of blue on hover */
        }

        .logo-container {
            text-align: right;
            margin-bottom: 20px;
        }
        .logo {
            width: 100px;
            height: auto;
            border: 1px solid #ccc; /* Light gray border */
            border-radius: 5px;
        }
        .table {
            border-collapse: collapse;
            margin-bottom: 20px;
            background-color: #fff;
            overflow-x: auto; /* Horizontal scrollbar */
        }


    </style>
</head>
<body>
    <div class="logo-container">
        <img src="/static/logo_1.jfif" alt="Logo" class="logo">
    </div>
    <h1>Dashboard</h1>
    <div class="dashboard-container">
        <form action="{% url 'dashboard' %}" method="get">
            <div class="dropdown-container">
                <label for="variable">Variable:</label>
                <select name="variable" id="variable">
                    {% for option in variable_options %}
                        <option value="{{ option }}" {% if option == selected_variable %}selected{% endif %}>{{ option }}</option>
                    {% endfor %}
                </select>
                <label for="country">Country:</label>
                <select name="country" id="country">
                    {% for option in country_options %}
                        <option value="{{ option }}" {% if option == selected_country %}selected{% endif %}>{{ option }}</option>
                    {% endfor %}
                </select>
                <label for="model">Model:</label>
                <select name="model" id="model">
                    {% for option in model_options %}
                        <option value="{{ option }}" {% if option == selected_model %}selected{% endif %}>{{ option }}</option>
                    {% endfor %}
                </select>
                <input type="submit" value="Submit">
            </div>
        </form>

        {% if plot_div_single %}
            {{ plot_div_single|safe }}
        {% endif %}

        {% if filtered_data %}
            <h2>Data</h2>
            <table>
                <thead>
                    <tr>
                        {% for column in filtered_data.0.keys %}
                            <th>{{ column }}</th>
                        {% endfor %}
                    </tr>
                </thead>
                <tbody>
                    {% for row in filtered_data %}
                        <tr>
                            {% for value in row.values %}
                                <td>{{ value }}</td>
                            {% endfor %}
                        </tr>
                    {% endfor %}
                </tbody>
            </table>
        {% else %}
            <p>No data available for the selected options.</p>
        {% endif %}
    </div>
</body>
</html>


































def dashboard(request):
    data = request.session.get("data", [])
    variable_options = request.session.get('variable_options', [])
    country_options = request.session.get('country_options', [])
    model_options = request.session.get('model_options', [])

    selected_variable = request.GET.get('variable', variable_options[0] if variable_options else None)
    selected_country = request.GET.get('country', country_options[0] if country_options else None)
    selected_model = request.GET.get('model', model_options[0] if model_options else None)

    # Convert data to DataFrame
    df = pd.DataFrame(data)

    # Filter country options based on selected variable
    filtered_country_options = sorted(df[df['Variable'] == selected_variable]['Region'].unique().tolist())

    # Update session variable for country options
    request.session['country_options'] = filtered_country_options

    # Filter model options based on selected variable and country
    filtered_model_options = sorted(df[(df['Variable'] == selected_variable) &
                                       (df['Region'] == selected_country)]['Model'].unique().tolist())

    # Update session variable for model options
    request.session['model_options'] = filtered_model_options

    # Filter the DataFrame based on selected filters
    filtered_data = df[(df['Variable'] == selected_variable) &
                      (df['Region'] == selected_country) &
                      (df['Model'] == selected_model)]

    if not filtered_data.empty:
        # Filter the DataFrame to keep only rows with unique scenarios
        unique_scenarios = filtered_data['Scenario'].unique()
        filtered_data_unique = filtered_data.drop_duplicates(subset=['Scenario'])

        # Convert the filtered DataFrame to a dictionary of records
        filtered_data_dict = filtered_data_unique.to_dict('records')
    else:
        filtered_data_dict = []

    if not filtered_data.empty:
        years = [2020, 2025, 2030, 2035, 2040, 2045, 2050]
        traces = []

        for scenario, scenario_data in filtered_data.groupby('Scenario'):
            trace = go.Scatter(
                x=years,
                y=scenario_data[years].values.flatten(),
                mode='lines+markers',
                name=scenario
            )
            traces.append(trace)

        # Create the multiline plot
        layout = go.Layout(
            title=selected_variable,
            xaxis=dict(title="Year", showgrid=False, tickfont=dict(color='black')),
            yaxis=dict(title="Value", showgrid=False, tickfont=dict(color="black")),
            height=750,
            plot_bgcolor='rgba(0,0,0,0)',
            paper_bgcolor='rgba(0,0,0,0)'
        )

        fig_single = go.Figure(data=traces, layout=layout)
        plot_div_single = plot(fig_single, output_type='div', include_plotlyjs=False)
    else:
        plot_div_single = None

    context = {
        'variable_options': variable_options,
        'country_options': filtered_country_options,
        'model_options': filtered_model_options,  # Use filtered model options
        'selected_variable': selected_variable,
        'selected_country': selected_country,
        'selected_model': selected_model,
        'filtered_data': filtered_data_dict,
        'plot_div_single': plot_div_single,
    }

    return render(request, 'dashboard.html', context)


















import pandas as pd
import plotly.graph_objs as go
from plotly.offline import plot

def dashboard(request):

    # Load data from Excel file
    df = pd.read_excel("static/data/data_dashboard.xlsx")

    selected_variable = request.GET.get('variable', None)
    selected_country = request.GET.get('country', None)
    selected_model = request.GET.get("model", None)

    if selected_variable and selected_country and selected_model:
        # Filter the DataFrame based on selected filters
        filtered_data = df[(df['Variable'] == selected_variable) &
                           (df['Region'] == selected_country) &
                           (df['Model'] == selected_model)]

        if not filtered_data.empty:
            # Check if filtered data is not empty
            years = [2020, 2025, 2030, 2035, 2040, 2045, 2050]
            traces = []

            for scenario, scenario_data in filtered_data.groupby('Scenario'):
                trace = go.Scatter(
                    x=years,
                    y=scenario_data[years].values.flatten(),
                    mode='lines+markers',
                    line=dict(width=5, shape='spline'),
                    name=scenario
                )
                traces.append(trace)

            # Create the multiline plot
            layout = go.Layout(
                title=selected_variable,
                xaxis=dict(title='Year', showgrid=False, tickfont=dict(color="black")),
                yaxis=dict(title='Value', showgrid=False, tickfont=dict(color="black")),
                height=750,
                plot_bgcolor='rgba(0,0,0,0)',
                paper_bgcolor='rgba(8,8,8,8)'
            )

            fig = go.Figure(data=traces, layout=layout)
            plot_div_single = plot(fig, output_type='div', include_plotlyjs=False)

        else:
            plot_div_single = None

    else:
        filtered_data = None
        plot_div_single = None

    context = {
        'variable_options': df['Variable'].unique().tolist(),
        'country_options': df['Country'].unique().tolist(),
        'model_options': df['Model'].unique().tolist(),
        'selected_variable': selected_variable,
        'selected_country': selected_country,
        'selected_model': selected_model,
        'filtered_data': filtered_data,
        'plot_div_single': plot_div_single,
    }

    return render(request, 'dashboard.html', context)


























import pandas as pd
import plotly.graph_objs as go
from plotly.offline import plot
from django.http import JsonResponse

def dashboard(request):
    # Load data from Excel file
    df = pd.read_excel("static/data/data_dashboard.xlsx")

    # Get selected options from request
    selected_variable = request.GET.get('variable', None)
    selected_country = request.GET.get('country', None)
    selected_model = request.GET.get("model", None)

    if selected_variable:
        # Filter country options based on selected variable
        country_options = df[df['Variable'] == selected_variable]['Region'].unique().tolist()
    else:
        country_options = []

    if selected_variable and selected_country:
        # Filter model options based on selected variable and country
        model_options = df[(df['Variable'] == selected_variable) & (df['Region'] == selected_country)]['Model'].unique().tolist()
    else:
        model_options = []

    if selected_variable and selected_country and selected_model:
        # Filter the DataFrame based on selected filters
        filtered_data = df[(df['Variable'] == selected_variable) &
                           (df['Region'] == selected_country) &
                           (df['Model'] == selected_model)]

        if not filtered_data.empty:
            # Create traces for each scenario
            years = [2020, 2025, 2030, 2035, 2040, 2045, 2050]
            traces = []

            for scenario, scenario_data in filtered_data.groupby('Scenario'):
                trace = go.Scatter(
                    x=years,
                    y=scenario_data[years].values.flatten(),
                    mode='lines+markers',
                    line=dict(width=5, shape='spline'),
                    name=scenario
                )
                traces.append(trace)

            # Create the multiline plot
            layout = go.Layout(
                title=selected_variable,
                xaxis=dict(title='Year', showgrid=False, tickfont=dict(color="black")),
                yaxis=dict(title='Value', showgrid=False, tickfont=dict(color="black")),
                height=750,
                plot_bgcolor='rgba(0,0,0,0)',
                paper_bgcolor='rgba(8,8,8,8)'
            )

            fig = go.Figure(data=traces, layout=layout)
            plot_div_single = plot(fig, output_type='div', include_plotlyjs=False)

        else:
            # If filtered data is empty, set plot_div_single to None
            plot_div_single = None

    else:
        # If any of the options is not selected, set filtered_data and plot_div_single to None
        filtered_data, plot_div_single = None, None

    # Prepare context to pass to the template
    context = {
        'variable_options': df['Variable'].unique().tolist(),
        'country_options': country_options,
        'model_options': model_options,
        'selected_variable': selected_variable,
        'selected_country': selected_country,
        'selected_model': selected_model,
        'filtered_data': filtered_data,
        'plot_div_single': plot_div_single,
    }

    return render(request, 'dashboard.html', context)

def get_country_options(request):
    # Load data from Excel file
    df = pd.read_excel("static/data/data_dashboard.xlsx")

    # Get selected variable from request
    selected_variable = request.GET.get('variable')

    # Filter country options based on selected variable
    country_options = df[df['Variable'] == selected_variable]['Region'].unique().tolist()

    # Return JSON response with country options
    return JsonResponse(country_options, safe=False)

def get_model_options(request):
    # Load data from Excel file
    df = pd.read_excel("static/data/data_dashboard.xlsx")

    # Get selected variable and country from request
    selected_variable = request.GET.get('variable')
    selected_country = request.GET.get('country')

    # Filter model options based on selected variable and country
    model_options = df[(df['Variable'] == selected_variable) & (df['Region'] == selected_country)]['Model'].unique().tolist()

    # Return JSON response with model options
    return JsonResponse(model_options, safe=False)




















import pandas as pd
import plotly.graph_objs as go
from plotly.offline import plot

def dashboard(request):
  # Load data from Excel file
  df = pd.read_excel("static/data/data_dashboard.xlsx")

  # Get selected options from request
  selected_variable = request.GET.get('variable', None)
  selected_country = request.GET.get('country', None)
  selected_model = request.GET.get("model", None)

  # Prepare initial context with all options
  context = {
      'variable_options': df['Variable'].unique().tolist(),
      'country_options': [],  # Initially empty for cascading
      'model_options': [],    # Initially empty for cascading
      'selected_variable': selected_variable,
      'selected_country': selected_country,
      'selected_model': selected_model,
      'filtered_data': None,
      'plot_div_single': None,
  }

  # Filter variable options based on selection (if any)
  if selected_variable:
      filtered_df = df[df['Variable'] == selected_variable]
      context['variable_options'] = [selected_variable]  # Keep only selected

      # Filter country options based on selected variable (if data allows)
      country_options = filtered_df['Region'].unique().tolist()
      if country_options:
          context['country_options'] = country_options

      # Filter model options based on selected variable and country (if data allows)
      if selected_country:
          filtered_df = filtered_df[filtered_df['Region'] == selected_country]
          model_options = filtered_df['Model'].unique().tolist()
          if model_options:
              context['model_options'] = model_options

  # Data filtering and plot generation (similar logic as before)
  if selected_variable and selected_country and selected_model:
      # ... (Your existing data filtering and plot generation logic here)

  # Return context to the template
  return render(request, 'dashboard.html', context)


















import pandas as pd
import plotly.graph_objs as go
from plotly.offline import plot

def dashboard(request):
    # Load data from Excel file
    df = pd.read_excel("static/data/data_dashboard.xlsx")

    # Get selected options from request
    selected_variable = request.GET.get('variable', None)
    selected_country = request.GET.get('country', None)
    selected_model = request.GET.get("model", None)

    # Filter the DataFrame based on selected filters
    if selected_variable and selected_country and selected_model:
        filtered_data = df[(df['Variable'] == selected_variable) &
                           (df['Region'] == selected_country) &
                           (df['Model'] == selected_model)]
        if not filtered_data.empty:
            # Create traces for each scenario
            years = [2020, 2025, 2030, 2035, 2040, 2045, 2050]
            traces = []
            for scenario, scenario_data in filtered_data.groupby('Scenario'):
                trace = go.Scatter(
                    x=years,
                    y=scenario_data[years].values.flatten(),
                    mode='lines+markers',
                    line=dict(width=5, shape='spline'),
                    name=scenario
                )
                traces.append(trace)
            # Create the multiline plot
            layout = go.Layout(
                title=selected_variable,
                xaxis=dict(title='Year', showgrid=False, tickfont=dict(color="black")),
                yaxis=dict(title='Value', showgrid=False, tickfont=dict(color="black")),
                height=750,
                plot_bgcolor='rgba(0,0,0,0)',
                paper_bgcolor='rgba(8,8,8,8)'
            )
            fig = go.Figure(data=traces, layout=layout)
            plot_div_single = plot(fig, output_type='div', include_plotlyjs=False)
        else:
            # If filtered data is empty, set plot_div_single to None
            plot_div_single = None
    else:
        # If any of the options is not selected, set filtered_data and plot_div_single to None
        filtered_data, plot_div_single = None, None

    # Get unique values for each column
    variable_options = df['Variable'].unique().tolist()
    country_options = df['Region'].unique().tolist()
    model_options = df['Model'].unique().tolist()

    # Filter country options based on selected variable
    if selected_variable:
        country_options = df[df['Variable'] == selected_variable]['Region'].unique().tolist()

    # Filter model options based on selected variable and country
    if selected_variable and selected_country:
        model_options = df[(df['Variable'] == selected_variable) & (df['Region'] == selected_country)]['Model'].unique().tolist()

    # Prepare context to pass to the template
    context = {
        'variable_options': variable_options,
        'country_options': country_options,
        'model_options': model_options,
        'selected_variable': selected_variable,
        'selected_country': selected_country,
        'selected_model': selected_model,
        'filtered_data': filtered_data,
        'plot_div_single': plot_div_single,
    }

    return render(request, 'dashboard.html', context)





































<body>
    <div class="logo-container">
    </div>
    <h1>Dashboard for Scenario</h1>
    <div class="dashboard-container">
        <form action="{% url 'dashboard' %}" method="get">
            <div class="dropdown-container">
                <label for="variable">Variable:</label>
                <select name="variable" id="variable" onchange="updateCountryOptions(this.value)">
                    <option value="">Select Variable</option>
                    {% for option in variable_options %}
                        <option value="{{ option }}" {% if option == selected_variable %}selected{% endif %}>{{ option }}</option>
                    {% endfor %}
                </select>

                <label for="country">Country:</label>
                <select name="country" id="country" onchange="updateModelOptions(this.value)">
                    <option value="">Select Country</option>
                    {% for option in country_options %}
                        <option value="{{ option }}" {% if option == selected_country %}selected{% endif %}>{{ option }}</option>
                    {% endfor %}
                </select>

                <label for="model">Model:</label>
                <select name="model" id="model">
                    <option value="">Select Model</option>
                    {% for option in model_options %}
                        <option value="{{ option }}" {% if option == selected_model %}selected{% endif %}>{{ option }}</option>
                    {% endfor %}
                </select>

                <input type="submit" value="Submit">
            </div>
        </form>

        {% if plot_div_single %}
            {{ plot_div_single|safe }}
        {% endif %}

        {% if filtered_data %}
            <h2>Data</h2>
            <table>
                <thead>
                    <tr>
                        {% for column in filtered_data.columns %}
                            <th>{{ column }}</th>
                        {% endfor %}
                    </tr>
                </thead>
                <tbody>
                    {% for _, row in filtered_data.iterrows %}
                        <tr>
                            {% for value in row %}
                                <td>{{ value }}</td>
                            {% endfor %}
                        </tr>
                    {% endfor %}
                </tbody>
            </table>
        {% else %}
            <p>No data available for the selected options.</p>
        {% endif %}
    </div>

    <script>
        var countryOptions = {{ country_options|safe }};
        var modelOptions = {{ model_options|safe }};

        function updateCountryOptions(selectedVariable) {
            var countrySelect = document.getElementById('country');
            countrySelect.innerHTML = '<option value="">Select Country</option>';

            if (selectedVariable) {
                var filteredCountries = countryOptions.filter(function(country) {
                    return country.startsWith(selectedVariable);
                });

                filteredCountries.forEach(function(country) {
                    var option = document.createElement('option');
                    option.value = country;
                    option.text = country;
                    countrySelect.add(option);
                });
            }
        }

        function updateModelOptions(selectedCountry) {
            var modelSelect = document.getElementById('model');
            modelSelect.innerHTML = '<option value="">Select Model</option>';

            if (selectedCountry) {
                var filteredModels = modelOptions.filter(function(model) {
                    return model.startsWith(selectedCountry);
                });

                filteredModels.forEach(function(model) {
                    var option = document.createElement('option');
                    option.value = model;
                    option.text = model;
                    modelSelect.add(option);
                });
            }
        }
    </script>
</body>





{% if filtered_data.empty %}
    <p>No data available for the selected options.</p>
{% else %}
    <h2>Data</h2>
    <table>
        <thead>
            <tr>
                {% for column in filtered_data.columns %}
                    <th>{{ column }}</th>
                {% endfor %}
            </tr>
        </thead>
        <tbody>
            {% for _, row in filtered_data.iterrows %}
                <tr>
                    {% for value in row %}
                        <td>{{ value }}</td>
                    {% endfor %}
                </tr>
            {% endfor %}
        </tbody>
    </table>
{% endif %}






















<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Dashboard</title>
    <!-- Plotly.js -->
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        /* Add your CSS styles here */
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #ffffff, #ffcccb);
            background-size: 400% 400%;
            animation: gradientAnimation 15s ease infinite;
            color: #333;
        }

        @keyframes gradientAnimation {
            0% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
            100% {
                background-position: 0% 50%;
            }
        }

        /* Table styles */
        .table {
            border-collapse: collapse;
            overflow-x: auto;
            background-color: #fff;
            color: #333;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }

        th, td {
            padding: 10px;
            text-align: left;
            border: 1px solid #ddd;
            font-weight: bold;
            border-radius: 5px;
        }

        th {
            background-color: #333;
            color: #fff;
        }

        tr:nth-child(even) {
            background-color: #f2f2f2;
        }

        tr:hover {
            background-color: #e6e6e6;
        }

        h1 {
            text-align: center;
            margin-top: 30px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .dashboard-container {
            border: 1px solid #ccc;
            border-radius: 10px;
            padding: 20px;
            margin: 20px auto;
            max-width: 1450px;
            background-color: #f5f5f5;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            overflow-x: auto;
        }

        .dropdown-container label {
            font-size: 20px;
            font-weight: bold;
            color: #333;
        }

        .dropdown-container select {
            font-size: 18px;
            padding: 10px 20px;
            border-radius: 20px;
            background-color: #ffcccb;
            color: #333;
            font-weight: bold;
            border: none;
            outline: none;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
        }

        .dropdown-container select:hover {
            background-color: #ff7f7f;
        }

        .dropdown-container select:focus {
            box-shadow: 0 0 5px rgba(255, 127, 127, 0.5);
        }

        input[type="submit"] {
            padding: 8px 16px;
            font-size: 18px;
            font-weight: bold;
            color: #fff;
            background-color: #8b0000;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        input[type="submit"]:hover {
            background-color: #ff4500;
        }

        .logo-container {
            text-align: right;
            margin-bottom: 20px;
        }

        .logo {
            width: 100px;
            height: auto;
            border-radius: 50%;
            animation: logoAnimation 5s infinite;
        }

        @keyframes logoAnimation {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 127, 127, 0.7);
            }
            70% {
                box-shadow: 0 0 0 20px rgba(255, 127, 127, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(255, 127, 127, 0);
            }
        }






<!--        /* Add your CSS styles here */-->
<!--        body {-->
<!--            margin: 0;-->
<!--            padding: 0;-->
<!--            font-family: Arial, sans-serif;-->
<!--            background-image: url('/static/chart_3.jfif'); /* Specify the URL of your background image */-->
<!--            background-size: cover;-->
<!--            background-position: center;-->
<!--            color: black; /* Set text color to black */-->
<!--        }-->

<!--        /* Table styles */-->
<!--        .table {-->
<!--            border-collapse: collapse;-->
<!--            overflow-x: auto; /* Enable horizontal scrolling */-->
<!--        }-->

<!--        th, td {-->
<!--            padding: 10px;-->
<!--            text-align: left;-->
<!--            border-bottom: 1px solid #ddd;-->
<!--            font-weight: bold; /* Make column names bold */-->
<!--        }-->

<!--        th {-->
<!--            background-color: red; /* Set column headers background color */-->
<!--            color: white; /* Set column headers text color */-->
<!--        }-->

<!--        tr:nth-child(even) {-->
<!--            background-color: #f2f2f2; /* Light green background for even rows */-->
<!--        }-->

<!--        tr:hover {-->
<!--            background-color: #ddd; /* Darker green background on hover */-->
<!--        }-->


<!--        h1 {-->
<!--            text-align: center;-->
<!--            margin-top: 30px;-->
<!--        }-->
<!--        .dashboard-container {-->
<!--            border: 1px solid #ccc; /* Light gray border */-->
<!--            border-radius: 5px; /* Rounded corners */-->
<!--            padding: 20px;-->
<!--            margin: 20px auto;-->
<!--            max-width: 1450px; /* Limit width for better readability */-->
<!--            background: url('/static/chart_2.jfif') no-repeat center center fixed, #ccc; /* Background image and gray color */-->
<!--            background-size: cover;-->
<!--            background-color: #ccc; /* White background */-->
<!--            overflow-x: auto; /* Ensure content doesn't overflow (consider removing if needed) */-->
<!--        }-->
<!--        .dropdown-container label {-->
<!--            font-size: 20px; /* Increase font size */-->
<!--            font-weight: bold; /* Make font bold */-->
<!--            color: black; /* Set text color to black */-->
<!--        }-->

<!--        .dropdown-container select {-->
<!--            font-size: 18px; /* Increase font size */-->
<!--        }-->

<!--        .dropdown-container select:hover {-->
<!--            border-color: #0056b3; /* Darker shade of blue on hover */-->
<!--        }-->

<!--        .dropdown-container select:focus {-->
<!--            outline: none; /* Remove default focus outline */-->
<!--            border-color: #0056b3; /* Darker shade of blue when focused */-->
<!--        }-->

<!--        input[type="submit"] {-->
<!--            padding: 3.5px 18px; /* Adjust padding */-->
<!--            font-size: 18px; /* Increase font size */-->
<!--            font-weight: bold; /* Make font bold */-->
<!--            color: black; /* Set text color to black */-->
<!--            background-color: #007bff; /* Blue background color */-->
<!--            border: 2px solid white; /* Blue border */-->
<!--            border-radius: 5px;-->
<!--            cursor: pointer;-->
<!--            transition: background-color 0.3s ease;-->
<!--        }-->

<!--        input[type="submit"]:hover {-->
<!--            background-color: #0056b3; /* Darker shade of blue on hover */-->
<!--        }-->

<!--        .logo-container {-->
<!--            text-align: right;-->
<!--            margin-bottom: 20px;-->
<!--        }-->
<!--        .logo {-->
<!--            width: 100px;-->
<!--            height: auto;-->
<!--            border: 1px solid #ccc; /* Light gray border */-->
<!--            border-radius: 5px;-->
<!--        }-->
<!--        .table {-->
<!--            border-collapse: collapse;-->
<!--            margin-bottom: 20px;-->
<!--            background-color: #fff;-->
<!--            overflow-x: auto; /* Horizontal scrollbar */-->
<!--        }-->

    </style>
</head>




<body>
    <div class="logo-container">
    </div>
    <h1>Dashboard for Scenario</h1>
    <div class="dashboard-container">
        <form id="dashboard-form">
            <div class="dropdown-container">
<!--                <label for="variable">Variable:</label>-->
                <select name="variable" id="variable" onchange="updateRegionOptions(this.value)">
                    <option value="">Select Variable</option>
                    {% for option in variable_options %}
                        <option value="{{ option }}" {% if option == selected_variable %}selected{% endif %}>{{ option }}</option>
                    {% endfor %}
                </select>

<!--                <label for="region">Region:</label>-->
                <select name="region" id="region" onchange="updateModelOptions(this.value)">
                    <option value="">Select Region</option>
                    {% for option in region_options %}
                        <option value="{{ option }}" {% if option == selected_region %}selected{% endif %}>{{ option }}</option>
                    {% endfor %}
                </select>

<!--                <label for="model">Model:</label>-->
                <select name="model" id="model">
                    <option value="">Select Model</option>
                    {% for option in model_options %}
                        <option value="{{ option }}" {% if option == selected_model %}selected{% endif %}>{{ option }}</option>
                    {% endfor %}
                </select>

<!--                <label for="plot_type">Plot Type:</label>-->
                <select name="plot_type" id="plot_type">
                    <option value="line" {% if selected_plot_type == "line" %}selected{% endif %}>Line</option>
                    <option value="line+marker" {% if selected_plot_type == "line+marker" %}selected{% endif %}>Line+Marker</option>
                    <option value="bar" {% if selected_plot_type == "bar" %}selected{% endif %}>Bar</option>
                </select>
            </div>
        </form>

        {% if plot_div_single %}
            {{ plot_div_single|safe }}
        {% endif %}

        {% if not filtered_data.empty %}
            <h2>Data</h2>
            <table>
                <thead>
                    <tr>
                        {% for column in filtered_data.columns %}
                            <th>{{ column }}</th>
                        {% endfor %}
                    </tr>
                </thead>
                <tbody>
                    {% for _, row in filtered_data.iterrows %}
                        <tr>
                            {% for value in row %}
                                <td>{{ value }}</td>
                            {% endfor %}
                        </tr>
                    {% endfor %}
                </tbody>
            </table>
        {% else %}
            <p>No data available for the selected options.</p>
        {% endif %}
    </div>

    <script>
        var regionOptions = {{ region_options|safe }};
        var modelOptions = {{ model_options|safe }};

        function updateRegionOptions(selectedVariable) {
            var regionSelect = document.getElementById('region');
            regionSelect.innerHTML = '<option value="">Select Region</option>';

            if (selectedVariable) {
                var filteredRegions = regionOptions.filter(function(region) {
                    return region.startsWith(selectedVariable);
                });

                filteredRegions.forEach(function(region) {
                    var option = document.createElement('option');
                    option.value = region;
                    option.text = region;
                    regionSelect.add(option);
                });
            }
        }

        function updateModelOptions(selectedRegion) {
            var modelSelect = document.getElementById('model');
            modelSelect.innerHTML = '<option value="">Select Model</option>';

            if (selectedRegion) {
                var filteredModels = modelOptions.filter(function(model) {
                    return model.startsWith(selectedRegion);
                });

                filteredModels.forEach(function(model) {
                    var option = document.createElement('option');
                    option.value = model;
                    option.text = model;
                    modelSelect.add(option);
                });
            }
        }

        // Add event listener to the form
        document.getElementById('dashboard-form').addEventListener('change', function() {
            // Submit the form when any dropdown value changes
            this.submit();
        });
    </script>
</body>




<!--<body>-->
<!--    <div class="logo-container">-->
<!--    </div>-->
<!--    <h1>Dashboard for Scenario</h1>-->
<!--    <div class="dashboard-container">-->
<!--        <form id="dashboard-form">-->
<!--            <div class="dropdown-container">-->
<!--                <label for="variable">Variable:</label>-->
<!--                <select name="variable" id="variable" onchange="updateRegionOptions(this.value)">-->
<!--                    <option value="">Select Variable</option>-->
<!--                    {% for option in variable_options %}-->
<!--                        <option value="{{ option }}" {% if option == selected_variable %}selected{% endif %}>{{ option }}</option>-->
<!--                    {% endfor %}-->
<!--                </select>-->

<!--                <label for="region">Region:</label>-->
<!--                <select name="region" id="region" onchange="updateModelOptions(this.value)">-->
<!--                    <option value="">Select Region</option>-->
<!--                    {% for option in region_options %}-->
<!--                        <option value="{{ option }}" {% if option == selected_region %}selected{% endif %}>{{ option }}</option>-->
<!--                    {% endfor %}-->
<!--                </select>-->

<!--                <label for="model">Model:</label>-->
<!--                <select name="model" id="model">-->
<!--                    <option value="">Select Model</option>-->
<!--                    {% for option in model_options %}-->
<!--                        <option value="{{ option }}" {% if option == selected_model %}selected{% endif %}>{{ option }}</option>-->
<!--                    {% endfor %}-->
<!--                </select>-->


<!--                <label for="plot_type">Plot Type:</label>-->
<!--                <select name="plot_type" id="plot_type">-->
<!--                    <option value="line" {% if selected_plot_type == "line" %}selected{% endif %}>Line</option>-->
<!--                    <option value="line+marker" {% if selected_plot_type == "line+marker" %}selected{% endif %}>Line+Marker</option>-->
<!--                    <option value="bar" {% if selected_plot_type == "bar" %}selected{% endif %}>Bar</option>-->
<!--                </select>-->
<!--            </div>-->
<!--        </form>-->

<!--        {% if plot_div_single %}-->
<!--            {{ plot_div_single|safe }}-->
<!--        {% endif %}-->

<!--        {% if not filtered_data.empty %}-->
<!--            <h2>Data</h2>-->
<!--            <table>-->
<!--                <thead>-->
<!--                    <tr>-->
<!--                        {% for column in filtered_data.columns %}-->
<!--                            <th>{{ column }}</th>-->
<!--                        {% endfor %}-->
<!--                    </tr>-->
<!--                </thead>-->
<!--                <tbody>-->
<!--                    {% for _, row in filtered_data.iterrows %}-->
<!--                        <tr>-->
<!--                            {% for value in row %}-->
<!--                                <td>{{ value }}</td>-->
<!--                            {% endfor %}-->
<!--                        </tr>-->
<!--                    {% endfor %}-->
<!--                </tbody>-->
<!--            </table>-->
<!--        {% else %}-->
<!--            <p>No data available for the selected options.</p>-->
<!--        {% endif %}-->
<!--    </div>-->

<!--    <script>-->
<!--        var regionOptions = {{ region_options|safe }};-->
<!--        var modelOptions = {{ model_options|safe }};-->

<!--        function updateRegionOptions(selectedVariable) {-->
<!--            var regionSelect = document.getElementById('region');-->
<!--            regionSelect.innerHTML = '<option value="">Select Region</option>';-->

<!--            if (selectedVariable) {-->
<!--                var filteredRegions = regionOptions.filter(function(region) {-->
<!--                    return region.startsWith(selectedVariable);-->
<!--                });-->

<!--                filteredRegions.forEach(function(region) {-->
<!--                    var option = document.createElement('option');-->
<!--                    option.value = region;-->
<!--                    option.text = region;-->
<!--                    regionSelect.add(option);-->
<!--                });-->
<!--            }-->
<!--        }-->

<!--        function updateModelOptions(selectedRegion) {-->
<!--            var modelSelect = document.getElementById('model');-->
<!--            modelSelect.innerHTML = '<option value="">Select Model</option>';-->

<!--            if (selectedRegion) {-->
<!--                var filteredModels = modelOptions.filter(function(model) {-->
<!--                    return model.startsWith(selectedRegion);-->
<!--                });-->

<!--                filteredModels.forEach(function(model) {-->
<!--                    var option = document.createElement('option');-->
<!--                    option.value = model;-->
<!--                    option.text = model;-->
<!--                    modelSelect.add(option);-->
<!--                });-->
<!--            }-->
<!--        }-->

<!--        // Add event listener to the form-->
<!--        document.getElementById('dashboard-form').addEventListener('change', function() {-->
<!--            // Submit the form when any dropdown value changes-->
<!--            this.submit();-->
<!--        });-->


<!--    </script>-->
<!--</body>-->
</html>












from django.shortcuts import render, redirect
import openpyxl
import json
from django.http import HttpResponse
from django.shortcuts import render
import pandas as pd
import plotly.graph_objs as go
from plotly.offline import plot

def chart(request):
    if request.method == "GET":
        return render(request, 'chart.html', {})
    else:
        excel_file = request.FILES["excel_file"]
        wb = openpyxl.load_workbook(excel_file)
        worksheet = wb.active
        excel_data = []
        for row in worksheet.iter_rows():
            row_data = []
            for cell in row:
                row_data.append(cell.value)
            excel_data.append(row_data)

        df = pd.DataFrame(excel_data[1:], columns=excel_data[0])
        variable_options = sorted(df['Variable'].unique().tolist())
        country_options = list(set([(country, variable) for country, variable in zip(df['Region'], df['Variable'])]))
        model_options = list(set([(model, variable, country) for model, variable, country in zip(df['Model'], df['Variable'], df['Region'])]))

        request.session['data'] = json.loads(df.to_json(orient='records'))
        request.session['variable_options'] = variable_options
        request.session['country_options'] = country_options
        request.session['model_options'] = model_options

        return redirect('dashboard')




import pandas as pd
import plotly.graph_objs as go
from plotly.offline import plot

def dashboard(request):
    # Load data from Excel file
    df = pd.read_excel("charts/static/data/bs_check.xlsx")

    # Get selected options from request
    selected_variable = request.GET.get('variable', None)
    selected_region = request.GET.get('region', None)
    selected_model = request.GET.get("model", None)
    selected_plot_type = request.GET.get("plot_type", "line")

    # Filter the DataFrame based on selected filters
    if selected_variable and selected_region and selected_model:
        filtered_data = df[(df['Variable'] == selected_variable) &
                           (df['Region'] == selected_region) &
                           (df['Model'] == selected_model)]
        if not filtered_data.empty:
            # Create traces for each scenario
            years = [2020, 2025, 2030, 2035, 2040, 2045, 2050]
            traces = []
            for scenario, scenario_data in filtered_data.groupby('Scenario'):
                if selected_plot_type == "line":
                    trace = go.Scatter(
                        x=years,
                        y=scenario_data[years].values.flatten(),
                        mode='lines',
                        line=dict(width=5, shape='spline'),
                        name=scenario
                    )
                elif selected_plot_type == "line+marker":
                    trace = go.Scatter(
                        x=years,
                        y=scenario_data[years].values.flatten(),
                        mode='lines+markers',
                        line=dict(width=5, shape='spline'),
                        name=scenario
                    )
                elif selected_plot_type == "bar":
                    trace = go.Bar(
                        x=years,
                        y=scenario_data[years].values.flatten(),

                        name=scenario
                    )
                traces.append(trace)

            # Create the plot
            layout = go.Layout(
                title=selected_variable,
                xaxis=dict(title='Year', showgrid=False, tickfont=dict(color="black")),
                yaxis=dict(title='Value', showgrid=False, tickfont=dict(color="black")),
                height=750,
                plot_bgcolor='rgba(0,0,0,0)',
                paper_bgcolor='rgba(8,8,8,8)'
            )
            fig = go.Figure(data=traces, layout=layout)
            plot_div_single = plot(fig, output_type='div', include_plotlyjs=False)
        else:
            # If filtered data is empty, set plot_div_single to None
            plot_div_single = None
    else:
        # If any of the options is not selected, set filtered_data and plot_div_single to None
        filtered_data, plot_div_single = None, None

    # Get unique values for each column
    variable_options = df['Variable'].unique().tolist()
    region_options = df['Region'].unique().tolist()
    model_options = df['Model'].unique().tolist()

    # Filter region options based on selected variable
    if selected_variable:
        region_options = df[df['Variable'] == selected_variable]['Region'].unique().tolist()

    # Filter model options based on selected variable and region
    if selected_variable and selected_region:
        model_options = df[(df['Variable'] == selected_variable) & (df['Region'] == selected_region)]['Model'].unique().tolist()

    # Prepare context to pass to the template
    context = {
        'variable_options': variable_options,
        'region_options': region_options,
        'model_options': model_options,
        'selected_variable': selected_variable,
        'selected_region': selected_region,
        'selected_model': selected_model,
        'selected_plot_type': selected_plot_type,
        'filtered_data': filtered_data,
        'plot_div_single': plot_div_single,
    }

    return render(request, 'dashboard.html', context)

# def dashboard(request):
#     # Load data from Excel file
#     df = pd.read_excel("charts/static/data/bs_check.xlsx")
#
#     # Get selected options from request
#     selected_variable = request.GET.get('variable', None)
#     selected_region = request.GET.get('region', None)
#     selected_model = request.GET.get("model", None)
#     selected_plot_type = request.GET.get("plot_type", None)
#
#     # Filter the DataFrame based on selected filters
#     if selected_variable and selected_region and selected_model:
#         filtered_data = df[(df['Variable'] == selected_variable) &
#                            (df['Region'] == selected_region) &
#                            (df['Model'] == selected_model)]
#         if not filtered_data.empty:
#             # Create traces for each scenario
#             years = [2020, 2025, 2030, 2035, 2040, 2045, 2050]
#             traces = []
#             for scenario, scenario_data in filtered_data.groupby('Scenario'):
#                 if selected_plot_type == "line":
#                     trace = go.Scatter(
#                         x=years,
#                         y=scenario_data[years].values.flatten(),
#                         mode='lines',
#                         line=dict(width=3),
#                         name=scenario
#                     )
#                 elif selected_plot_type == "line+marker":
#                     trace = go.Scatter(
#                         x=years,
#                         y=scenario_data[years].values.flatten(),
#                         mode='lines+markers',
#                         line=dict(width=3),
#                         name=scenario
#                     )
#                 elif selected_plot_type == "bar":
#                     trace = go.Bar(
#                         x=years,
#                         y=scenario_data[years].values.flatten(),
#                         name=scenario
#                     )
#                 traces.append(trace)
#
#             # Create the plot
#             layout = go.Layout(
#                 title=selected_variable,
#                 xaxis=dict(title='Year', showgrid=True, tickfont=dict(color="black")),
#                 yaxis=dict(title='Value', showgrid=True, tickfont=dict(color="black")),
#                 height=750,
#                 plot_bgcolor='rgba(0,0,0,0)',
#                 paper_bgcolor='rgba(8,8,8,8)'
#             )
#             fig = go.Figure(data=traces, layout=layout)
#             plot_div_single = plot(fig, output_type='div', include_plotlyjs=False)
#         else:
#             # If filtered data is empty, set plot_div_single to None
#             plot_div_single = None
#     else:
#         # If any of the options is not selected, set filtered_data and plot_div_single to None
#         filtered_data, plot_div_single = None, None
#
#     # Get unique values for each column
#     variable_options = df['Variable'].unique().tolist()
#     region_options = df['Region'].unique().tolist()
#     model_options = df['Model'].unique().tolist()
#
#     # Filter region options based on selected variable
#     if selected_variable:
#         region_options = df[df['Variable'] == selected_variable]['Region'].unique().tolist()
#
#     # Filter model options based on selected variable and region
#     if selected_variable and selected_region:
#         model_options = df[(df['Variable'] == selected_variable) & (df['Region'] == selected_region)]['Model'].unique().tolist()
#
#     # Prepare context to pass to the template
#     context = {
#         'variable_options': variable_options,
#         'region_options': region_options,
#         'model_options': model_options,
#         'selected_variable': selected_variable,
#         'selected_region': selected_region,
#         'selected_model': selected_model,
#         'selected_plot_type': selected_plot_type,
#         'filtered_data': filtered_data,
#         'plot_div_single': plot_div_single,
#     }
#
#     return render(request, 'dashboard.html', context)

# def dashboard(request):
#     # Load data from Excel file
#     df = pd.read_excel("charts/static/data/bs_check.xlsx")
#
#     # Get selected options from request
#     selected_variable = request.GET.get('variable', None)
#     selected_region = request.GET.get('region', None)
#     selected_model = request.GET.get("model", None)
#     selected_plot_type = request.GET.get("plot_type", None)
#
#
#     # Filter the DataFrame based on selected filters
#     if selected_variable and selected_region and selected_model:
#         filtered_data = df[(df['Variable'] == selected_variable) &
#                            (df['Region'] == selected_region) &
#                            (df['Model'] == selected_model)]
#         if not filtered_data.empty:
#             # Create traces for each scenario
#             years = [2020, 2025, 2030, 2035, 2040, 2045, 2050]
#             traces = []
#             for scenario, scenario_data in filtered_data.groupby('Scenario'):
#                 trace = go.Scatter(
#                     x=years,
#                     y=scenario_data[years].values.flatten(),
#                     mode='lines+markers',
#                     line=dict(width=5, shape='spline'),
#                     name=scenario
#                 )
#                 traces.append(trace)
#             # Create the multiline plot
#             layout = go.Layout(
#                 title=selected_variable,
#                 xaxis=dict(title='Year', showgrid=False, tickfont=dict(color="black")),
#                 yaxis=dict(title='Value', showgrid=False, tickfont=dict(color="black")),
#                 height=750,
#                 plot_bgcolor='rgba(0,0,0,0)',
#                 paper_bgcolor='rgba(8,8,8,8)'
#             )
#             fig = go.Figure(data=traces, layout=layout)
#             plot_div_single = plot(fig, output_type='div', include_plotlyjs=False)
#         else:
#             # If filtered data is empty, set plot_div_single to None
#             plot_div_single = None
#     else:
#         # If any of the options is not selected, set filtered_data and plot_div_single to None
#         filtered_data, plot_div_single = None, None
#
#     # Get unique values for each column
#     variable_options = df['Variable'].unique().tolist()
#     region_options = df['Region'].unique().tolist()
#     model_options = df['Model'].unique().tolist()
#
#     # Filter region options based on selected variable
#     if selected_variable:
#         region_options = df[df['Variable'] == selected_variable]['Region'].unique().tolist()
#
#     # Filter model options based on selected variable and region
#     if selected_variable and selected_region:
#         model_options = df[(df['Variable'] == selected_variable) & (df['Region'] == selected_region)]['Model'].unique().tolist()
#
#     # Prepare context to pass to the template
#     context = {
#         'variable_options': variable_options,
#         'region_options': region_options,
#         'model_options': model_options,
#         'selected_variable': selected_variable,
#         'selected_region': selected_region,
#         'selected_model': selected_model,
#         'filtered_data': filtered_data,
#         'selected_plot_type': selected_plot_type,
#         'plot_div_single': plot_div_single,
#     }
#
#     return render(request, 'dashboard.html', context)

# def dashboard(request):
#     # Load data from Excel file
#     df = pd.read_excel("charts/static/data/bs_check.xlsx")
#     print(df)
#     # Get selected options from request
#     selected_variable = request.GET.get('variable', None)
#     selected_country = request.GET.get('country', None)
#     selected_model = request.GET.get("model", None)
#
#     # Filter the DataFrame based on selected filters
#     if selected_variable and selected_country and selected_model:
#         filtered_data = df[(df['Variable'] == selected_variable) &
#                            (df['Region'] == selected_country) &
#                            (df['Model'] == selected_model)]
#         if not filtered_data.empty:
#             # Create traces for each scenario
#             years = [2020, 2025, 2030, 2035, 2040, 2045, 2050]
#             traces = []
#             for scenario, scenario_data in filtered_data.groupby('Scenario'):
#                 trace = go.Scatter(
#                     x=years,
#                     y=scenario_data[years].values.flatten(),
#                     mode='lines+markers',
#                     line=dict(width=5, shape='spline'),
#                     name=scenario
#                 )
#                 traces.append(trace)
#             # Create the multiline plot
#             layout = go.Layout(
#                 title=selected_variable,
#                 xaxis=dict(title='Year', showgrid=False, tickfont=dict(color="black")),
#                 yaxis=dict(title='Value', showgrid=False, tickfont=dict(color="black")),
#                 height=750,
#                 plot_bgcolor='rgba(0,0,0,0)',
#                 paper_bgcolor='rgba(8,8,8,8)'
#             )
#             fig = go.Figure(data=traces, layout=layout)
#             plot_div_single = plot(fig, output_type='div', include_plotlyjs=False)
#         else:
#             # If filtered data is empty, set plot_div_single to None
#             plot_div_single = None
#     else:
#         # If any of the options is not selected, set filtered_data and plot_div_single to None
#         filtered_data, plot_div_single = None, None
#
#     # Get unique values for each column
#     variable_options = df['Variable'].unique().tolist()
#     country_options = df['Region'].unique().tolist()
#     model_options = df['Model'].unique().tolist()
#
#     # Filter country options based on selected variable
#     if selected_variable:
#         country_options = df[df['Variable'] == selected_variable]['Region'].unique().tolist()
#
#     # Filter model options based on selected variable and country
#     if selected_variable and selected_country:
#         model_options = df[(df['Variable'] == selected_variable) & (df['Region'] == selected_country)]['Model'].unique().tolist()
#
#     # Prepare context to pass to the template
#     context = {
#         'variable_options': variable_options,
#         'country_options': country_options,
#         'model_options': model_options,
#         'selected_variable': selected_variable,
#         'selected_country': selected_country,
#         'selected_model': selected_model,
#         'filtered_data': filtered_data,
#         'plot_div_single': plot_div_single,
#     }
#
#     return render(request, 'dashboard.html', context)












.dropdown-container select option[value*="BL"] {
    color: yellow;
}

.dropdown-container select option[value*="NZ"] {
    color: skyblue;
}

.dropdown-container select option[value*="DT"] {
    color: black;
}

.dropdown-container select option[value*="DP"] {
    color: red;



















from django.shortcuts import render
from django.core.paginator import Paginator
import pandas as pd
import plotly.graph_objs as go
from plotly.offline import plot

def dashboard(request):
    # Get selected options from request
    selected_variable = request.GET.get('variable', None)
    selected_region = request.GET.get('region', None)
    selected_model = request.GET.get("model", None)
    selected_plot_type = request.GET.get("plot_type", "line")

    # Load data from Excel file (consider loading only necessary columns if dataset is too large)
    df = pd.read_excel("charts/static/data/bs_check.xlsx")

    # Filter the DataFrame based on selected filters
    filtered_data = df.copy()  # Copy the dataframe to avoid modifying the original one
    if selected_variable:
        filtered_data = filtered_data[filtered_data['Variable'] == selected_variable]
    if selected_region:
        filtered_data = filtered_data[filtered_data['Region'] == selected_region]
    if selected_model:
        filtered_data = filtered_data[filtered_data['Model'] == selected_model]

    # Pagination
    paginator = Paginator(filtered_data.values.tolist(), 10)  # Change 10 to your desired page size
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)

    # Create the plot if data is available
    if len(filtered_data) > 0:
        # Extract relevant columns for plotting
        years = [2020, 2025, 2030, 2035, 2040, 2045, 2050]
        traces = []
        for scenario, scenario_data in filtered_data.groupby('Scenario'):
            if selected_plot_type == "line":
                trace = go.Scatter(
                    x=years,
                    y=scenario_data[years].values.flatten(),
                    mode='lines',
                    line=dict(width=5, shape='spline'),
                    name=scenario
                )
            elif selected_plot_type == "line+marker":
                trace = go.Scatter(
                    x=years,
                    y=scenario_data[years].values.flatten(),
                    mode='lines+markers',
                    line=dict(width=5, shape='spline'),
                    name=scenario
                )
            elif selected_plot_type == "bar":
                trace = go.Bar(
                    x=years,
                    y=scenario_data[years].values.flatten(),
                    name=scenario
                )
            traces.append(trace)

        # Create the plot
        layout = go.Layout(
            title=selected_variable,
            xaxis=dict(title='Year', showgrid=False, tickfont=dict(color="black")),
            yaxis=dict(title='Value', showgrid=False, tickfont=dict(color="black")),
            height=750,
            plot_bgcolor='rgba(0,0,0,0)',
            paper_bgcolor='rgba(8,8,8,8)'
        )
        fig = go.Figure(data=traces, layout=layout)
        plot_div_single = plot(fig, output_type='div', include_plotlyjs=False)
    else:
        plot_div_single = None

    # Get unique values for each column
    variable_options = df['Variable'].unique().tolist()
    region_options = df['Region'].unique().tolist()
    model_options = df['Model'].unique().tolist()

    # Prepare context to pass to the template
    context = {
        'variable_options': variable_options,
        'region_options': region_options,
        'model_options': model_options,
        'selected_variable': selected_variable,
        'selected_region': selected_region,
        'selected_model': selected_model,
        'selected_plot_type': selected_plot_type,
        'page_obj': page_obj,
        'plot_div_single': plot_div_single,
    }

    return render(request, 'dashboard.html', context)


















from django.shortcuts import render
from django.core.paginator import Paginator
import pandas as pd
import plotly.graph_objs as go
from plotly.offline import plot

def dashboard(request):
    # Get selected options from request
    selected_variable = request.GET.get('variable', None)
    selected_region = request.GET.get('region', None)
    selected_model = request.GET.get("model", None)
    selected_plot_type = request.GET.get("plot_type", "line")

    # Load data from Excel file (consider loading only necessary columns if dataset is too large)
    df = pd.read_excel("charts/static/data/bs_check.xlsx")

    # Filter the DataFrame based on selected filters
    filtered_data = df.copy()  # Copy the dataframe to avoid modifying the original one
    if selected_variable:
        filtered_data = filtered_data[filtered_data['Variable'] == selected_variable]
    if selected_region:
        filtered_data = filtered_data[filtered_data['Region'] == selected_region]
    if selected_model:
        filtered_data = filtered_data[filtered_data['Model'] == selected_model]

    # Pagination
    paginator = Paginator(filtered_data.values.tolist(), 10)  # Change 10 to your desired page size
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)

    # Create the plot if data is available
    if len(filtered_data) > 0:
        # Extract relevant columns for plotting
        years = [2020, 2025, 2030, 2035, 2040, 2045, 2050]
        traces = []
        for scenario, scenario_data in filtered_data.groupby('Scenario'):
            if selected_plot_type == "line":
                trace = go.Scatter(
                    x=years,
                    y=scenario_data[years].values.flatten(),
                    mode='lines',
                    line=dict(width=5, shape='spline'),
                    name=scenario
                )
            elif selected_plot_type == "line+marker":
                trace = go.Scatter(
                    x=years,
                    y=scenario_data[years].values.flatten(),
                    mode='lines+markers',
                    line=dict(width=5, shape='spline'),
                    name=scenario
                )
            elif selected_plot_type == "bar":
                trace = go.Bar(
                    x=years,
                    y=scenario_data[years].values.flatten(),
                    name=scenario
                )
            traces.append(trace)

        # Create the plot
        layout = go.Layout(
            title=selected_variable,
            xaxis=dict(title='Year', showgrid=False, tickfont=dict(color="black")),
            yaxis=dict(title='Value', showgrid=False, tickfont=dict(color="black")),
            height=750,
            plot_bgcolor='rgba(0,0,0,0)',
            paper_bgcolor='rgba(8,8,8,8)'
        )
        fig = go.Figure(data=traces, layout=layout)
        plot_div_single = plot(fig, output_type='div', include_plotlyjs=False)
    else:
        plot_div_single = None

    # Get unique values for each column
    variable_options = df['Variable'].unique().tolist()
    region_options = df['Region'].unique().tolist()
    model_options = df['Model'].unique().tolist()

    # Prepare context to pass to the template
    context = {
        'variable_options': variable_options,
        'region_options': region_options,
        'model_options': model_options,
        'selected_variable': selected_variable,
        'selected_region': selected_region,
        'selected_model': selected_model,
        'selected_plot_type': selected_plot_type,
        'page_obj': page_obj,
        'plot_div_single': plot_div_single,
    }

    return render(request, 'dashboard.html', context)












# Install necessary packages
!pip install plotly pandas

# Load data from Excel file (for demonstration, you can upload your file to Colab)
import pandas as pd

# Load your dataset
df = pd.read_excel("path_to_your_file/bs_check.xlsx")

# Create dropdowns using Plotly's Dash components
import plotly.graph_objs as go
import dash
import dash_core_components as dcc
import dash_html_components as html
from dash.dependencies import Input, Output

app = dash.Dash(__name__)

app.layout = html.Div([
    html.H1('Dashboard for Scenario'),
    html.Div([
        html.Label('Variable:'),
        dcc.Dropdown(
            id='variable-dropdown',
            options=[{'label': var, 'value': var} for var in df['Variable'].unique()],
            value=None,
            multi=False
        ),
        html.Label('Region:'),
        dcc.Dropdown(
            id='region-dropdown',
            options=[{'label': reg, 'value': reg} for reg in df['Region'].unique()],
            value=None,
            multi=False
        ),
        html.Label('Model:'),
        dcc.Dropdown(
            id='model-dropdown',
            options=[{'label': mod, 'value': mod} for mod in df['Model'].unique()],
            value=None,
            multi=False
        ),
        html.Label('Plot Type:'),
        dcc.Dropdown(
            id='plot-type-dropdown',
            options=[
                {'label': 'Line', 'value': 'line'},
                {'label': 'Line+Marker', 'value': 'line+marker'},
                {'label': 'Bar', 'value': 'bar'}
            ],
            value='line',
            multi=False
        ),
    ]),
    html.Div(id='plot-container')
])

@app.callback(
    Output('plot-container', 'children'),
    [Input('variable-dropdown', 'value'),
     Input('region-dropdown', 'value'),
     Input('model-dropdown', 'value'),
     Input('plot-type-dropdown', 'value')]
)
def update_plot(selected_variable, selected_region, selected_model, selected_plot_type):
    # Filter the DataFrame based on selected filters
    filtered_data = df.copy()  # Copy the dataframe to avoid modifying the original one
    if selected_variable:
        filtered_data = filtered_data[filtered_data['Variable'] == selected_variable]
    if selected_region:
        filtered_data = filtered_data[filtered_data['Region'] == selected_region]
    if selected_model:
        filtered_data = filtered_data[filtered_data['Model'] == selected_model]

    # Create traces for each scenario
    years = [2020, 2025, 2030, 2035, 2040, 2045, 2050]
    traces = []
    for scenario, scenario_data in filtered_data.groupby('Scenario'):
        if selected_plot_type == "line":
            trace = go.Scatter(
                x=years,
                y=scenario_data[years].values.flatten(),
                mode='lines',
                line=dict(width=5, shape='spline'),
                name=scenario
            )
        elif selected_plot_type == "line+marker":
            trace = go.Scatter(
                x=years,
                y=scenario_data[years].values.flatten(),
                mode='lines+markers',
                line=dict(width=5, shape='spline'),
                name=scenario
            )
        elif selected_plot_type == "bar":
            trace = go.Bar(
                x=years,
                y=scenario_data[years].values.flatten(),
                name=scenario
            )
        traces.append(trace)

    # Create the plot
    layout = go.Layout(
        title=selected_variable,
        xaxis=dict(title='Year', showgrid=False, tickfont=dict(color="black")),
        yaxis=dict(title='Value', showgrid=False, tickfont=dict(color="black")),
        height=750,
        plot_bgcolor='rgba(0,0,0,0)',
        paper_bgcolor='rgba(8,8,8,8)'
    )
    fig = go.Figure(data=traces, layout=layout)
    return dcc.Graph(
        id='plot',
        figure=fig
    )

if __name__ == '__main__':
    app.run_server(debug=True, use_reloader=False)








# Import necessary modules
from django.shortcuts import render
import pandas as pd
import plotly.graph_objs as go
from dash import Dash
from dash.dependencies import Input, Output
import dash_core_components as dcc
import dash_html_components as html

# Create a function to generate the Dash dashboard layout
def generate_dash_layout(df):
    # Define the Dash app
    app = Dash(__name__)

    # Define the layout of the dashboard
    app.layout = html.Div([
        html.H1('Dashboard for Scenario'),
        html.Div([
            html.Label('Variable:'),
            dcc.Dropdown(
                id='variable-dropdown',
                options=[{'label': var, 'value': var} for var in df['Variable'].unique()],
                value=None,
                multi=False
            ),
            html.Label('Region:'),
            dcc.Dropdown(
                id='region-dropdown',
                options=[{'label': reg, 'value': reg} for reg in df['Region'].unique()],
                value=None,
                multi=False
            ),
            html.Label('Model:'),
            dcc.Dropdown(
                id='model-dropdown',
                options=[{'label': mod, 'value': mod} for mod in df['Model'].unique()],
                value=None,
                multi=False
            ),
            html.Label('Plot Type:'),
            dcc.Dropdown(
                id='plot-type-dropdown',
                options=[
                    {'label': 'Line', 'value': 'line'},
                    {'label': 'Line+Marker', 'value': 'line+marker'},
                    {'label': 'Bar', 'value': 'bar'}
                ],
                value='line',
                multi=False
            ),
        ]),
        html.Div(id='plot-container')
    ])

    # Define the callback function to update the plot
    @app.callback(
        Output('plot-container', 'children'),
        [Input('variable-dropdown', 'value'),
         Input('region-dropdown', 'value'),
         Input('model-dropdown', 'value'),
         Input('plot-type-dropdown', 'value')]
    )
    def update_plot(selected_variable, selected_region, selected_model, selected_plot_type):
        # Filter the DataFrame based on selected filters
        filtered_data = df.copy()  # Copy the dataframe to avoid modifying the original one
        if selected_variable:
            filtered_data = filtered_data[filtered_data['Variable'] == selected_variable]
        if selected_region:
            filtered_data = filtered_data[filtered_data['Region'] == selected_region]
        if selected_model:
            filtered_data = filtered_data[filtered_data['Model'] == selected_model]

        # Create traces for each scenario
        years = [2020, 2025, 2030, 2035, 2040, 2045, 2050]
        traces = []
        for scenario, scenario_data in filtered_data.groupby('Scenario'):
            if selected_plot_type == "line":
                trace = go.Scatter(
                    x=years,
                    y=scenario_data[years].values.flatten(),
                    mode='lines',
                    line=dict(width=5, shape='spline'),
                    name=scenario
                )
            elif selected_plot_type == "line+marker":
                trace = go.Scatter(
                    x=years,
                    y=scenario_data[years].values.flatten(),
                    mode='lines+markers',
                    line=dict(width=5, shape='spline'),
                    name=scenario
                )
            elif selected_plot_type == "bar":
                trace = go.Bar(
                    x=years,
                    y=scenario_data[years].values.flatten(),
                    name=scenario
                )
            traces.append(trace)

        # Create the plot
        layout = go.Layout(
            title=selected_variable,
            xaxis=dict(title='Year', showgrid=False, tickfont=dict(color="black")),
            yaxis=dict(title='Value', showgrid=False, tickfont=dict(color="black")),
            height=750,
            plot_bgcolor='rgba(0,0,0,0)',
            paper_bgcolor='rgba(8,8,8,8)'
        )
        fig = go.Figure(data=traces, layout=layout)
        return dcc.Graph(
            id='plot',
            figure=fig
        )

    # Return the app's layout
    return app.layout

# Your existing Django view
def dashboard(request):
    # Load data from Excel file
    df = pd.read_excel("charts/static/data/bs_check.xlsx")

    # Generate the Dash dashboard layout
    dash_layout = generate_dash_layout(df)

    # Pass the Dash layout to the template
    context = {'dash_layout': dash_layout}
    return render(request, 'dashboard.html', context)














??????????AutomateGSIB???


import pandas as pd
from openpyxl import load_workbook, Workbook
from datetime import datetime
from openpyxl.styles import Font, PatternFill, Side, Border

def add_output_columns(sheet):
    df = pd.read_excel(sheet)
    df["GDP YR"] = df.groupby(["ISOCODES"])["GDP"].pct_change(4) * 100
    df["CPI YR"] = df.groupby(["ISOCODES"])["CPI"].pct_change(4) * 100
    df["PH YR"] = df.groupby(["ISOCODES"])["PH"].pct_change(4) * 100
    df["PH DUBAI YR"] = df.groupby(["ISOCODES"])["PH_DUBAI"].pct_change(4) * 100
    df["PCOM YR"] = df.groupby(["ISOCODES"])["PCOM"].pct_change(4) * 100
    df["GDP QoQ"] = df.groupby(["ISOCODES"])["GDP"].pct_change(1) * 100
    df["CPI QoQ"] = df.groupby(["ISOCODES"])["CPI"].pct_change(1) * 100
    df["PH_QoQ"] = df.groupby(["ISOCODES"])["PH"].pct_change(1) * 100
    df["PH_DUBAI_QOQ"] = df.groupby(["ISOCODES"])["PH_DUBAI"].pct_change(1) * 100
    df["PCOM QOQ"] = df.groupby(["ISOCODES"])["PCOM"].pct_change(1) * 100
    return df

def calculate_weights(df_table, isocode):
    mapping_file_path = "C:\\Users\\45363901\\PycharmProjects\\pythonProject\\Automation_GBIC\\GBIC Workings Data\\Input Mapping File Copy.xlsx"
    country_sheet = pd.read_excel(mapping_file_path, sheet_name="Country")
    scenario_weights_sheet = pd.read_excel(mapping_file_path, sheet_name="Scenario Weights")
    merged_sheet = scenario_weights_sheet.merge(country_sheet, on="ISOCODE")
    u1_weight = merged_sheet[(merged_sheet["ISOCODE"] == isocode) & (merged_sheet["SCENARIO NAME"] == "U1")]["WEIGHT"].values[0]
    cn_weight = merged_sheet[(merged_sheet["ISOCODE"] == isocode) & (merged_sheet["SCENARIO NAME"] == "CN")]["WEIGHT"].values[0]
    d1_weight = merged_sheet[(merged_sheet["ISOCODE"] == isocode) & (merged_sheet["SCENARIO NAME"] == "D1")]["WEIGHT"].values[0]
    d2_weight = merged_sheet[(merged_sheet["ISOCODE"] == isocode) & (merged_sheet["SCENARIO NAME"] == "D2")]["WEIGHT"].values[0]
    for i in range(0, 18):
        df_table.values[i][8] = (
            df_table.values[i][4] * u1_weight + df_table.values[i][5] * cn_weight +
            df_table.values[i][6] * d1_weight + df_table.values[i][7] * d2_weight
        )[0]

def construct_and_populate_tables(isocode, tzero_date, col):
    current_year = 2024

    columns = [
        "Upside",
        "Central",
        "Down 1",
        "Down 2",
        "Upside",
        "Central",
        "Down 1",
        "Down 2",
        "Weighted",
        "10% UP",
        "Central",
        "10% DN",
        "4% DN",
    ]
    rows = [
        ["Q1", "Q2", "Q3", "Q4", current_year, current_year + 1, current_year + 2, current_year + 3, "", "", "", "", ""],
        [str(current_year) + "-03-31", str(current_year) + "-06-30", str(current_year) + "-09-30", str(current_year) + "-12-31", str(current_year + 1), str(current_year + 1) + "-03-31", str(current_year + 1) + "-06-30", str(current_year + 1) + "-09-30", "", "", "", "", ""],
    ]
    df_table = pd.DataFrame(columns=columns, index=rows)
    df_table.loc[-1] = ['IFRS 1024' for _ in range(len(columns))]
    df_table.loc[-2] = ['IFRS9 4023 Scenarios' for _ in range(len(columns))]
    df_table.index += 2
    df_table = df_table.sort_index()

    year3_sum = 0
    year4_sum = 0
    col_index = 0

    for frame in All:
        for row in frame.itertuples():
            # Your existing code to populate the DataFrame goes here

    calculate_weights(df_table, isocode)
    return df_table

def adjust_col_width_and_font_size(sheet):
    for column in sheet.columns:
        column_letter = column[0].column_letter
        if column_letter in ['A', 'B', 'C']:
            continue
        sheet.column_dimensions[column_letter].width = 6
        for cell in column:
            cell.font = cell.font if cell.font else Font()
            cell.font = Font(size=9)

input_file = r"C:\Users\45363901\PycharmProjects\pythonProject\Automation_GBIC\GBIC_Workings Data\GBIC_Workings\2401_GBIC_Tables_29022024.xlsx"
workbook = load_workbook(input_file)

for sheet_name in workbook.sheetnames:
    sheet = workbook[sheet_name]
    # Remove gridlines
    sheet.sheet_view.showGridLines = False
    # Apply grey color to all data cells except column names
    for row in sheet.iter_rows(min_row=2):
        for cell in row:
            if cell.row > 5:
                cell.fill = PatternFill(start_color="FFAFAFAF", end_color="FFAFAFAF", fill_type="solid")
    # Add darker grey to specific rows
    for row in sheet.iter_rows(min_row=2, max_row=5):
        for cell in row:
            cell.fill = PatternFill(start_color="FF808080", end_color="FF808080", fill_type="solid")
    # Rename Q1, Q2, etc. columns to country codes
    for cell in sheet["D"][1:]:
        cell.value = cell.value.replace("Q", "")
    # Add rows for IFRS scenarios
    sheet.insert_rows(1)
    sheet.insert_rows(1)
    sheet["D1"].value = "IFRS 1024"
    sheet["D2"].value = "IFRS9 4023 Scenarios"
    sheet["A1"].value = "Moody's"
    sheet["B1"].value = "Moody's"
    sheet["C1"].value = "Moody's"
    sheet["A2"].value = "Moody's"
    sheet["B2"].value = "Moody's"
    sheet["C2"].value = "Moody's"
    sheet["A1"].font = Font(color="FFFF0000")
    sheet["B1"].font = Font(color="FFFF0000")
    sheet["C1"].font = Font(color="FFFF0000")
    sheet["A2"].font = Font(color="FFFF0000")
    sheet["B2"].font = Font(color="FFFF0000")
    sheet["C2"].font = Font(color="FFFF0000")
    sheet["D1"].font = Font(color="FFFF0000")
    sheet["D2"].font = Font(color="FFFF0000")
    sheet["D1"].fill = PatternFill(start_color="FF87CEEB", end_color="FF87CEEB", fill_type="solid")
    sheet["D2"].fill = PatternFill(start_color="FF87CEEB", end_color="FF87CEEB", fill_type="solid")
    # Apply thin white border to separate cells
    thin_border = Border(left=Side(style='thin'), right=Side(style='thin'), top=Side(style='thin'), bottom=Side(style='thin'))
    for row in sheet.iter_rows():
        for cell in row:
            cell.border = thin_border

    adjust_col_width_and_font_size(sheet)

workbook.save(input_file)


























import pandas as pd
from openpyxl import load_workbook, Workbook
from datetime import datetime
from openpyxl.styles import Font, PatternFill, Border, Side


def add_output_columns(sheet):
    df = pd.read_excel(sheet)

    df["GDP YR"] = df.groupby(["ISOCODES"])["GDP"].pct_change(4) * 100
    df["CPI YR"] = df.groupby(["ISOCODES"])["CPI"].pct_change(4) * 100
    df["PH YR"] = df.groupby(["ISOCODES"])["PH"].pct_change(4) * 100
    df["PH DUBAI YR"] = df.groupby(["ISOCODES"])["PH_DUBAI"].pct_change(4) * 100
    df["PCOM YR"] = df.groupby(["ISOCODES"])["PCOM"].pct_change(4) * 100
    df["GDP QoQ"] = df.groupby(["ISOCODES"])["GDP"].pct_change(1) * 100
    df["CPI QoQ"] = df.groupby(["ISOCODES"])["CPI"].pct_change(1) * 100
    df["PH_QoQ"] = df.groupby(["ISOCODES"])["PH"].pct_change(1) * 100
    df["PH_DUBAI_QOQ"] = df.groupby(["ISOCODES"])["PH_DUBAI"].pct_change(1) * 100
    df["PCOM QOQ"] = df.groupby(["ISOCODES"])["PCOM"].pct_change(1) * 100

    return df


def calculate_syear_avg(frame, isocode, tzero_date, col):
    index = frame[(frame["ISOCODES"] == isocode) & (frame["date"] == datetime.strptime(tzero_date, "%Y-%m-%d %H:%M:%S"))]
    if not index.empty:
        avg = frame[col].iloc[(index.index[0] + 1): (index.index[0] + 21)].mean()
        return avg
    else:
        return None


def calculate_weights(df_table, isocode):
    mapping_file_path = "C:\\Users\\45363901\\PycharmProjects\\pythonProject\\Automation_GBIC\\GBIC Workings Data\\Input Mapping File Copy.xlsx"

    country_sheet = pd.read_excel(mapping_file_path, sheet_name="Country")
    scenario_weights_sheet = pd.read_excel(mapping_file_path, sheet_name="Scenario Weights")

    merged_sheet = scenario_weights_sheet.merge(country_sheet, on="ISOCODE")

    u1_weight = merged_sheet[(merged_sheet["ISOCODE"] == isocode) & (merged_sheet["SCENARIO NAME"] == "U1")]["WEIGHT"].values[0]
    cn_weight = merged_sheet[(merged_sheet["ISOCODE"] == isocode) & (merged_sheet["SCENARIO NAME"] == "CN")]["WEIGHT"].values[0]
    d1_weight = merged_sheet[(merged_sheet["ISOCODE"] == isocode) & (merged_sheet["SCENARIO NAME"] == "D1")]["WEIGHT"].values[0]
    d2_weight = merged_sheet[(merged_sheet["ISOCODE"] == isocode) & (merged_sheet["SCENARIO NAME"] == "D2")]["WEIGHT"].values[0]

    for i in range(0, 18):
        df_table.values[i][8] = (
            df_table.values[i][4] * u1_weight
            + df_table.values[i][5] * cn_weight
            + df_table.values[i][6] * d1_weight
            + df_table.values[i][7] * d2_weight
        )[0]


def construct_and_populate_tables(isocode, tzero_date, col):
    current_year = 2024

    columns = [
        "Upside",
        "Central",
        "Down 1",
        "Down 2",
        "Upside",
        "Central",
        "Down 1",
        "Down 2",
        "Weighted",
        "10% UP",
        "Central",
        "10% DN",
        "4% DN",
    ]
    rows = [
        ["Q1", "Q2", "Q3", "Q4", current_year, current_year + 1, current_year + 2, current_year + 3, "", "", "", "", ""],
        [str(current_year) + "-03-31", str(current_year) + "-06-30", str(current_year) + "-09-30", str(current_year) + "-12-31", str(current_year + 1), str(current_year + 1) + "-03-31", str(current_year + 1) + "-06-30", str(current_year + 1) + "-09-30", "", "", "", "", ""],
    ]
    df_table = pd.DataFrame(columns=columns, index=rows)

    year3_sum = 0
    year4_sum = 0
    col_index = 0

    for frame in All:
        for row in frame.itertuples():
            # For previous year
            if (
                row.ISOCODES == isocode
                and row.date == datetime.strptime(str(current_year - 1) + "-03-31 00:00:00", "%Y-%m-%d %H:%M:%S")
            ):
                df_table.values[0][col_index] = getattr(row, col)
            elif (
                row.ISOCODES == isocode
                and row.date == datetime.strptime(str(current_year - 1) + "-06-30 00:00:00", "%Y-%m-%d %H:%M:%S")
            ):
                df_table.values[1][col_index] = getattr(row, col)
            elif (
                row.ISOCODES == isocode
                and row.date == datetime.strptime(str(current_year - 1) + "-09-30 00:00:00", "%Y-%m-%d %H:%M:%S")
            ):
                df_table.values[2][col_index] = getattr(row, col)
            elif (
                row.ISOCODES == isocode
                and row.date == datetime.strptime(str(current_year - 1) + "-12-31 00:00:00", "%Y-%m-%d %H:%M:%S")
            ):
                df_table.values[3][col_index] = getattr(row, col)

            # For current year
            elif (
                row.ISOCODES == isocode
                and row.date == datetime.strptime(str(current_year) + "-03-31 00:00:00", "%Y-%m-%d %H:%M:%S")
            ):
                df_table.values[5][col_index] = getattr(row, col)
            elif (
                row.ISOCODES == isocode
                and row.date == datetime.strptime(str(current_year) + "-06-30 00:00:00", "%Y-%m-%d %H:%M:%S")
            ):
                df_table.values[6][col_index] = getattr(row, col)
            elif (
                row.ISOCODES == isocode
                and row.date == datetime.strptime(str(current_year) + "-09-30 00:00:00", "%Y-%m-%d %H:%M:%S")
            ):
                df_table.values[7][col_index] = getattr(row, col)
            elif (
                row.ISOCODES == isocode
                and row.date == datetime.strptime(str(current_year) + "-12-31 00:00:00", "%Y-%m-%d %H:%M:%S")
            ):
                df_table.values
            elif (
                row.ISOCODES == isocode
                and row.date == datetime.strptime(str(current_year + 1) + "-03-31 00:00:00", "%Y-%m-%d %H:%M:%S")
            ):
                df_table.values[10][col_index] = getattr(row, col)
            elif (
                row.ISOCODES == isocode
                and row.date == datetime.strptime(str(current_year + 1) + "-06-30 00:00:00", "%Y-%m-%d %H:%M:%S")
            ):
                df_table.values[11][col_index] = getattr(row, col)
            elif (
                row.ISOCODES == isocode
                and row.date == datetime.strptime(str(current_year + 1) + "-09-30 00:00:00", "%Y-%m-%d %H:%M:%S")
            ):
                df_table.values[12][col_index] = getattr(row, col)
            elif (
                row.ISOCODES == isocode
                and row.date == datetime.strptime(str(current_year + 1) + "-12-31 00:00:00", "%Y-%m-%d %H:%M:%S")
            ):
                df_table.values[13][col_index] = getattr(row, col)

            # For next year 2
            elif (
                row.ISOCODES == isocode
                and row.date == datetime.strptime(str(current_year + 2) + "-03-31 00:00:00", "%Y-%m-%d %H:%M:%S")
            ):
                year3_sum += getattr(row, col)
            elif (
                row.ISOCODES == isocode
                and row.date == datetime.strptime(str(current_year + 2) + "-06-30 00:00:00", "%Y-%m-%d %H:%M:%S")
            ):
                year3_sum += getattr(row, col)
            elif (
                row.ISOCODES == isocode
                and row.date == datetime.strptime(str(current_year + 2) + "-09-30 00:00:00", "%Y-%m-%d %H:%M:%S")
            ):
                year3_sum += getattr(row, col)
            elif (
                row.ISOCODES == isocode
                and row.date == datetime.strptime(str(current_year + 2) + "-12-31 00:00:00", "%Y-%m-%d %H:%M:%S")
            ):
                year3_sum += getattr(row, col)

            # For next year + 3
            elif (
                row.ISOCODES == isocode
                and row.date == datetime.strptime(str(current_year + 3) + "-03-31 00:00:00", "%Y-%m-%d %H:%M:%S")
            ):
                year4_sum += getattr(row, col)
            elif (
                row.ISOCODES == isocode
                and row.date == datetime.strptime(str(current_year + 3) + "-06-30 00:00:00", "%Y-%m-%d %H:%M:%S")
            ):
                year4_sum += getattr(row, col)
            elif (
                row.ISOCODES == isocode
                and row.date == datetime.strptime(str(current_year + 3) + "-09-30 00:00:00", "%Y-%m-%d %H:%M:%S")
            ):
                year4_sum += getattr(row, col)

        df_table.values[4][col_index] = (df_table.values[0][col_index] + df_table.values[1][col_index] +
                                         df_table.values[2][col_index] + df_table.values[3][col_index]) / 4
        df_table.values[9][col_index] = (df_table.values[5][col_index] + df_table.values[6][col_index] +
                                         df_table.values[7][col_index] + df_table.values[8][col_index]) / 4
        df_table.values[14][col_index] = (df_table.values[10][col_index] + df_table.values[11][col_index] +
                                          df_table.values[12][col_index] + df_table.values[13][col_index]) / 4
        calculate_5year_avg(frame, isocode, tzero_date, col)
        df_table.values[17][col_index] = df_table.values[15][col_index]
        df_table.values[16][col_index] = df_table.values[16][col_index]
        df_table.values[16][col_index] = year3_sum / 4
        df_table.values[16][col_index] = year4_sum / 4
        year3_sum = 0
        year4_sum = 0
        col_index += 1
        if col_index == 8:
            col_index = 1
    calculate_weights(df_table, isocode)
    return df_table


def adjust_col_width_and_font_size(sheet):
    for column in sheet.columns:
        column_letter = column[0].column_letter
        if column_letter in ['A', 'B', 'C']:
            continue
        sheet.column_dimensions[column_letter].width = 6
        for cell in column:
            cell.font = cell.font if cell.font else Font()
            cell.font = Font(size=9)


def format_excel(input_file):
    workbook = load_workbook(input_file)

    for sheet_name in workbook.sheetnames:
        sheet = workbook[sheet_name]
        sheet.sheet_view.showGridLines = False

        # Apply grey color to all data cells except column names
        for row in sheet.iter_rows(min_row=2):
            for cell in row:
                if cell.row > 5:
                    cell.fill = PatternFill(start_color="FFAFAFAF", end_color="FFAFAFAF", fill_type="solid")

        # Add darker grey to specific rows
        for row in sheet.iter_rows(min_row=2, max_row=5):
            for cell in row:
                cell.fill = PatternFill(start_color="FF808080", end_color="FF808080", fill_type="solid")

        # Rename Q1, Q2, etc. columns to country codes
        for cell in sheet["D"][1:]:
            cell.value = cell.value.replace("Q", "")

        # Add rows for IFRS scenarios
        sheet.insert_rows(1)
        sheet.insert_rows(1)
        sheet["D1"].value = "IFRS 1024"
        sheet["D2"].value = "IFRS9 4023 Scenarios"
        sheet["A1"].value = "Moody's"
        sheet["B1"].value = "Moody's"
        sheet["C1"].value = "Moody's"
        sheet["A2"].value = "Moody's"
        sheet["B2"].value = "Moody's"
        sheet["C2"].value = "Moody's"
        sheet["A1"].font = Font(color="FFFF0000")
        sheet["B1"].font = Font(color="FFFF0000")
        sheet["C1"].font = Font(color="FFFF0000")
        sheet["A2"].font = Font(color="FFFF0000")
        sheet["B2"].font = Font(color="FFFF0000")
        sheet["C2"].font = Font(color="FFFF0000")
        sheet["D1"].font = Font(color="FFFF0000")
        sheet["D2"].font = Font(color="FFFF0000")
        sheet["D1"].fill = PatternFill(start_color="FF87CEEB", end_color="FF87CEEB", fill_type="solid")
        sheet["D2"].fill = PatternFill(start_color="FF87CEEB", end_color="FF87CEEB", fill_type="solid")

        # Apply thin white border to separate cells
        thin_border = Border(left=Side(style='thin'), right=Side(style='thin'), top=Side(style='thin'), bottom=Side(style='thin'))
        for row in sheet.iter_rows():
            for cell in row:
                cell.border = thin_border

        adjust_col_width_and_font_size(sheet)

    workbook.save(input_file)


def main():
    input_file = r"C:\Users\45363901\PycharmProjects\pythonProject\Automation_GBIC\GBIC_Workings Data\GBIC_Workings\2401_GBIC_Tables_29022024.xlsx"
    format_excel(input_file)


if __name__ == "__main__":
    main()



















workbook = load_workbook(input_file)

for sheet_name in workbook.sheetnames:
    sheet = workbook[sheet_name]
    # Remove gridlines
    sheet.sheet_view.showGridLines = False
    # Apply grey color to all data cells except column names
    for row in sheet.iter_rows(min_row=2):
        for cell in row:
            if cell.row > 5:
                cell.fill = PatternFill(start_color="FFAFAFAF", end_color="FFAFAFAF", fill_type="solid")
    # Add darker grey to specific rows
    for row in sheet.iter_rows(min_row=2, max_row=5):
        for cell in row:
            cell.fill = PatternFill(start_color="FF808080", end_color="FF808080", fill_type="solid")
    # Rename Q1, Q2, etc. columns to country codes
    for cell in sheet["D"][1:]:
        cell.value = cell.value.replace("Q", "")
    # Freeze top 5 rows and left 4 columns
    sheet.freeze_panes = "E6"

output_file = input_file.replace(".xlsx", "_formatted.xlsx")
workbook.save(output_file)

