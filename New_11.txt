<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Upload Excel File</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-image: url('/static/chart_3.jfif'); /* Specify your background image URL */
            background-size: cover;
            background-position: center;
            color: white;
        }
        .container {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        .box {
            width: 500px;
            height: 280px;
            margin: 30px;
            padding: 30px;
            border-radius: 10px;
            background-color: rgba(0, 0, 0, 0.5); /* Semi-transparent black background */
            text-align: center;
        }
        .box h2 {
            font-weight: bold;
        }
        .box p {
            font-weight: bold;
            margin-top: 10px;
        }
        .button {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #007bff; /* Blue color, adjust as needed */
            color: white;
            border: 2px solid white; /* White border */
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .button:hover {
            background-color: #0056b3; /* Darker shade of blue on hover */
        }.logo {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 100px; /* Adjust width as needed */
            height: auto;
        }.file-input {
            display: inline-block;
            padding: 15px 30px;
            background-color: #007bff; /* Blue background color */
            color: white;
            border: 2px solid white; /* White border */
            border-radius: 5px;
            font-size: 18px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .file-input:hover {
            background-color: #0056b3; /* Darker shade of blue on hover */
        }.upload-form {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 50px;
        }.upload-button {
            margin-top: 20px;
            padding: 15px 30px;
            background-color: #007bff; /* Blue background color */
            color: white;
            border: 2px solid white; /* White border */
            border-radius: 5px;
            font-size: 18px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .upload-button:hover {
            background-color: #28a745; /* Green background color on hover */
        }
    </style>
</head>
<body>
    <img src="/static/logo_1.jfif" alt="Logo" class="logo">
    <h1>Upload Excel File</h1>
    <div class="container">
        <div class="box">
            <h1>Upload Excel File</h1>
    <form method="post" enctype="multipart/form-data" class="upload-form">
        {% csrf_token %}
        <input type="file" name="excel_file" accept=".xlsx, .xls" class="file-input">
        <button type="submit" class="upload-button">Upload</button>
    </form>
        </div>
    </div>
    <form method="post" enctype="multipart/form-data" action="dashboard" id="uploadForm" style="display: none;"></form>
</body>
</html>







































<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Dashboard</title>
    <!-- Plotly.js -->
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        /* Add your CSS styles here */
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-image: url('/static/chart_3.jfif'); /* Specify the URL of your background image */
            background-size: cover;
            background-position: center;
            color: black; /* Set text color to black */
        }

        /* Table styles */
        .table {
            border-collapse: collapse;
            overflow-x: auto; /* Enable horizontal scrolling */
        }

        th, td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #ddd;
            font-weight: bold; /* Make column names bold */
        }

        th {
            background-color: red; /* Set column headers background color */
            color: white; /* Set column headers text color */
        }

        tr:nth-child(even) {
            background-color: #f2f2f2; /* Light green background for even rows */
        }

        tr:hover {
            background-color: #ddd; /* Darker green background on hover */
        }


        h1 {
            text-align: center;
            margin-top: 30px;
        }
        .dashboard-container {
            border: 1px solid #ccc; /* Light gray border */
            border-radius: 5px; /* Rounded corners */
            padding: 20px;
            margin: 20px auto;
            max-width: 1450px; /* Limit width for better readability */
            background: url('/static/chart_2.jfif') no-repeat center center fixed, #ccc; /* Background image and gray color */
            background-size: cover;
            background-color: #ccc; /* White background */
            overflow-x: auto; /* Ensure content doesn't overflow (consider removing if needed) */
        }
        .dropdown-container label {
            font-size: 20px; /* Increase font size */
            font-weight: bold; /* Make font bold */
            color: black; /* Set text color to black */
        }

        .dropdown-container select {
            font-size: 18px; /* Increase font size */
        }

        .dropdown-container select:hover {
            border-color: #0056b3; /* Darker shade of blue on hover */
        }

        .dropdown-container select:focus {
            outline: none; /* Remove default focus outline */
            border-color: #0056b3; /* Darker shade of blue when focused */
        }

        input[type="submit"] {
            padding: 3.5px 18px; /* Adjust padding */
            font-size: 18px; /* Increase font size */
            font-weight: bold; /* Make font bold */
            color: black; /* Set text color to black */
            background-color: #007bff; /* Blue background color */
            border: 2px solid white; /* Blue border */
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        input[type="submit"]:hover {
            background-color: #0056b3; /* Darker shade of blue on hover */
        }

        .logo-container {
            text-align: right;
            margin-bottom: 20px;
        }
        .logo {
            width: 100px;
            height: auto;
            border: 1px solid #ccc; /* Light gray border */
            border-radius: 5px;
        }
        .table {
            border-collapse: collapse;
            margin-bottom: 20px;
            background-color: #fff;
            overflow-x: auto; /* Horizontal scrollbar */
        }


    </style>
</head>
<body>
    <div class="logo-container">
        <img src="/static/logo_1.jfif" alt="Logo" class="logo">
    </div>
    <h1>Dashboard</h1>
    <div class="dashboard-container">
        <form action="{% url 'dashboard' %}" method="get">
            <div class="dropdown-container">
                <label for="variable">Variable:</label>
                <select name="variable" id="variable">
                    {% for option in variable_options %}
                        <option value="{{ option }}" {% if option == selected_variable %}selected{% endif %}>{{ option }}</option>
                    {% endfor %}
                </select>
                <label for="country">Country:</label>
                <select name="country" id="country">
                    {% for option in country_options %}
                        <option value="{{ option }}" {% if option == selected_country %}selected{% endif %}>{{ option }}</option>
                    {% endfor %}
                </select>
                <label for="model">Model:</label>
                <select name="model" id="model">
                    {% for option in model_options %}
                        <option value="{{ option }}" {% if option == selected_model %}selected{% endif %}>{{ option }}</option>
                    {% endfor %}
                </select>
                <input type="submit" value="Submit">
            </div>
        </form>

        {% if plot_div_single %}
            {{ plot_div_single|safe }}
        {% endif %}

        {% if filtered_data %}
            <h2>Data</h2>
            <table>
                <thead>
                    <tr>
                        {% for column in filtered_data.0.keys %}
                            <th>{{ column }}</th>
                        {% endfor %}
                    </tr>
                </thead>
                <tbody>
                    {% for row in filtered_data %}
                        <tr>
                            {% for value in row.values %}
                                <td>{{ value }}</td>
                            {% endfor %}
                        </tr>
                    {% endfor %}
                </tbody>
            </table>
        {% else %}
            <p>No data available for the selected options.</p>
        {% endif %}
    </div>
</body>
</html>


































def dashboard(request):
    data = request.session.get("data", [])
    variable_options = request.session.get('variable_options', [])
    country_options = request.session.get('country_options', [])
    model_options = request.session.get('model_options', [])

    selected_variable = request.GET.get('variable', variable_options[0] if variable_options else None)
    selected_country = request.GET.get('country', country_options[0] if country_options else None)
    selected_model = request.GET.get('model', model_options[0] if model_options else None)

    # Convert data to DataFrame
    df = pd.DataFrame(data)

    # Filter country options based on selected variable
    filtered_country_options = sorted(df[df['Variable'] == selected_variable]['Region'].unique().tolist())

    # Update session variable for country options
    request.session['country_options'] = filtered_country_options

    # Filter model options based on selected variable and country
    filtered_model_options = sorted(df[(df['Variable'] == selected_variable) &
                                       (df['Region'] == selected_country)]['Model'].unique().tolist())

    # Update session variable for model options
    request.session['model_options'] = filtered_model_options

    # Filter the DataFrame based on selected filters
    filtered_data = df[(df['Variable'] == selected_variable) &
                      (df['Region'] == selected_country) &
                      (df['Model'] == selected_model)]

    if not filtered_data.empty:
        # Filter the DataFrame to keep only rows with unique scenarios
        unique_scenarios = filtered_data['Scenario'].unique()
        filtered_data_unique = filtered_data.drop_duplicates(subset=['Scenario'])

        # Convert the filtered DataFrame to a dictionary of records
        filtered_data_dict = filtered_data_unique.to_dict('records')
    else:
        filtered_data_dict = []

    if not filtered_data.empty:
        years = [2020, 2025, 2030, 2035, 2040, 2045, 2050]
        traces = []

        for scenario, scenario_data in filtered_data.groupby('Scenario'):
            trace = go.Scatter(
                x=years,
                y=scenario_data[years].values.flatten(),
                mode='lines+markers',
                name=scenario
            )
            traces.append(trace)

        # Create the multiline plot
        layout = go.Layout(
            title=selected_variable,
            xaxis=dict(title="Year", showgrid=False, tickfont=dict(color='black')),
            yaxis=dict(title="Value", showgrid=False, tickfont=dict(color="black")),
            height=750,
            plot_bgcolor='rgba(0,0,0,0)',
            paper_bgcolor='rgba(0,0,0,0)'
        )

        fig_single = go.Figure(data=traces, layout=layout)
        plot_div_single = plot(fig_single, output_type='div', include_plotlyjs=False)
    else:
        plot_div_single = None

    context = {
        'variable_options': variable_options,
        'country_options': filtered_country_options,
        'model_options': filtered_model_options,  # Use filtered model options
        'selected_variable': selected_variable,
        'selected_country': selected_country,
        'selected_model': selected_model,
        'filtered_data': filtered_data_dict,
        'plot_div_single': plot_div_single,
    }

    return render(request, 'dashboard.html', context)


















import pandas as pd
import plotly.graph_objs as go
from plotly.offline import plot

def dashboard(request):

    # Load data from Excel file
    df = pd.read_excel("static/data/data_dashboard.xlsx")

    selected_variable = request.GET.get('variable', None)
    selected_country = request.GET.get('country', None)
    selected_model = request.GET.get("model", None)

    if selected_variable and selected_country and selected_model:
        # Filter the DataFrame based on selected filters
        filtered_data = df[(df['Variable'] == selected_variable) &
                           (df['Region'] == selected_country) &
                           (df['Model'] == selected_model)]

        if not filtered_data.empty:
            # Check if filtered data is not empty
            years = [2020, 2025, 2030, 2035, 2040, 2045, 2050]
            traces = []

            for scenario, scenario_data in filtered_data.groupby('Scenario'):
                trace = go.Scatter(
                    x=years,
                    y=scenario_data[years].values.flatten(),
                    mode='lines+markers',
                    line=dict(width=5, shape='spline'),
                    name=scenario
                )
                traces.append(trace)

            # Create the multiline plot
            layout = go.Layout(
                title=selected_variable,
                xaxis=dict(title='Year', showgrid=False, tickfont=dict(color="black")),
                yaxis=dict(title='Value', showgrid=False, tickfont=dict(color="black")),
                height=750,
                plot_bgcolor='rgba(0,0,0,0)',
                paper_bgcolor='rgba(8,8,8,8)'
            )

            fig = go.Figure(data=traces, layout=layout)
            plot_div_single = plot(fig, output_type='div', include_plotlyjs=False)

        else:
            plot_div_single = None

    else:
        filtered_data = None
        plot_div_single = None

    context = {
        'variable_options': df['Variable'].unique().tolist(),
        'country_options': df['Country'].unique().tolist(),
        'model_options': df['Model'].unique().tolist(),
        'selected_variable': selected_variable,
        'selected_country': selected_country,
        'selected_model': selected_model,
        'filtered_data': filtered_data,
        'plot_div_single': plot_div_single,
    }

    return render(request, 'dashboard.html', context)


























import pandas as pd
import plotly.graph_objs as go
from plotly.offline import plot
from django.http import JsonResponse

def dashboard(request):
    # Load data from Excel file
    df = pd.read_excel("static/data/data_dashboard.xlsx")

    # Get selected options from request
    selected_variable = request.GET.get('variable', None)
    selected_country = request.GET.get('country', None)
    selected_model = request.GET.get("model", None)

    if selected_variable:
        # Filter country options based on selected variable
        country_options = df[df['Variable'] == selected_variable]['Region'].unique().tolist()
    else:
        country_options = []

    if selected_variable and selected_country:
        # Filter model options based on selected variable and country
        model_options = df[(df['Variable'] == selected_variable) & (df['Region'] == selected_country)]['Model'].unique().tolist()
    else:
        model_options = []

    if selected_variable and selected_country and selected_model:
        # Filter the DataFrame based on selected filters
        filtered_data = df[(df['Variable'] == selected_variable) &
                           (df['Region'] == selected_country) &
                           (df['Model'] == selected_model)]

        if not filtered_data.empty:
            # Create traces for each scenario
            years = [2020, 2025, 2030, 2035, 2040, 2045, 2050]
            traces = []

            for scenario, scenario_data in filtered_data.groupby('Scenario'):
                trace = go.Scatter(
                    x=years,
                    y=scenario_data[years].values.flatten(),
                    mode='lines+markers',
                    line=dict(width=5, shape='spline'),
                    name=scenario
                )
                traces.append(trace)

            # Create the multiline plot
            layout = go.Layout(
                title=selected_variable,
                xaxis=dict(title='Year', showgrid=False, tickfont=dict(color="black")),
                yaxis=dict(title='Value', showgrid=False, tickfont=dict(color="black")),
                height=750,
                plot_bgcolor='rgba(0,0,0,0)',
                paper_bgcolor='rgba(8,8,8,8)'
            )

            fig = go.Figure(data=traces, layout=layout)
            plot_div_single = plot(fig, output_type='div', include_plotlyjs=False)

        else:
            # If filtered data is empty, set plot_div_single to None
            plot_div_single = None

    else:
        # If any of the options is not selected, set filtered_data and plot_div_single to None
        filtered_data, plot_div_single = None, None

    # Prepare context to pass to the template
    context = {
        'variable_options': df['Variable'].unique().tolist(),
        'country_options': country_options,
        'model_options': model_options,
        'selected_variable': selected_variable,
        'selected_country': selected_country,
        'selected_model': selected_model,
        'filtered_data': filtered_data,
        'plot_div_single': plot_div_single,
    }

    return render(request, 'dashboard.html', context)

def get_country_options(request):
    # Load data from Excel file
    df = pd.read_excel("static/data/data_dashboard.xlsx")

    # Get selected variable from request
    selected_variable = request.GET.get('variable')

    # Filter country options based on selected variable
    country_options = df[df['Variable'] == selected_variable]['Region'].unique().tolist()

    # Return JSON response with country options
    return JsonResponse(country_options, safe=False)

def get_model_options(request):
    # Load data from Excel file
    df = pd.read_excel("static/data/data_dashboard.xlsx")

    # Get selected variable and country from request
    selected_variable = request.GET.get('variable')
    selected_country = request.GET.get('country')

    # Filter model options based on selected variable and country
    model_options = df[(df['Variable'] == selected_variable) & (df['Region'] == selected_country)]['Model'].unique().tolist()

    # Return JSON response with model options
    return JsonResponse(model_options, safe=False)




















import pandas as pd
import plotly.graph_objs as go
from plotly.offline import plot

def dashboard(request):
  # Load data from Excel file
  df = pd.read_excel("static/data/data_dashboard.xlsx")

  # Get selected options from request
  selected_variable = request.GET.get('variable', None)
  selected_country = request.GET.get('country', None)
  selected_model = request.GET.get("model", None)

  # Prepare initial context with all options
  context = {
      'variable_options': df['Variable'].unique().tolist(),
      'country_options': [],  # Initially empty for cascading
      'model_options': [],    # Initially empty for cascading
      'selected_variable': selected_variable,
      'selected_country': selected_country,
      'selected_model': selected_model,
      'filtered_data': None,
      'plot_div_single': None,
  }

  # Filter variable options based on selection (if any)
  if selected_variable:
      filtered_df = df[df['Variable'] == selected_variable]
      context['variable_options'] = [selected_variable]  # Keep only selected

      # Filter country options based on selected variable (if data allows)
      country_options = filtered_df['Region'].unique().tolist()
      if country_options:
          context['country_options'] = country_options

      # Filter model options based on selected variable and country (if data allows)
      if selected_country:
          filtered_df = filtered_df[filtered_df['Region'] == selected_country]
          model_options = filtered_df['Model'].unique().tolist()
          if model_options:
              context['model_options'] = model_options

  # Data filtering and plot generation (similar logic as before)
  if selected_variable and selected_country and selected_model:
      # ... (Your existing data filtering and plot generation logic here)

  # Return context to the template
  return render(request, 'dashboard.html', context)


















import pandas as pd
import plotly.graph_objs as go
from plotly.offline import plot

def dashboard(request):
    # Load data from Excel file
    df = pd.read_excel("static/data/data_dashboard.xlsx")

    # Get selected options from request
    selected_variable = request.GET.get('variable', None)
    selected_country = request.GET.get('country', None)
    selected_model = request.GET.get("model", None)

    # Filter the DataFrame based on selected filters
    if selected_variable and selected_country and selected_model:
        filtered_data = df[(df['Variable'] == selected_variable) &
                           (df['Region'] == selected_country) &
                           (df['Model'] == selected_model)]
        if not filtered_data.empty:
            # Create traces for each scenario
            years = [2020, 2025, 2030, 2035, 2040, 2045, 2050]
            traces = []
            for scenario, scenario_data in filtered_data.groupby('Scenario'):
                trace = go.Scatter(
                    x=years,
                    y=scenario_data[years].values.flatten(),
                    mode='lines+markers',
                    line=dict(width=5, shape='spline'),
                    name=scenario
                )
                traces.append(trace)
            # Create the multiline plot
            layout = go.Layout(
                title=selected_variable,
                xaxis=dict(title='Year', showgrid=False, tickfont=dict(color="black")),
                yaxis=dict(title='Value', showgrid=False, tickfont=dict(color="black")),
                height=750,
                plot_bgcolor='rgba(0,0,0,0)',
                paper_bgcolor='rgba(8,8,8,8)'
            )
            fig = go.Figure(data=traces, layout=layout)
            plot_div_single = plot(fig, output_type='div', include_plotlyjs=False)
        else:
            # If filtered data is empty, set plot_div_single to None
            plot_div_single = None
    else:
        # If any of the options is not selected, set filtered_data and plot_div_single to None
        filtered_data, plot_div_single = None, None

    # Get unique values for each column
    variable_options = df['Variable'].unique().tolist()
    country_options = df['Region'].unique().tolist()
    model_options = df['Model'].unique().tolist()

    # Filter country options based on selected variable
    if selected_variable:
        country_options = df[df['Variable'] == selected_variable]['Region'].unique().tolist()

    # Filter model options based on selected variable and country
    if selected_variable and selected_country:
        model_options = df[(df['Variable'] == selected_variable) & (df['Region'] == selected_country)]['Model'].unique().tolist()

    # Prepare context to pass to the template
    context = {
        'variable_options': variable_options,
        'country_options': country_options,
        'model_options': model_options,
        'selected_variable': selected_variable,
        'selected_country': selected_country,
        'selected_model': selected_model,
        'filtered_data': filtered_data,
        'plot_div_single': plot_div_single,
    }

    return render(request, 'dashboard.html', context)





































<body>
    <div class="logo-container">
    </div>
    <h1>Dashboard for Scenario</h1>
    <div class="dashboard-container">
        <form action="{% url 'dashboard' %}" method="get">
            <div class="dropdown-container">
                <label for="variable">Variable:</label>
                <select name="variable" id="variable" onchange="updateCountryOptions(this.value)">
                    <option value="">Select Variable</option>
                    {% for option in variable_options %}
                        <option value="{{ option }}" {% if option == selected_variable %}selected{% endif %}>{{ option }}</option>
                    {% endfor %}
                </select>

                <label for="country">Country:</label>
                <select name="country" id="country" onchange="updateModelOptions(this.value)">
                    <option value="">Select Country</option>
                    {% for option in country_options %}
                        <option value="{{ option }}" {% if option == selected_country %}selected{% endif %}>{{ option }}</option>
                    {% endfor %}
                </select>

                <label for="model">Model:</label>
                <select name="model" id="model">
                    <option value="">Select Model</option>
                    {% for option in model_options %}
                        <option value="{{ option }}" {% if option == selected_model %}selected{% endif %}>{{ option }}</option>
                    {% endfor %}
                </select>

                <input type="submit" value="Submit">
            </div>
        </form>

        {% if plot_div_single %}
            {{ plot_div_single|safe }}
        {% endif %}

        {% if filtered_data %}
            <h2>Data</h2>
            <table>
                <thead>
                    <tr>
                        {% for column in filtered_data.columns %}
                            <th>{{ column }}</th>
                        {% endfor %}
                    </tr>
                </thead>
                <tbody>
                    {% for _, row in filtered_data.iterrows %}
                        <tr>
                            {% for value in row %}
                                <td>{{ value }}</td>
                            {% endfor %}
                        </tr>
                    {% endfor %}
                </tbody>
            </table>
        {% else %}
            <p>No data available for the selected options.</p>
        {% endif %}
    </div>

    <script>
        var countryOptions = {{ country_options|safe }};
        var modelOptions = {{ model_options|safe }};

        function updateCountryOptions(selectedVariable) {
            var countrySelect = document.getElementById('country');
            countrySelect.innerHTML = '<option value="">Select Country</option>';

            if (selectedVariable) {
                var filteredCountries = countryOptions.filter(function(country) {
                    return country.startsWith(selectedVariable);
                });

                filteredCountries.forEach(function(country) {
                    var option = document.createElement('option');
                    option.value = country;
                    option.text = country;
                    countrySelect.add(option);
                });
            }
        }

        function updateModelOptions(selectedCountry) {
            var modelSelect = document.getElementById('model');
            modelSelect.innerHTML = '<option value="">Select Model</option>';

            if (selectedCountry) {
                var filteredModels = modelOptions.filter(function(model) {
                    return model.startsWith(selectedCountry);
                });

                filteredModels.forEach(function(model) {
                    var option = document.createElement('option');
                    option.value = model;
                    option.text = model;
                    modelSelect.add(option);
                });
            }
        }
    </script>
</body>





{% if filtered_data.empty %}
    <p>No data available for the selected options.</p>
{% else %}
    <h2>Data</h2>
    <table>
        <thead>
            <tr>
                {% for column in filtered_data.columns %}
                    <th>{{ column }}</th>
                {% endfor %}
            </tr>
        </thead>
        <tbody>
            {% for _, row in filtered_data.iterrows %}
                <tr>
                    {% for value in row %}
                        <td>{{ value }}</td>
                    {% endfor %}
                </tr>
            {% endfor %}
        </tbody>
    </table>
{% endif %}






















<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Dashboard</title>
    <!-- Plotly.js -->
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        /* Add your CSS styles here */
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #ffffff, #ffcccb);
            background-size: 400% 400%;
            animation: gradientAnimation 15s ease infinite;
            color: #333;
        }

        @keyframes gradientAnimation {
            0% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
            100% {
                background-position: 0% 50%;
            }
        }

        /* Table styles */
        .table {
            border-collapse: collapse;
            overflow-x: auto;
            background-color: #fff;
            color: #333;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }

        th, td {
            padding: 10px;
            text-align: left;
            border: 1px solid #ddd;
            font-weight: bold;
            border-radius: 5px;
        }

        th {
            background-color: #333;
            color: #fff;
        }

        tr:nth-child(even) {
            background-color: #f2f2f2;
        }

        tr:hover {
            background-color: #e6e6e6;
        }

        h1 {
            text-align: center;
            margin-top: 30px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .dashboard-container {
            border: 1px solid #ccc;
            border-radius: 10px;
            padding: 20px;
            margin: 20px auto;
            max-width: 1450px;
            background-color: #f5f5f5;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            overflow-x: auto;
        }

        .dropdown-container label {
            font-size: 20px;
            font-weight: bold;
            color: #333;
        }

        .dropdown-container select {
            font-size: 18px;
            padding: 10px 20px;
            border-radius: 20px;
            background-color: #ffcccb;
            color: #333;
            font-weight: bold;
            border: none;
            outline: none;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
        }

        .dropdown-container select:hover {
            background-color: #ff7f7f;
        }

        .dropdown-container select:focus {
            box-shadow: 0 0 5px rgba(255, 127, 127, 0.5);
        }

        input[type="submit"] {
            padding: 8px 16px;
            font-size: 18px;
            font-weight: bold;
            color: #fff;
            background-color: #8b0000;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        input[type="submit"]:hover {
            background-color: #ff4500;
        }

        .logo-container {
            text-align: right;
            margin-bottom: 20px;
        }

        .logo {
            width: 100px;
            height: auto;
            border-radius: 50%;
            animation: logoAnimation 5s infinite;
        }

        @keyframes logoAnimation {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 127, 127, 0.7);
            }
            70% {
                box-shadow: 0 0 0 20px rgba(255, 127, 127, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(255, 127, 127, 0);
            }
        }






<!--        /* Add your CSS styles here */-->
<!--        body {-->
<!--            margin: 0;-->
<!--            padding: 0;-->
<!--            font-family: Arial, sans-serif;-->
<!--            background-image: url('/static/chart_3.jfif'); /* Specify the URL of your background image */-->
<!--            background-size: cover;-->
<!--            background-position: center;-->
<!--            color: black; /* Set text color to black */-->
<!--        }-->

<!--        /* Table styles */-->
<!--        .table {-->
<!--            border-collapse: collapse;-->
<!--            overflow-x: auto; /* Enable horizontal scrolling */-->
<!--        }-->

<!--        th, td {-->
<!--            padding: 10px;-->
<!--            text-align: left;-->
<!--            border-bottom: 1px solid #ddd;-->
<!--            font-weight: bold; /* Make column names bold */-->
<!--        }-->

<!--        th {-->
<!--            background-color: red; /* Set column headers background color */-->
<!--            color: white; /* Set column headers text color */-->
<!--        }-->

<!--        tr:nth-child(even) {-->
<!--            background-color: #f2f2f2; /* Light green background for even rows */-->
<!--        }-->

<!--        tr:hover {-->
<!--            background-color: #ddd; /* Darker green background on hover */-->
<!--        }-->


<!--        h1 {-->
<!--            text-align: center;-->
<!--            margin-top: 30px;-->
<!--        }-->
<!--        .dashboard-container {-->
<!--            border: 1px solid #ccc; /* Light gray border */-->
<!--            border-radius: 5px; /* Rounded corners */-->
<!--            padding: 20px;-->
<!--            margin: 20px auto;-->
<!--            max-width: 1450px; /* Limit width for better readability */-->
<!--            background: url('/static/chart_2.jfif') no-repeat center center fixed, #ccc; /* Background image and gray color */-->
<!--            background-size: cover;-->
<!--            background-color: #ccc; /* White background */-->
<!--            overflow-x: auto; /* Ensure content doesn't overflow (consider removing if needed) */-->
<!--        }-->
<!--        .dropdown-container label {-->
<!--            font-size: 20px; /* Increase font size */-->
<!--            font-weight: bold; /* Make font bold */-->
<!--            color: black; /* Set text color to black */-->
<!--        }-->

<!--        .dropdown-container select {-->
<!--            font-size: 18px; /* Increase font size */-->
<!--        }-->

<!--        .dropdown-container select:hover {-->
<!--            border-color: #0056b3; /* Darker shade of blue on hover */-->
<!--        }-->

<!--        .dropdown-container select:focus {-->
<!--            outline: none; /* Remove default focus outline */-->
<!--            border-color: #0056b3; /* Darker shade of blue when focused */-->
<!--        }-->

<!--        input[type="submit"] {-->
<!--            padding: 3.5px 18px; /* Adjust padding */-->
<!--            font-size: 18px; /* Increase font size */-->
<!--            font-weight: bold; /* Make font bold */-->
<!--            color: black; /* Set text color to black */-->
<!--            background-color: #007bff; /* Blue background color */-->
<!--            border: 2px solid white; /* Blue border */-->
<!--            border-radius: 5px;-->
<!--            cursor: pointer;-->
<!--            transition: background-color 0.3s ease;-->
<!--        }-->

<!--        input[type="submit"]:hover {-->
<!--            background-color: #0056b3; /* Darker shade of blue on hover */-->
<!--        }-->

<!--        .logo-container {-->
<!--            text-align: right;-->
<!--            margin-bottom: 20px;-->
<!--        }-->
<!--        .logo {-->
<!--            width: 100px;-->
<!--            height: auto;-->
<!--            border: 1px solid #ccc; /* Light gray border */-->
<!--            border-radius: 5px;-->
<!--        }-->
<!--        .table {-->
<!--            border-collapse: collapse;-->
<!--            margin-bottom: 20px;-->
<!--            background-color: #fff;-->
<!--            overflow-x: auto; /* Horizontal scrollbar */-->
<!--        }-->

    </style>
</head>




<body>
    <div class="logo-container">
    </div>
    <h1>Dashboard for Scenario</h1>
    <div class="dashboard-container">
        <form id="dashboard-form">
            <div class="dropdown-container">
<!--                <label for="variable">Variable:</label>-->
                <select name="variable" id="variable" onchange="updateRegionOptions(this.value)">
                    <option value="">Select Variable</option>
                    {% for option in variable_options %}
                        <option value="{{ option }}" {% if option == selected_variable %}selected{% endif %}>{{ option }}</option>
                    {% endfor %}
                </select>

<!--                <label for="region">Region:</label>-->
                <select name="region" id="region" onchange="updateModelOptions(this.value)">
                    <option value="">Select Region</option>
                    {% for option in region_options %}
                        <option value="{{ option }}" {% if option == selected_region %}selected{% endif %}>{{ option }}</option>
                    {% endfor %}
                </select>

<!--                <label for="model">Model:</label>-->
                <select name="model" id="model">
                    <option value="">Select Model</option>
                    {% for option in model_options %}
                        <option value="{{ option }}" {% if option == selected_model %}selected{% endif %}>{{ option }}</option>
                    {% endfor %}
                </select>

<!--                <label for="plot_type">Plot Type:</label>-->
                <select name="plot_type" id="plot_type">
                    <option value="line" {% if selected_plot_type == "line" %}selected{% endif %}>Line</option>
                    <option value="line+marker" {% if selected_plot_type == "line+marker" %}selected{% endif %}>Line+Marker</option>
                    <option value="bar" {% if selected_plot_type == "bar" %}selected{% endif %}>Bar</option>
                </select>
            </div>
        </form>

        {% if plot_div_single %}
            {{ plot_div_single|safe }}
        {% endif %}

        {% if not filtered_data.empty %}
            <h2>Data</h2>
            <table>
                <thead>
                    <tr>
                        {% for column in filtered_data.columns %}
                            <th>{{ column }}</th>
                        {% endfor %}
                    </tr>
                </thead>
                <tbody>
                    {% for _, row in filtered_data.iterrows %}
                        <tr>
                            {% for value in row %}
                                <td>{{ value }}</td>
                            {% endfor %}
                        </tr>
                    {% endfor %}
                </tbody>
            </table>
        {% else %}
            <p>No data available for the selected options.</p>
        {% endif %}
    </div>

    <script>
        var regionOptions = {{ region_options|safe }};
        var modelOptions = {{ model_options|safe }};

        function updateRegionOptions(selectedVariable) {
            var regionSelect = document.getElementById('region');
            regionSelect.innerHTML = '<option value="">Select Region</option>';

            if (selectedVariable) {
                var filteredRegions = regionOptions.filter(function(region) {
                    return region.startsWith(selectedVariable);
                });

                filteredRegions.forEach(function(region) {
                    var option = document.createElement('option');
                    option.value = region;
                    option.text = region;
                    regionSelect.add(option);
                });
            }
        }

        function updateModelOptions(selectedRegion) {
            var modelSelect = document.getElementById('model');
            modelSelect.innerHTML = '<option value="">Select Model</option>';

            if (selectedRegion) {
                var filteredModels = modelOptions.filter(function(model) {
                    return model.startsWith(selectedRegion);
                });

                filteredModels.forEach(function(model) {
                    var option = document.createElement('option');
                    option.value = model;
                    option.text = model;
                    modelSelect.add(option);
                });
            }
        }

        // Add event listener to the form
        document.getElementById('dashboard-form').addEventListener('change', function() {
            // Submit the form when any dropdown value changes
            this.submit();
        });
    </script>
</body>




<!--<body>-->
<!--    <div class="logo-container">-->
<!--    </div>-->
<!--    <h1>Dashboard for Scenario</h1>-->
<!--    <div class="dashboard-container">-->
<!--        <form id="dashboard-form">-->
<!--            <div class="dropdown-container">-->
<!--                <label for="variable">Variable:</label>-->
<!--                <select name="variable" id="variable" onchange="updateRegionOptions(this.value)">-->
<!--                    <option value="">Select Variable</option>-->
<!--                    {% for option in variable_options %}-->
<!--                        <option value="{{ option }}" {% if option == selected_variable %}selected{% endif %}>{{ option }}</option>-->
<!--                    {% endfor %}-->
<!--                </select>-->

<!--                <label for="region">Region:</label>-->
<!--                <select name="region" id="region" onchange="updateModelOptions(this.value)">-->
<!--                    <option value="">Select Region</option>-->
<!--                    {% for option in region_options %}-->
<!--                        <option value="{{ option }}" {% if option == selected_region %}selected{% endif %}>{{ option }}</option>-->
<!--                    {% endfor %}-->
<!--                </select>-->

<!--                <label for="model">Model:</label>-->
<!--                <select name="model" id="model">-->
<!--                    <option value="">Select Model</option>-->
<!--                    {% for option in model_options %}-->
<!--                        <option value="{{ option }}" {% if option == selected_model %}selected{% endif %}>{{ option }}</option>-->
<!--                    {% endfor %}-->
<!--                </select>-->


<!--                <label for="plot_type">Plot Type:</label>-->
<!--                <select name="plot_type" id="plot_type">-->
<!--                    <option value="line" {% if selected_plot_type == "line" %}selected{% endif %}>Line</option>-->
<!--                    <option value="line+marker" {% if selected_plot_type == "line+marker" %}selected{% endif %}>Line+Marker</option>-->
<!--                    <option value="bar" {% if selected_plot_type == "bar" %}selected{% endif %}>Bar</option>-->
<!--                </select>-->
<!--            </div>-->
<!--        </form>-->

<!--        {% if plot_div_single %}-->
<!--            {{ plot_div_single|safe }}-->
<!--        {% endif %}-->

<!--        {% if not filtered_data.empty %}-->
<!--            <h2>Data</h2>-->
<!--            <table>-->
<!--                <thead>-->
<!--                    <tr>-->
<!--                        {% for column in filtered_data.columns %}-->
<!--                            <th>{{ column }}</th>-->
<!--                        {% endfor %}-->
<!--                    </tr>-->
<!--                </thead>-->
<!--                <tbody>-->
<!--                    {% for _, row in filtered_data.iterrows %}-->
<!--                        <tr>-->
<!--                            {% for value in row %}-->
<!--                                <td>{{ value }}</td>-->
<!--                            {% endfor %}-->
<!--                        </tr>-->
<!--                    {% endfor %}-->
<!--                </tbody>-->
<!--            </table>-->
<!--        {% else %}-->
<!--            <p>No data available for the selected options.</p>-->
<!--        {% endif %}-->
<!--    </div>-->

<!--    <script>-->
<!--        var regionOptions = {{ region_options|safe }};-->
<!--        var modelOptions = {{ model_options|safe }};-->

<!--        function updateRegionOptions(selectedVariable) {-->
<!--            var regionSelect = document.getElementById('region');-->
<!--            regionSelect.innerHTML = '<option value="">Select Region</option>';-->

<!--            if (selectedVariable) {-->
<!--                var filteredRegions = regionOptions.filter(function(region) {-->
<!--                    return region.startsWith(selectedVariable);-->
<!--                });-->

<!--                filteredRegions.forEach(function(region) {-->
<!--                    var option = document.createElement('option');-->
<!--                    option.value = region;-->
<!--                    option.text = region;-->
<!--                    regionSelect.add(option);-->
<!--                });-->
<!--            }-->
<!--        }-->

<!--        function updateModelOptions(selectedRegion) {-->
<!--            var modelSelect = document.getElementById('model');-->
<!--            modelSelect.innerHTML = '<option value="">Select Model</option>';-->

<!--            if (selectedRegion) {-->
<!--                var filteredModels = modelOptions.filter(function(model) {-->
<!--                    return model.startsWith(selectedRegion);-->
<!--                });-->

<!--                filteredModels.forEach(function(model) {-->
<!--                    var option = document.createElement('option');-->
<!--                    option.value = model;-->
<!--                    option.text = model;-->
<!--                    modelSelect.add(option);-->
<!--                });-->
<!--            }-->
<!--        }-->

<!--        // Add event listener to the form-->
<!--        document.getElementById('dashboard-form').addEventListener('change', function() {-->
<!--            // Submit the form when any dropdown value changes-->
<!--            this.submit();-->
<!--        });-->


<!--    </script>-->
<!--</body>-->
</html>












from django.shortcuts import render, redirect
import openpyxl
import json
from django.http import HttpResponse
from django.shortcuts import render
import pandas as pd
import plotly.graph_objs as go
from plotly.offline import plot

def chart(request):
    if request.method == "GET":
        return render(request, 'chart.html', {})
    else:
        excel_file = request.FILES["excel_file"]
        wb = openpyxl.load_workbook(excel_file)
        worksheet = wb.active
        excel_data = []
        for row in worksheet.iter_rows():
            row_data = []
            for cell in row:
                row_data.append(cell.value)
            excel_data.append(row_data)

        df = pd.DataFrame(excel_data[1:], columns=excel_data[0])
        variable_options = sorted(df['Variable'].unique().tolist())
        country_options = list(set([(country, variable) for country, variable in zip(df['Region'], df['Variable'])]))
        model_options = list(set([(model, variable, country) for model, variable, country in zip(df['Model'], df['Variable'], df['Region'])]))

        request.session['data'] = json.loads(df.to_json(orient='records'))
        request.session['variable_options'] = variable_options
        request.session['country_options'] = country_options
        request.session['model_options'] = model_options

        return redirect('dashboard')




import pandas as pd
import plotly.graph_objs as go
from plotly.offline import plot

def dashboard(request):
    # Load data from Excel file
    df = pd.read_excel("charts/static/data/bs_check.xlsx")

    # Get selected options from request
    selected_variable = request.GET.get('variable', None)
    selected_region = request.GET.get('region', None)
    selected_model = request.GET.get("model", None)
    selected_plot_type = request.GET.get("plot_type", "line")

    # Filter the DataFrame based on selected filters
    if selected_variable and selected_region and selected_model:
        filtered_data = df[(df['Variable'] == selected_variable) &
                           (df['Region'] == selected_region) &
                           (df['Model'] == selected_model)]
        if not filtered_data.empty:
            # Create traces for each scenario
            years = [2020, 2025, 2030, 2035, 2040, 2045, 2050]
            traces = []
            for scenario, scenario_data in filtered_data.groupby('Scenario'):
                if selected_plot_type == "line":
                    trace = go.Scatter(
                        x=years,
                        y=scenario_data[years].values.flatten(),
                        mode='lines',
                        line=dict(width=5, shape='spline'),
                        name=scenario
                    )
                elif selected_plot_type == "line+marker":
                    trace = go.Scatter(
                        x=years,
                        y=scenario_data[years].values.flatten(),
                        mode='lines+markers',
                        line=dict(width=5, shape='spline'),
                        name=scenario
                    )
                elif selected_plot_type == "bar":
                    trace = go.Bar(
                        x=years,
                        y=scenario_data[years].values.flatten(),

                        name=scenario
                    )
                traces.append(trace)

            # Create the plot
            layout = go.Layout(
                title=selected_variable,
                xaxis=dict(title='Year', showgrid=False, tickfont=dict(color="black")),
                yaxis=dict(title='Value', showgrid=False, tickfont=dict(color="black")),
                height=750,
                plot_bgcolor='rgba(0,0,0,0)',
                paper_bgcolor='rgba(8,8,8,8)'
            )
            fig = go.Figure(data=traces, layout=layout)
            plot_div_single = plot(fig, output_type='div', include_plotlyjs=False)
        else:
            # If filtered data is empty, set plot_div_single to None
            plot_div_single = None
    else:
        # If any of the options is not selected, set filtered_data and plot_div_single to None
        filtered_data, plot_div_single = None, None

    # Get unique values for each column
    variable_options = df['Variable'].unique().tolist()
    region_options = df['Region'].unique().tolist()
    model_options = df['Model'].unique().tolist()

    # Filter region options based on selected variable
    if selected_variable:
        region_options = df[df['Variable'] == selected_variable]['Region'].unique().tolist()

    # Filter model options based on selected variable and region
    if selected_variable and selected_region:
        model_options = df[(df['Variable'] == selected_variable) & (df['Region'] == selected_region)]['Model'].unique().tolist()

    # Prepare context to pass to the template
    context = {
        'variable_options': variable_options,
        'region_options': region_options,
        'model_options': model_options,
        'selected_variable': selected_variable,
        'selected_region': selected_region,
        'selected_model': selected_model,
        'selected_plot_type': selected_plot_type,
        'filtered_data': filtered_data,
        'plot_div_single': plot_div_single,
    }

    return render(request, 'dashboard.html', context)

# def dashboard(request):
#     # Load data from Excel file
#     df = pd.read_excel("charts/static/data/bs_check.xlsx")
#
#     # Get selected options from request
#     selected_variable = request.GET.get('variable', None)
#     selected_region = request.GET.get('region', None)
#     selected_model = request.GET.get("model", None)
#     selected_plot_type = request.GET.get("plot_type", None)
#
#     # Filter the DataFrame based on selected filters
#     if selected_variable and selected_region and selected_model:
#         filtered_data = df[(df['Variable'] == selected_variable) &
#                            (df['Region'] == selected_region) &
#                            (df['Model'] == selected_model)]
#         if not filtered_data.empty:
#             # Create traces for each scenario
#             years = [2020, 2025, 2030, 2035, 2040, 2045, 2050]
#             traces = []
#             for scenario, scenario_data in filtered_data.groupby('Scenario'):
#                 if selected_plot_type == "line":
#                     trace = go.Scatter(
#                         x=years,
#                         y=scenario_data[years].values.flatten(),
#                         mode='lines',
#                         line=dict(width=3),
#                         name=scenario
#                     )
#                 elif selected_plot_type == "line+marker":
#                     trace = go.Scatter(
#                         x=years,
#                         y=scenario_data[years].values.flatten(),
#                         mode='lines+markers',
#                         line=dict(width=3),
#                         name=scenario
#                     )
#                 elif selected_plot_type == "bar":
#                     trace = go.Bar(
#                         x=years,
#                         y=scenario_data[years].values.flatten(),
#                         name=scenario
#                     )
#                 traces.append(trace)
#
#             # Create the plot
#             layout = go.Layout(
#                 title=selected_variable,
#                 xaxis=dict(title='Year', showgrid=True, tickfont=dict(color="black")),
#                 yaxis=dict(title='Value', showgrid=True, tickfont=dict(color="black")),
#                 height=750,
#                 plot_bgcolor='rgba(0,0,0,0)',
#                 paper_bgcolor='rgba(8,8,8,8)'
#             )
#             fig = go.Figure(data=traces, layout=layout)
#             plot_div_single = plot(fig, output_type='div', include_plotlyjs=False)
#         else:
#             # If filtered data is empty, set plot_div_single to None
#             plot_div_single = None
#     else:
#         # If any of the options is not selected, set filtered_data and plot_div_single to None
#         filtered_data, plot_div_single = None, None
#
#     # Get unique values for each column
#     variable_options = df['Variable'].unique().tolist()
#     region_options = df['Region'].unique().tolist()
#     model_options = df['Model'].unique().tolist()
#
#     # Filter region options based on selected variable
#     if selected_variable:
#         region_options = df[df['Variable'] == selected_variable]['Region'].unique().tolist()
#
#     # Filter model options based on selected variable and region
#     if selected_variable and selected_region:
#         model_options = df[(df['Variable'] == selected_variable) & (df['Region'] == selected_region)]['Model'].unique().tolist()
#
#     # Prepare context to pass to the template
#     context = {
#         'variable_options': variable_options,
#         'region_options': region_options,
#         'model_options': model_options,
#         'selected_variable': selected_variable,
#         'selected_region': selected_region,
#         'selected_model': selected_model,
#         'selected_plot_type': selected_plot_type,
#         'filtered_data': filtered_data,
#         'plot_div_single': plot_div_single,
#     }
#
#     return render(request, 'dashboard.html', context)

# def dashboard(request):
#     # Load data from Excel file
#     df = pd.read_excel("charts/static/data/bs_check.xlsx")
#
#     # Get selected options from request
#     selected_variable = request.GET.get('variable', None)
#     selected_region = request.GET.get('region', None)
#     selected_model = request.GET.get("model", None)
#     selected_plot_type = request.GET.get("plot_type", None)
#
#
#     # Filter the DataFrame based on selected filters
#     if selected_variable and selected_region and selected_model:
#         filtered_data = df[(df['Variable'] == selected_variable) &
#                            (df['Region'] == selected_region) &
#                            (df['Model'] == selected_model)]
#         if not filtered_data.empty:
#             # Create traces for each scenario
#             years = [2020, 2025, 2030, 2035, 2040, 2045, 2050]
#             traces = []
#             for scenario, scenario_data in filtered_data.groupby('Scenario'):
#                 trace = go.Scatter(
#                     x=years,
#                     y=scenario_data[years].values.flatten(),
#                     mode='lines+markers',
#                     line=dict(width=5, shape='spline'),
#                     name=scenario
#                 )
#                 traces.append(trace)
#             # Create the multiline plot
#             layout = go.Layout(
#                 title=selected_variable,
#                 xaxis=dict(title='Year', showgrid=False, tickfont=dict(color="black")),
#                 yaxis=dict(title='Value', showgrid=False, tickfont=dict(color="black")),
#                 height=750,
#                 plot_bgcolor='rgba(0,0,0,0)',
#                 paper_bgcolor='rgba(8,8,8,8)'
#             )
#             fig = go.Figure(data=traces, layout=layout)
#             plot_div_single = plot(fig, output_type='div', include_plotlyjs=False)
#         else:
#             # If filtered data is empty, set plot_div_single to None
#             plot_div_single = None
#     else:
#         # If any of the options is not selected, set filtered_data and plot_div_single to None
#         filtered_data, plot_div_single = None, None
#
#     # Get unique values for each column
#     variable_options = df['Variable'].unique().tolist()
#     region_options = df['Region'].unique().tolist()
#     model_options = df['Model'].unique().tolist()
#
#     # Filter region options based on selected variable
#     if selected_variable:
#         region_options = df[df['Variable'] == selected_variable]['Region'].unique().tolist()
#
#     # Filter model options based on selected variable and region
#     if selected_variable and selected_region:
#         model_options = df[(df['Variable'] == selected_variable) & (df['Region'] == selected_region)]['Model'].unique().tolist()
#
#     # Prepare context to pass to the template
#     context = {
#         'variable_options': variable_options,
#         'region_options': region_options,
#         'model_options': model_options,
#         'selected_variable': selected_variable,
#         'selected_region': selected_region,
#         'selected_model': selected_model,
#         'filtered_data': filtered_data,
#         'selected_plot_type': selected_plot_type,
#         'plot_div_single': plot_div_single,
#     }
#
#     return render(request, 'dashboard.html', context)

# def dashboard(request):
#     # Load data from Excel file
#     df = pd.read_excel("charts/static/data/bs_check.xlsx")
#     print(df)
#     # Get selected options from request
#     selected_variable = request.GET.get('variable', None)
#     selected_country = request.GET.get('country', None)
#     selected_model = request.GET.get("model", None)
#
#     # Filter the DataFrame based on selected filters
#     if selected_variable and selected_country and selected_model:
#         filtered_data = df[(df['Variable'] == selected_variable) &
#                            (df['Region'] == selected_country) &
#                            (df['Model'] == selected_model)]
#         if not filtered_data.empty:
#             # Create traces for each scenario
#             years = [2020, 2025, 2030, 2035, 2040, 2045, 2050]
#             traces = []
#             for scenario, scenario_data in filtered_data.groupby('Scenario'):
#                 trace = go.Scatter(
#                     x=years,
#                     y=scenario_data[years].values.flatten(),
#                     mode='lines+markers',
#                     line=dict(width=5, shape='spline'),
#                     name=scenario
#                 )
#                 traces.append(trace)
#             # Create the multiline plot
#             layout = go.Layout(
#                 title=selected_variable,
#                 xaxis=dict(title='Year', showgrid=False, tickfont=dict(color="black")),
#                 yaxis=dict(title='Value', showgrid=False, tickfont=dict(color="black")),
#                 height=750,
#                 plot_bgcolor='rgba(0,0,0,0)',
#                 paper_bgcolor='rgba(8,8,8,8)'
#             )
#             fig = go.Figure(data=traces, layout=layout)
#             plot_div_single = plot(fig, output_type='div', include_plotlyjs=False)
#         else:
#             # If filtered data is empty, set plot_div_single to None
#             plot_div_single = None
#     else:
#         # If any of the options is not selected, set filtered_data and plot_div_single to None
#         filtered_data, plot_div_single = None, None
#
#     # Get unique values for each column
#     variable_options = df['Variable'].unique().tolist()
#     country_options = df['Region'].unique().tolist()
#     model_options = df['Model'].unique().tolist()
#
#     # Filter country options based on selected variable
#     if selected_variable:
#         country_options = df[df['Variable'] == selected_variable]['Region'].unique().tolist()
#
#     # Filter model options based on selected variable and country
#     if selected_variable and selected_country:
#         model_options = df[(df['Variable'] == selected_variable) & (df['Region'] == selected_country)]['Model'].unique().tolist()
#
#     # Prepare context to pass to the template
#     context = {
#         'variable_options': variable_options,
#         'country_options': country_options,
#         'model_options': model_options,
#         'selected_variable': selected_variable,
#         'selected_country': selected_country,
#         'selected_model': selected_model,
#         'filtered_data': filtered_data,
#         'plot_div_single': plot_div_single,
#     }
#
#     return render(request, 'dashboard.html', context)












.dropdown-container select option[value*="BL"] {
    color: yellow;
}

.dropdown-container select option[value*="NZ"] {
    color: skyblue;
}

.dropdown-container select option[value*="DT"] {
    color: black;
}

.dropdown-container select option[value*="DP"] {
    color: red;



















from django.shortcuts import render
from django.core.paginator import Paginator
import pandas as pd
import plotly.graph_objs as go
from plotly.offline import plot

def dashboard(request):
    # Get selected options from request
    selected_variable = request.GET.get('variable', None)
    selected_region = request.GET.get('region', None)
    selected_model = request.GET.get("model", None)
    selected_plot_type = request.GET.get("plot_type", "line")

    # Load data from Excel file (consider loading only necessary columns if dataset is too large)
    df = pd.read_excel("charts/static/data/bs_check.xlsx")

    # Filter the DataFrame based on selected filters
    filtered_data = df.copy()  # Copy the dataframe to avoid modifying the original one
    if selected_variable:
        filtered_data = filtered_data[filtered_data['Variable'] == selected_variable]
    if selected_region:
        filtered_data = filtered_data[filtered_data['Region'] == selected_region]
    if selected_model:
        filtered_data = filtered_data[filtered_data['Model'] == selected_model]

    # Pagination
    paginator = Paginator(filtered_data.values.tolist(), 10)  # Change 10 to your desired page size
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)

    # Create the plot if data is available
    if len(filtered_data) > 0:
        # Extract relevant columns for plotting
        years = [2020, 2025, 2030, 2035, 2040, 2045, 2050]
        traces = []
        for scenario, scenario_data in filtered_data.groupby('Scenario'):
            if selected_plot_type == "line":
                trace = go.Scatter(
                    x=years,
                    y=scenario_data[years].values.flatten(),
                    mode='lines',
                    line=dict(width=5, shape='spline'),
                    name=scenario
                )
            elif selected_plot_type == "line+marker":
                trace = go.Scatter(
                    x=years,
                    y=scenario_data[years].values.flatten(),
                    mode='lines+markers',
                    line=dict(width=5, shape='spline'),
                    name=scenario
                )
            elif selected_plot_type == "bar":
                trace = go.Bar(
                    x=years,
                    y=scenario_data[years].values.flatten(),
                    name=scenario
                )
            traces.append(trace)

        # Create the plot
        layout = go.Layout(
            title=selected_variable,
            xaxis=dict(title='Year', showgrid=False, tickfont=dict(color="black")),
            yaxis=dict(title='Value', showgrid=False, tickfont=dict(color="black")),
            height=750,
            plot_bgcolor='rgba(0,0,0,0)',
            paper_bgcolor='rgba(8,8,8,8)'
        )
        fig = go.Figure(data=traces, layout=layout)
        plot_div_single = plot(fig, output_type='div', include_plotlyjs=False)
    else:
        plot_div_single = None

    # Get unique values for each column
    variable_options = df['Variable'].unique().tolist()
    region_options = df['Region'].unique().tolist()
    model_options = df['Model'].unique().tolist()

    # Prepare context to pass to the template
    context = {
        'variable_options': variable_options,
        'region_options': region_options,
        'model_options': model_options,
        'selected_variable': selected_variable,
        'selected_region': selected_region,
        'selected_model': selected_model,
        'selected_plot_type': selected_plot_type,
        'page_obj': page_obj,
        'plot_div_single': plot_div_single,
    }

    return render(request, 'dashboard.html', context)


















from django.shortcuts import render
from django.core.paginator import Paginator
import pandas as pd
import plotly.graph_objs as go
from plotly.offline import plot

def dashboard(request):
    # Get selected options from request
    selected_variable = request.GET.get('variable', None)
    selected_region = request.GET.get('region', None)
    selected_model = request.GET.get("model", None)
    selected_plot_type = request.GET.get("plot_type", "line")

    # Load data from Excel file (consider loading only necessary columns if dataset is too large)
    df = pd.read_excel("charts/static/data/bs_check.xlsx")

    # Filter the DataFrame based on selected filters
    filtered_data = df.copy()  # Copy the dataframe to avoid modifying the original one
    if selected_variable:
        filtered_data = filtered_data[filtered_data['Variable'] == selected_variable]
    if selected_region:
        filtered_data = filtered_data[filtered_data['Region'] == selected_region]
    if selected_model:
        filtered_data = filtered_data[filtered_data['Model'] == selected_model]

    # Pagination
    paginator = Paginator(filtered_data.values.tolist(), 10)  # Change 10 to your desired page size
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)

    # Create the plot if data is available
    if len(filtered_data) > 0:
        # Extract relevant columns for plotting
        years = [2020, 2025, 2030, 2035, 2040, 2045, 2050]
        traces = []
        for scenario, scenario_data in filtered_data.groupby('Scenario'):
            if selected_plot_type == "line":
                trace = go.Scatter(
                    x=years,
                    y=scenario_data[years].values.flatten(),
                    mode='lines',
                    line=dict(width=5, shape='spline'),
                    name=scenario
                )
            elif selected_plot_type == "line+marker":
                trace = go.Scatter(
                    x=years,
                    y=scenario_data[years].values.flatten(),
                    mode='lines+markers',
                    line=dict(width=5, shape='spline'),
                    name=scenario
                )
            elif selected_plot_type == "bar":
                trace = go.Bar(
                    x=years,
                    y=scenario_data[years].values.flatten(),
                    name=scenario
                )
            traces.append(trace)

        # Create the plot
        layout = go.Layout(
            title=selected_variable,
            xaxis=dict(title='Year', showgrid=False, tickfont=dict(color="black")),
            yaxis=dict(title='Value', showgrid=False, tickfont=dict(color="black")),
            height=750,
            plot_bgcolor='rgba(0,0,0,0)',
            paper_bgcolor='rgba(8,8,8,8)'
        )
        fig = go.Figure(data=traces, layout=layout)
        plot_div_single = plot(fig, output_type='div', include_plotlyjs=False)
    else:
        plot_div_single = None

    # Get unique values for each column
    variable_options = df['Variable'].unique().tolist()
    region_options = df['Region'].unique().tolist()
    model_options = df['Model'].unique().tolist()

    # Prepare context to pass to the template
    context = {
        'variable_options': variable_options,
        'region_options': region_options,
        'model_options': model_options,
        'selected_variable': selected_variable,
        'selected_region': selected_region,
        'selected_model': selected_model,
        'selected_plot_type': selected_plot_type,
        'page_obj': page_obj,
        'plot_div_single': plot_div_single,
    }

    return render(request, 'dashboard.html', context)












# Install necessary packages
!pip install plotly pandas

# Load data from Excel file (for demonstration, you can upload your file to Colab)
import pandas as pd

# Load your dataset
df = pd.read_excel("path_to_your_file/bs_check.xlsx")

# Create dropdowns using Plotly's Dash components
import plotly.graph_objs as go
import dash
import dash_core_components as dcc
import dash_html_components as html
from dash.dependencies import Input, Output

app = dash.Dash(__name__)

app.layout = html.Div([
    html.H1('Dashboard for Scenario'),
    html.Div([
        html.Label('Variable:'),
        dcc.Dropdown(
            id='variable-dropdown',
            options=[{'label': var, 'value': var} for var in df['Variable'].unique()],
            value=None,
            multi=False
        ),
        html.Label('Region:'),
        dcc.Dropdown(
            id='region-dropdown',
            options=[{'label': reg, 'value': reg} for reg in df['Region'].unique()],
            value=None,
            multi=False
        ),
        html.Label('Model:'),
        dcc.Dropdown(
            id='model-dropdown',
            options=[{'label': mod, 'value': mod} for mod in df['Model'].unique()],
            value=None,
            multi=False
        ),
        html.Label('Plot Type:'),
        dcc.Dropdown(
            id='plot-type-dropdown',
            options=[
                {'label': 'Line', 'value': 'line'},
                {'label': 'Line+Marker', 'value': 'line+marker'},
                {'label': 'Bar', 'value': 'bar'}
            ],
            value='line',
            multi=False
        ),
    ]),
    html.Div(id='plot-container')
])

@app.callback(
    Output('plot-container', 'children'),
    [Input('variable-dropdown', 'value'),
     Input('region-dropdown', 'value'),
     Input('model-dropdown', 'value'),
     Input('plot-type-dropdown', 'value')]
)
def update_plot(selected_variable, selected_region, selected_model, selected_plot_type):
    # Filter the DataFrame based on selected filters
    filtered_data = df.copy()  # Copy the dataframe to avoid modifying the original one
    if selected_variable:
        filtered_data = filtered_data[filtered_data['Variable'] == selected_variable]
    if selected_region:
        filtered_data = filtered_data[filtered_data['Region'] == selected_region]
    if selected_model:
        filtered_data = filtered_data[filtered_data['Model'] == selected_model]

    # Create traces for each scenario
    years = [2020, 2025, 2030, 2035, 2040, 2045, 2050]
    traces = []
    for scenario, scenario_data in filtered_data.groupby('Scenario'):
        if selected_plot_type == "line":
            trace = go.Scatter(
                x=years,
                y=scenario_data[years].values.flatten(),
                mode='lines',
                line=dict(width=5, shape='spline'),
                name=scenario
            )
        elif selected_plot_type == "line+marker":
            trace = go.Scatter(
                x=years,
                y=scenario_data[years].values.flatten(),
                mode='lines+markers',
                line=dict(width=5, shape='spline'),
                name=scenario
            )
        elif selected_plot_type == "bar":
            trace = go.Bar(
                x=years,
                y=scenario_data[years].values.flatten(),
                name=scenario
            )
        traces.append(trace)

    # Create the plot
    layout = go.Layout(
        title=selected_variable,
        xaxis=dict(title='Year', showgrid=False, tickfont=dict(color="black")),
        yaxis=dict(title='Value', showgrid=False, tickfont=dict(color="black")),
        height=750,
        plot_bgcolor='rgba(0,0,0,0)',
        paper_bgcolor='rgba(8,8,8,8)'
    )
    fig = go.Figure(data=traces, layout=layout)
    return dcc.Graph(
        id='plot',
        figure=fig
    )

if __name__ == '__main__':
    app.run_server(debug=True, use_reloader=False)








# Import necessary modules
from django.shortcuts import render
import pandas as pd
import plotly.graph_objs as go
from dash import Dash
from dash.dependencies import Input, Output
import dash_core_components as dcc
import dash_html_components as html

# Create a function to generate the Dash dashboard layout
def generate_dash_layout(df):
    # Define the Dash app
    app = Dash(__name__)

    # Define the layout of the dashboard
    app.layout = html.Div([
        html.H1('Dashboard for Scenario'),
        html.Div([
            html.Label('Variable:'),
            dcc.Dropdown(
                id='variable-dropdown',
                options=[{'label': var, 'value': var} for var in df['Variable'].unique()],
                value=None,
                multi=False
            ),
            html.Label('Region:'),
            dcc.Dropdown(
                id='region-dropdown',
                options=[{'label': reg, 'value': reg} for reg in df['Region'].unique()],
                value=None,
                multi=False
            ),
            html.Label('Model:'),
            dcc.Dropdown(
                id='model-dropdown',
                options=[{'label': mod, 'value': mod} for mod in df['Model'].unique()],
                value=None,
                multi=False
            ),
            html.Label('Plot Type:'),
            dcc.Dropdown(
                id='plot-type-dropdown',
                options=[
                    {'label': 'Line', 'value': 'line'},
                    {'label': 'Line+Marker', 'value': 'line+marker'},
                    {'label': 'Bar', 'value': 'bar'}
                ],
                value='line',
                multi=False
            ),
        ]),
        html.Div(id='plot-container')
    ])

    # Define the callback function to update the plot
    @app.callback(
        Output('plot-container', 'children'),
        [Input('variable-dropdown', 'value'),
         Input('region-dropdown', 'value'),
         Input('model-dropdown', 'value'),
         Input('plot-type-dropdown', 'value')]
    )
    def update_plot(selected_variable, selected_region, selected_model, selected_plot_type):
        # Filter the DataFrame based on selected filters
        filtered_data = df.copy()  # Copy the dataframe to avoid modifying the original one
        if selected_variable:
            filtered_data = filtered_data[filtered_data['Variable'] == selected_variable]
        if selected_region:
            filtered_data = filtered_data[filtered_data['Region'] == selected_region]
        if selected_model:
            filtered_data = filtered_data[filtered_data['Model'] == selected_model]

        # Create traces for each scenario
        years = [2020, 2025, 2030, 2035, 2040, 2045, 2050]
        traces = []
        for scenario, scenario_data in filtered_data.groupby('Scenario'):
            if selected_plot_type == "line":
                trace = go.Scatter(
                    x=years,
                    y=scenario_data[years].values.flatten(),
                    mode='lines',
                    line=dict(width=5, shape='spline'),
                    name=scenario
                )
            elif selected_plot_type == "line+marker":
                trace = go.Scatter(
                    x=years,
                    y=scenario_data[years].values.flatten(),
                    mode='lines+markers',
                    line=dict(width=5, shape='spline'),
                    name=scenario
                )
            elif selected_plot_type == "bar":
                trace = go.Bar(
                    x=years,
                    y=scenario_data[years].values.flatten(),
                    name=scenario
                )
            traces.append(trace)

        # Create the plot
        layout = go.Layout(
            title=selected_variable,
            xaxis=dict(title='Year', showgrid=False, tickfont=dict(color="black")),
            yaxis=dict(title='Value', showgrid=False, tickfont=dict(color="black")),
            height=750,
            plot_bgcolor='rgba(0,0,0,0)',
            paper_bgcolor='rgba(8,8,8,8)'
        )
        fig = go.Figure(data=traces, layout=layout)
        return dcc.Graph(
            id='plot',
            figure=fig
        )

    # Return the app's layout
    return app.layout

# Your existing Django view
def dashboard(request):
    # Load data from Excel file
    df = pd.read_excel("charts/static/data/bs_check.xlsx")

    # Generate the Dash dashboard layout
    dash_layout = generate_dash_layout(df)

    # Pass the Dash layout to the template
    context = {'dash_layout': dash_layout}
    return render(request, 'dashboard.html', context)














??????????AutomateGSIB???


import pandas as pd
from openpyxl import load_workbook, Workbook
from datetime import datetime
from openpyxl.styles import Font, PatternFill, Side, Border

def add_output_columns(sheet):
    df = pd.read_excel(sheet)
    df["GDP YR"] = df.groupby(["ISOCODES"])["GDP"].pct_change(4) * 100
    df["CPI YR"] = df.groupby(["ISOCODES"])["CPI"].pct_change(4) * 100
    df["PH YR"] = df.groupby(["ISOCODES"])["PH"].pct_change(4) * 100
    df["PH DUBAI YR"] = df.groupby(["ISOCODES"])["PH_DUBAI"].pct_change(4) * 100
    df["PCOM YR"] = df.groupby(["ISOCODES"])["PCOM"].pct_change(4) * 100
    df["GDP QoQ"] = df.groupby(["ISOCODES"])["GDP"].pct_change(1) * 100
    df["CPI QoQ"] = df.groupby(["ISOCODES"])["CPI"].pct_change(1) * 100
    df["PH_QoQ"] = df.groupby(["ISOCODES"])["PH"].pct_change(1) * 100
    df["PH_DUBAI_QOQ"] = df.groupby(["ISOCODES"])["PH_DUBAI"].pct_change(1) * 100
    df["PCOM QOQ"] = df.groupby(["ISOCODES"])["PCOM"].pct_change(1) * 100
    return df

def calculate_weights(df_table, isocode):
    mapping_file_path = "C:\\Users\\45363901\\PycharmProjects\\pythonProject\\Automation_GBIC\\GBIC Workings Data\\Input Mapping File Copy.xlsx"
    country_sheet = pd.read_excel(mapping_file_path, sheet_name="Country")
    scenario_weights_sheet = pd.read_excel(mapping_file_path, sheet_name="Scenario Weights")
    merged_sheet = scenario_weights_sheet.merge(country_sheet, on="ISOCODE")
    u1_weight = merged_sheet[(merged_sheet["ISOCODE"] == isocode) & (merged_sheet["SCENARIO NAME"] == "U1")]["WEIGHT"].values[0]
    cn_weight = merged_sheet[(merged_sheet["ISOCODE"] == isocode) & (merged_sheet["SCENARIO NAME"] == "CN")]["WEIGHT"].values[0]
    d1_weight = merged_sheet[(merged_sheet["ISOCODE"] == isocode) & (merged_sheet["SCENARIO NAME"] == "D1")]["WEIGHT"].values[0]
    d2_weight = merged_sheet[(merged_sheet["ISOCODE"] == isocode) & (merged_sheet["SCENARIO NAME"] == "D2")]["WEIGHT"].values[0]
    for i in range(0, 18):
        df_table.values[i][8] = (
            df_table.values[i][4] * u1_weight + df_table.values[i][5] * cn_weight +
            df_table.values[i][6] * d1_weight + df_table.values[i][7] * d2_weight
        )[0]

def construct_and_populate_tables(isocode, tzero_date, col):
    current_year = 2024

    columns = [
        "Upside",
        "Central",
        "Down 1",
        "Down 2",
        "Upside",
        "Central",
        "Down 1",
        "Down 2",
        "Weighted",
        "10% UP",
        "Central",
        "10% DN",
        "4% DN",
    ]
    rows = [
        ["Q1", "Q2", "Q3", "Q4", current_year, current_year + 1, current_year + 2, current_year + 3, "", "", "", "", ""],
        [str(current_year) + "-03-31", str(current_year) + "-06-30", str(current_year) + "-09-30", str(current_year) + "-12-31", str(current_year + 1), str(current_year + 1) + "-03-31", str(current_year + 1) + "-06-30", str(current_year + 1) + "-09-30", "", "", "", "", ""],
    ]
    df_table = pd.DataFrame(columns=columns, index=rows)
    df_table.loc[-1] = ['IFRS 1024' for _ in range(len(columns))]
    df_table.loc[-2] = ['IFRS9 4023 Scenarios' for _ in range(len(columns))]
    df_table.index += 2
    df_table = df_table.sort_index()

    year3_sum = 0
    year4_sum = 0
    col_index = 0

    for frame in All:
        for row in frame.itertuples():
            # Your existing code to populate the DataFrame goes here

    calculate_weights(df_table, isocode)
    return df_table

def adjust_col_width_and_font_size(sheet):
    for column in sheet.columns:
        column_letter = column[0].column_letter
        if column_letter in ['A', 'B', 'C']:
            continue
        sheet.column_dimensions[column_letter].width = 6
        for cell in column:
            cell.font = cell.font if cell.font else Font()
            cell.font = Font(size=9)

input_file = r"C:\Users\45363901\PycharmProjects\pythonProject\Automation_GBIC\GBIC_Workings Data\GBIC_Workings\2401_GBIC_Tables_29022024.xlsx"
workbook = load_workbook(input_file)

for sheet_name in workbook.sheetnames:
    sheet = workbook[sheet_name]
    # Remove gridlines
    sheet.sheet_view.showGridLines = False
    # Apply grey color to all data cells except column names
    for row in sheet.iter_rows(min_row=2):
        for cell in row:
            if cell.row > 5:
                cell.fill = PatternFill(start_color="FFAFAFAF", end_color="FFAFAFAF", fill_type="solid")
    # Add darker grey to specific rows
    for row in sheet.iter_rows(min_row=2, max_row=5):
        for cell in row:
            cell.fill = PatternFill(start_color="FF808080", end_color="FF808080", fill_type="solid")
    # Rename Q1, Q2, etc. columns to country codes
    for cell in sheet["D"][1:]:
        cell.value = cell.value.replace("Q", "")
    # Add rows for IFRS scenarios
    sheet.insert_rows(1)
    sheet.insert_rows(1)
    sheet["D1"].value = "IFRS 1024"
    sheet["D2"].value = "IFRS9 4023 Scenarios"
    sheet["A1"].value = "Moody's"
    sheet["B1"].value = "Moody's"
    sheet["C1"].value = "Moody's"
    sheet["A2"].value = "Moody's"
    sheet["B2"].value = "Moody's"
    sheet["C2"].value = "Moody's"
    sheet["A1"].font = Font(color="FFFF0000")
    sheet["B1"].font = Font(color="FFFF0000")
    sheet["C1"].font = Font(color="FFFF0000")
    sheet["A2"].font = Font(color="FFFF0000")
    sheet["B2"].font = Font(color="FFFF0000")
    sheet["C2"].font = Font(color="FFFF0000")
    sheet["D1"].font = Font(color="FFFF0000")
    sheet["D2"].font = Font(color="FFFF0000")
    sheet["D1"].fill = PatternFill(start_color="FF87CEEB", end_color="FF87CEEB", fill_type="solid")
    sheet["D2"].fill = PatternFill(start_color="FF87CEEB", end_color="FF87CEEB", fill_type="solid")
    # Apply thin white border to separate cells
    thin_border = Border(left=Side(style='thin'), right=Side(style='thin'), top=Side(style='thin'), bottom=Side(style='thin'))
    for row in sheet.iter_rows():
        for cell in row:
            cell.border = thin_border

    adjust_col_width_and_font_size(sheet)

workbook.save(input_file)


























import pandas as pd
from openpyxl import load_workbook, Workbook
from datetime import datetime
from openpyxl.styles import Font, PatternFill, Border, Side


def add_output_columns(sheet):
    df = pd.read_excel(sheet)

    df["GDP YR"] = df.groupby(["ISOCODES"])["GDP"].pct_change(4) * 100
    df["CPI YR"] = df.groupby(["ISOCODES"])["CPI"].pct_change(4) * 100
    df["PH YR"] = df.groupby(["ISOCODES"])["PH"].pct_change(4) * 100
    df["PH DUBAI YR"] = df.groupby(["ISOCODES"])["PH_DUBAI"].pct_change(4) * 100
    df["PCOM YR"] = df.groupby(["ISOCODES"])["PCOM"].pct_change(4) * 100
    df["GDP QoQ"] = df.groupby(["ISOCODES"])["GDP"].pct_change(1) * 100
    df["CPI QoQ"] = df.groupby(["ISOCODES"])["CPI"].pct_change(1) * 100
    df["PH_QoQ"] = df.groupby(["ISOCODES"])["PH"].pct_change(1) * 100
    df["PH_DUBAI_QOQ"] = df.groupby(["ISOCODES"])["PH_DUBAI"].pct_change(1) * 100
    df["PCOM QOQ"] = df.groupby(["ISOCODES"])["PCOM"].pct_change(1) * 100

    return df


def calculate_syear_avg(frame, isocode, tzero_date, col):
    index = frame[(frame["ISOCODES"] == isocode) & (frame["date"] == datetime.strptime(tzero_date, "%Y-%m-%d %H:%M:%S"))]
    if not index.empty:
        avg = frame[col].iloc[(index.index[0] + 1): (index.index[0] + 21)].mean()
        return avg
    else:
        return None


def calculate_weights(df_table, isocode):
    mapping_file_path = "C:\\Users\\45363901\\PycharmProjects\\pythonProject\\Automation_GBIC\\GBIC Workings Data\\Input Mapping File Copy.xlsx"

    country_sheet = pd.read_excel(mapping_file_path, sheet_name="Country")
    scenario_weights_sheet = pd.read_excel(mapping_file_path, sheet_name="Scenario Weights")

    merged_sheet = scenario_weights_sheet.merge(country_sheet, on="ISOCODE")

    u1_weight = merged_sheet[(merged_sheet["ISOCODE"] == isocode) & (merged_sheet["SCENARIO NAME"] == "U1")]["WEIGHT"].values[0]
    cn_weight = merged_sheet[(merged_sheet["ISOCODE"] == isocode) & (merged_sheet["SCENARIO NAME"] == "CN")]["WEIGHT"].values[0]
    d1_weight = merged_sheet[(merged_sheet["ISOCODE"] == isocode) & (merged_sheet["SCENARIO NAME"] == "D1")]["WEIGHT"].values[0]
    d2_weight = merged_sheet[(merged_sheet["ISOCODE"] == isocode) & (merged_sheet["SCENARIO NAME"] == "D2")]["WEIGHT"].values[0]

    for i in range(0, 18):
        df_table.values[i][8] = (
            df_table.values[i][4] * u1_weight
            + df_table.values[i][5] * cn_weight
            + df_table.values[i][6] * d1_weight
            + df_table.values[i][7] * d2_weight
        )[0]


def construct_and_populate_tables(isocode, tzero_date, col):
    current_year = 2024

    columns = [
        "Upside",
        "Central",
        "Down 1",
        "Down 2",
        "Upside",
        "Central",
        "Down 1",
        "Down 2",
        "Weighted",
        "10% UP",
        "Central",
        "10% DN",
        "4% DN",
    ]
    rows = [
        ["Q1", "Q2", "Q3", "Q4", current_year, current_year + 1, current_year + 2, current_year + 3, "", "", "", "", ""],
        [str(current_year) + "-03-31", str(current_year) + "-06-30", str(current_year) + "-09-30", str(current_year) + "-12-31", str(current_year + 1), str(current_year + 1) + "-03-31", str(current_year + 1) + "-06-30", str(current_year + 1) + "-09-30", "", "", "", "", ""],
    ]
    df_table = pd.DataFrame(columns=columns, index=rows)

    year3_sum = 0
    year4_sum = 0
    col_index = 0

    for frame in All:
        for row in frame.itertuples():
            # For previous year
            if (
                row.ISOCODES == isocode
                and row.date == datetime.strptime(str(current_year - 1) + "-03-31 00:00:00", "%Y-%m-%d %H:%M:%S")
            ):
                df_table.values[0][col_index] = getattr(row, col)
            elif (
                row.ISOCODES == isocode
                and row.date == datetime.strptime(str(current_year - 1) + "-06-30 00:00:00", "%Y-%m-%d %H:%M:%S")
            ):
                df_table.values[1][col_index] = getattr(row, col)
            elif (
                row.ISOCODES == isocode
                and row.date == datetime.strptime(str(current_year - 1) + "-09-30 00:00:00", "%Y-%m-%d %H:%M:%S")
            ):
                df_table.values[2][col_index] = getattr(row, col)
            elif (
                row.ISOCODES == isocode
                and row.date == datetime.strptime(str(current_year - 1) + "-12-31 00:00:00", "%Y-%m-%d %H:%M:%S")
            ):
                df_table.values[3][col_index] = getattr(row, col)

            # For current year
            elif (
                row.ISOCODES == isocode
                and row.date == datetime.strptime(str(current_year) + "-03-31 00:00:00", "%Y-%m-%d %H:%M:%S")
            ):
                df_table.values[5][col_index] = getattr(row, col)
            elif (
                row.ISOCODES == isocode
                and row.date == datetime.strptime(str(current_year) + "-06-30 00:00:00", "%Y-%m-%d %H:%M:%S")
            ):
                df_table.values[6][col_index] = getattr(row, col)
            elif (
                row.ISOCODES == isocode
                and row.date == datetime.strptime(str(current_year) + "-09-30 00:00:00", "%Y-%m-%d %H:%M:%S")
            ):
                df_table.values[7][col_index] = getattr(row, col)
            elif (
                row.ISOCODES == isocode
                and row.date == datetime.strptime(str(current_year) + "-12-31 00:00:00", "%Y-%m-%d %H:%M:%S")
            ):
                df_table.values
            elif (
                row.ISOCODES == isocode
                and row.date == datetime.strptime(str(current_year + 1) + "-03-31 00:00:00", "%Y-%m-%d %H:%M:%S")
            ):
                df_table.values[10][col_index] = getattr(row, col)
            elif (
                row.ISOCODES == isocode
                and row.date == datetime.strptime(str(current_year + 1) + "-06-30 00:00:00", "%Y-%m-%d %H:%M:%S")
            ):
                df_table.values[11][col_index] = getattr(row, col)
            elif (
                row.ISOCODES == isocode
                and row.date == datetime.strptime(str(current_year + 1) + "-09-30 00:00:00", "%Y-%m-%d %H:%M:%S")
            ):
                df_table.values[12][col_index] = getattr(row, col)
            elif (
                row.ISOCODES == isocode
                and row.date == datetime.strptime(str(current_year + 1) + "-12-31 00:00:00", "%Y-%m-%d %H:%M:%S")
            ):
                df_table.values[13][col_index] = getattr(row, col)

            # For next year 2
            elif (
                row.ISOCODES == isocode
                and row.date == datetime.strptime(str(current_year + 2) + "-03-31 00:00:00", "%Y-%m-%d %H:%M:%S")
            ):
                year3_sum += getattr(row, col)
            elif (
                row.ISOCODES == isocode
                and row.date == datetime.strptime(str(current_year + 2) + "-06-30 00:00:00", "%Y-%m-%d %H:%M:%S")
            ):
                year3_sum += getattr(row, col)
            elif (
                row.ISOCODES == isocode
                and row.date == datetime.strptime(str(current_year + 2) + "-09-30 00:00:00", "%Y-%m-%d %H:%M:%S")
            ):
                year3_sum += getattr(row, col)
            elif (
                row.ISOCODES == isocode
                and row.date == datetime.strptime(str(current_year + 2) + "-12-31 00:00:00", "%Y-%m-%d %H:%M:%S")
            ):
                year3_sum += getattr(row, col)

            # For next year + 3
            elif (
                row.ISOCODES == isocode
                and row.date == datetime.strptime(str(current_year + 3) + "-03-31 00:00:00", "%Y-%m-%d %H:%M:%S")
            ):
                year4_sum += getattr(row, col)
            elif (
                row.ISOCODES == isocode
                and row.date == datetime.strptime(str(current_year + 3) + "-06-30 00:00:00", "%Y-%m-%d %H:%M:%S")
            ):
                year4_sum += getattr(row, col)
            elif (
                row.ISOCODES == isocode
                and row.date == datetime.strptime(str(current_year + 3) + "-09-30 00:00:00", "%Y-%m-%d %H:%M:%S")
            ):
                year4_sum += getattr(row, col)

        df_table.values[4][col_index] = (df_table.values[0][col_index] + df_table.values[1][col_index] +
                                         df_table.values[2][col_index] + df_table.values[3][col_index]) / 4
        df_table.values[9][col_index] = (df_table.values[5][col_index] + df_table.values[6][col_index] +
                                         df_table.values[7][col_index] + df_table.values[8][col_index]) / 4
        df_table.values[14][col_index] = (df_table.values[10][col_index] + df_table.values[11][col_index] +
                                          df_table.values[12][col_index] + df_table.values[13][col_index]) / 4
        calculate_5year_avg(frame, isocode, tzero_date, col)
        df_table.values[17][col_index] = df_table.values[15][col_index]
        df_table.values[16][col_index] = df_table.values[16][col_index]
        df_table.values[16][col_index] = year3_sum / 4
        df_table.values[16][col_index] = year4_sum / 4
        year3_sum = 0
        year4_sum = 0
        col_index += 1
        if col_index == 8:
            col_index = 1
    calculate_weights(df_table, isocode)
    return df_table


def adjust_col_width_and_font_size(sheet):
    for column in sheet.columns:
        column_letter = column[0].column_letter
        if column_letter in ['A', 'B', 'C']:
            continue
        sheet.column_dimensions[column_letter].width = 6
        for cell in column:
            cell.font = cell.font if cell.font else Font()
            cell.font = Font(size=9)


def format_excel(input_file):
    workbook = load_workbook(input_file)

    for sheet_name in workbook.sheetnames:
        sheet = workbook[sheet_name]
        sheet.sheet_view.showGridLines = False

        # Apply grey color to all data cells except column names
        for row in sheet.iter_rows(min_row=2):
            for cell in row:
                if cell.row > 5:
                    cell.fill = PatternFill(start_color="FFAFAFAF", end_color="FFAFAFAF", fill_type="solid")

        # Add darker grey to specific rows
        for row in sheet.iter_rows(min_row=2, max_row=5):
            for cell in row:
                cell.fill = PatternFill(start_color="FF808080", end_color="FF808080", fill_type="solid")

        # Rename Q1, Q2, etc. columns to country codes
        for cell in sheet["D"][1:]:
            cell.value = cell.value.replace("Q", "")

        # Add rows for IFRS scenarios
        sheet.insert_rows(1)
        sheet.insert_rows(1)
        sheet["D1"].value = "IFRS 1024"
        sheet["D2"].value = "IFRS9 4023 Scenarios"
        sheet["A1"].value = "Moody's"
        sheet["B1"].value = "Moody's"
        sheet["C1"].value = "Moody's"
        sheet["A2"].value = "Moody's"
        sheet["B2"].value = "Moody's"
        sheet["C2"].value = "Moody's"
        sheet["A1"].font = Font(color="FFFF0000")
        sheet["B1"].font = Font(color="FFFF0000")
        sheet["C1"].font = Font(color="FFFF0000")
        sheet["A2"].font = Font(color="FFFF0000")
        sheet["B2"].font = Font(color="FFFF0000")
        sheet["C2"].font = Font(color="FFFF0000")
        sheet["D1"].font = Font(color="FFFF0000")
        sheet["D2"].font = Font(color="FFFF0000")
        sheet["D1"].fill = PatternFill(start_color="FF87CEEB", end_color="FF87CEEB", fill_type="solid")
        sheet["D2"].fill = PatternFill(start_color="FF87CEEB", end_color="FF87CEEB", fill_type="solid")

        # Apply thin white border to separate cells
        thin_border = Border(left=Side(style='thin'), right=Side(style='thin'), top=Side(style='thin'), bottom=Side(style='thin'))
        for row in sheet.iter_rows():
            for cell in row:
                cell.border = thin_border

        adjust_col_width_and_font_size(sheet)

    workbook.save(input_file)


def main():
    input_file = r"C:\Users\45363901\PycharmProjects\pythonProject\Automation_GBIC\GBIC_Workings Data\GBIC_Workings\2401_GBIC_Tables_29022024.xlsx"
    format_excel(input_file)


if __name__ == "__main__":
    main()



















workbook = load_workbook(input_file)

for sheet_name in workbook.sheetnames:
    sheet = workbook[sheet_name]
    # Remove gridlines
    sheet.sheet_view.showGridLines = False
    # Apply grey color to all data cells except column names
    for row in sheet.iter_rows(min_row=2):
        for cell in row:
            if cell.row > 5:
                cell.fill = PatternFill(start_color="FFAFAFAF", end_color="FFAFAFAF", fill_type="solid")
    # Add darker grey to specific rows
    for row in sheet.iter_rows(min_row=2, max_row=5):
        for cell in row:
            cell.fill = PatternFill(start_color="FF808080", end_color="FF808080", fill_type="solid")
    # Rename Q1, Q2, etc. columns to country codes
    for cell in sheet["D"][1:]:
        cell.value = cell.value.replace("Q", "")
    # Freeze top 5 rows and left 4 columns
    sheet.freeze_panes = "E6"

output_file = input_file.replace(".xlsx", "_formatted.xlsx")
workbook.save(output_file)











workbook = load_workbook(input_file)

for sheet_name in workbook.sheetnames:
    sheet = workbook[sheet_name]
    # Remove gridlines
    sheet.sheet_view.showGridLines = False
    # Apply grey color to all data cells except column names
    for row in sheet.iter_rows(min_row=2):
        for cell in row:
            if cell.row > 5:
                cell.fill = PatternFill(start_color="FFAFAFAF", end_color="FFAFAFAF", fill_type="solid")
    # Add darker grey to specific rows
    for row in sheet.iter_rows(min_row=2, max_row=5):
        for cell in row:
            cell.fill = PatternFill(start_color="FF808080", end_color="FF808080", fill_type="solid")
    # Rename Q1, Q2, etc. columns to country codes
    for cell in sheet["D"][1:]:
        cell.value = cell.value.replace("Q", "")
    # Freeze top 5 rows and left 4 columns
    sheet.freeze_panes = "E6"
    # Add header row for IFRS scenarios
    sheet.insert_rows(1)
    sheet["D1"].value = "IFRS 1024"
    sheet["D2"].value = "IFRS9 4023 Scenarios"
    sheet["A1"].value = "Moody's"
    sheet["B1"].value = "Moody's"
    sheet["C1"].value = "Moody's"
    sheet["A2"].value = "Moody's"
    sheet["B2"].value = "Moody's"
    sheet["C2"].value = "Moody's"
    sheet["A1"].font = Font(color="FFFF0000")
    sheet["B1"].font = Font(color="FFFF0000")
    sheet["C1"].font = Font(color="FFFF0000")
    sheet["A2"].font = Font(color="FFFF0000")
    sheet["B2"].font = Font(color="FFFF0000")
    sheet["C2"].font = Font(color="FFFF0000")
    sheet["D1"].font = Font(color="FFFF0000")
    sheet["D2"].font = Font(color="FFFF0000")
    sheet["D1"].fill = PatternFill(start_color="FF87CEEB", end_color="FF87CEEB", fill_type="solid")
    sheet["D2"].fill = PatternFill(start_color="FF87CEEB", end_color="FF87CEEB", fill_type="solid")
    # Apply thin white border to separate cells
    thin_border = Border(left=Side(style='thin'), right=Side(style='thin'), top=Side(style='thin'), bottom=Side(style='thin'))
    for row in sheet.iter_rows():
        for cell in row:
            cell.border = thin_border

output_file = input_file.replace(".xlsx", "_formatted.xlsx")
workbook.save(output_file)


















import pandas as pd
import openpyxl
from openpyxl import load_workbook, Workbook
from openpyxl.styles import Font, PatternFill, Border, Side
from datetime import datetime

def add_output_columns(sheet, workbook):
    ws = workbook[sheet]
    data = ws.values
    cols = next(data)
    data = list(data)
    df = pd.DataFrame(data, columns=cols).round(1)  # Round data to 1 decimal place

    # Your existing transformations
    df["GDP YR"] = df.groupby(["ISOCODES"])["GDP"].pct_change(4) * 100
    df["CPI YR"] = df.groupby(["ISOCODES"])["CPI"].pct_change(4) * 100
    df["PH YR"] = df.groupby(["ISOCODES"])["PH"].pct_change(4) * 100
    df["PH DUBAI YR"] = df.groupby(["ISOCODES"])["PH_DUBAI"].pct_change(4) * 100
    df["PCOM YR"] = df.groupby(["ISOCODES"])["PCOM"].pct_change(4) * 100
    df["GDP QoQ"] = df.groupby(["ISOCODES"])["GDP"].pct_change(1) * 100
    df["CPI QoQ"] = df.groupby(["ISOCODES"])["CPI"].pct_change(1) * 100
    df["PH_QoQ"] = df.groupby(["ISOCODES"])["PH"].pct_change(1) * 100
    df["PH_DUBAI_QOQ"] = df.groupby(["ISOCODES"])["PH_DUBAI"].pct_change(1) * 100
    df["PCOM QOQ"] = df.groupby(["ISOCODES"])["PCOM"].pct_change(1) * 100

    return df

# Assuming the rest of your functions are defined here as per your original code

def apply_custom_formatting(workbook):
    for sheet_name in workbook.sheetnames:
        sheet = workbook[sheet_name]
        # Apply formatting here as per your requirements
        for row in sheet.iter_rows(min_row=2):
            for cell in row:
                if cell.row > 5:
                    cell.fill = PatternFill(start_color="FFAFAFAF", end_color="FFAFAFAF", fill_type="solid")
                if cell.row in [1, 2, 3, 4, 5]:
                    cell.fill = PatternFill(start_color="FF808080", end_color="FF808080", fill_type="solid")
                if cell.row == 1:
                    cell.font = Font(color="FFFF0000")
                thin_border = Border(left=Side(style='thin'), right=Side(style='thin'), top=Side(style='thin'), bottom=Side(style='thin'))
                cell.border = thin_border
        # Add custom rows for IFRS scenarios if needed

# Load workbook and apply transformations and formatting
input_file = r"C:\Users\45363901\PycharmProjects\pythonProject\Automation_GBIC\GBIC_Workings Data\Data - Copy.xlsx"
workbook = load_workbook(input_file)
sheetNames = workbook.sheetnames
All = []

for sheet in sheetNames:
    df = add_output_columns(sheet, workbook)
    All.append(df)

# Assuming you have a function to write these DataFrames back to an Excel file
# After writing back to Excel, reload the workbook to apply custom formatting
workbook = load_workbook('path_to_your_new_excel_file.xlsx')  # Use the path where you saved the new Excel file
apply_custom_formatting(workbook)
workbook.save('path_to_your_final_excel_file.xlsx')  # Save the final version of your Excel file with formatting








import pandas as pd
from openpyxl import load_workbook, Workbook
from openpyxl.styles import Font, PatternFill, Border, Side
from datetime import datetime
import numpy as np

# Function to add output columns to DataFrame
def add_output_columns(df):
    # Assuming 'df' is your DataFrame after reading from Excel
    # Perform your calculations here
    # Example:
    df["GDP YR"] = df.groupby(["ISOCODES"])["GDP"].pct_change(4) * 100
    # Continue for other columns...
    return df.round(1)  # Round to 1 decimal place

# Function to apply custom formatting to a sheet
def apply_custom_formatting(sheet):
    for row in sheet.iter_rows(min_row=2):
        for cell in row:
            if cell.row > 5:
                cell.fill = PatternFill(start_color="FFAFAFAF", end_color="FFAFAFAF", fill_type="solid")
            if cell.row in [1, 2, 3, 4, 5]:
                cell.fill = PatternFill(start_color="FF808080", end_color="FF808080", fill_type="solid")
            if cell.row == 1:
                cell.font = Font(color="FFFF0000")
            thin_border = Border(left=Side(style='thin'), right=Side(style='thin'), top=Side(style='thin'), bottom=Side(style='thin'))
            cell.border = thin_border

    # Additional formatting here as needed

# Main code
input_file = "path_to_your_excel_file.xlsx"
output_file = "path_to_your_output_file.xlsx"

# Load the workbook and sheet names
workbook = load_workbook(input_file)
sheet_names = workbook.sheetnames

# New workbook for output
wb_out = Workbook()
wb_out.remove(wb_out.active)  # Remove default sheet

for sheet_name in sheet_names:
    ws = workbook[sheet_name]
    data = ws.values
    cols = next(data)[0:]  # Read the header row
    data = list(data)  # Convert iterator to list
    df = pd.DataFrame(data, columns=cols)

    # Apply your data transformations
    df_transformed = add_output_columns(df)

    # Write transformed DataFrame to new workbook
    ws_out = wb_out.create_sheet(title=sheet_name)
    for r in dataframe_to_rows(df_transformed, index=False, header=True):
        ws_out.append(r)

# Save the transformed data to a new Excel file
wb_out.save(output_file)

# Re-open the output workbook to apply formatting
wb_formatted = load_workbook(output_file)
for sheet_name in wb_formatted.sheetnames:
    sheet = wb_formatted[sheet_name]
    apply_custom_formatting(sheet)

#









import pandas as pd
from openpyxl import load_workbook, Workbook
from datetime import datetime
from openpyxl.styles import Font, PatternFill, Border, Side

def add_output_columns(sheet):
    df = pd.read_excel(sheet)

    df["GDP YR"] = df.groupby(["ISOCODES"])["GDP"].pct_change(4) * 100
    df["CPI YR"] = df.groupby(["ISOCODES"])["CPI"].pct_change(4) * 100
    df["PH YR"] = df.groupby(["ISOCODES"])["PH"].pct_change(4) * 100
    df["PH DUBAI YR"] = df.groupby(["ISOCODES"])["PH_DUBAI"].pct_change(4) * 100
    df["PCOM YR"] = df.groupby(["ISOCODES"])["PCOM"].pct_change(4) * 100
    df["GDP QoQ"] = df.groupby(["ISOCODES"])["GDP"].pct_change(1) * 100
    df["CPI QoQ"] = df.groupby(["ISOCODES"])["CPI"].pct_change(1) * 100
    df["PH_QoQ"] = df.groupby(["ISOCODES"])["PH"].pct_change(1) * 100
    df["PH_DUBAI_QOQ"] = df.groupby(["ISOCODES"])["PH_DUBAI"].pct_change(1) * 100
    df["PCOM QOQ"] = df.groupby(["ISOCODES"])["PCOM"].pct_change(1) * 100

    return df

input_file = r"C:\Users\45363901\PycharmProjects\pythonProject\Automation_GBIC\GBIC Workings Data\Data - Copy.xlsx"
workbook = openpyxl.load_workbook(input_file)
sheetNames = workbook.sheetnames
All = list()
for sheet in sheetNames:
    df = add_output_columns(sheet)
    All.append(df)

# ... (rest of the code remains the same until the end of the construct_and_populate_tables function)

def adjust_col_width_and_font_size(sheet):
    for column in sheet.columns:
        column_letter = column[0].column_letter
        if column_letter in ['A', 'B', 'C']:
            continue
        sheet.column_dimensions[column_letter].width = 6
        for cell in column:
            cell.font = cell.font if cell.font else Font()
            cell.font = Font(size=9)
            cell.value = round(cell.value, 1) if cell.value is not None else None

def format_sheet(sheet):
    # Remove gridlines
    sheet.sheet_view.showGridLines = False

    # Apply grey color to all data cells except column names
    for row in sheet.iter_rows(min_row=2):
        for cell in row:
            if cell.row > 5:
                cell.fill = PatternFill(start_color="FFAFAFAF", end_color="FFAFAFAF", fill_type="solid")

    # Add darker grey to specific rows
    for row in sheet.iter_rows(min_row=2, max_row=5):
        for cell in row:
            cell.fill = PatternFill(start_color="FF808080", end_color="FF808080", fill_type="solid")

    # Rename Q1, Q2, etc. columns to country codes
    country_list = ["GBR", "HKG", "CHN", "FRA", "USA", "CAN", "MEX", "ARE", "GBL"]
    for cell, country in zip(sheet["D"][1:], country_list):
        cell.value = country

    # Add rows for IFRS scenarios
    sheet.insert_rows(1)
    sheet.insert_rows(1)
    sheet["D1"].value = "IFRS 1024"
    sheet["D2"].value = "IFRS9 4023 Scenarios"
    sheet["A1"].value = "Moody's"
    sheet["B1"].value = "Moody's"
    sheet["C1"].value = "Moody's"
    sheet["A2"].value = "Moody's"
    sheet["B2"].value = "Moody's"
    sheet["C2"].value = "Moody's"
    sheet["A1"].font = Font(color="FFFF0000")
    sheet["B1"].font = Font(color="FFFF0000")
    sheet["C1"].font = Font(color="FFFF0000")
    sheet["A2"].font = Font(color="FFFF0000")
    sheet["B2"].font = Font(color="FFFF0000")
    sheet["C2"].font = Font(color="FFFF0000")
    sheet["D1"].font = Font(color="FFFF0000")
    sheet["D2"].font = Font(color="FFFF0000")
    sheet["D1"].fill = PatternFill(start_color="FF87CEEB", end_color="FF87CEEB", fill_type="solid")
    sheet["D2"].fill = PatternFill(start_color="FF87CEEB", end_color="FF87CEEB", fill_type="solid")
    sheet["D1"].font = Font(color="FFFFFFFF")
    sheet["D2"].font = Font(color="FFFFFFFF")

    # Apply thin white border to separate cells
    thin_border = Border(left=Side(style='thin'), right=Side(style='thin'), top=Side(style='thin'), bottom=Side(style='thin'))
    for row in sheet.iter_rows():
        for cell in row:
            cell.border = thin_border

# All tables append(df_table)
tzero_date = "2024-03-31"

Table_List = pd.read_excel(
    r"C:\Users\45363901\PycharmProjects\pythonProject\Automation_GBIC\GBIC_Workings Data\Input Mapping File - Copy.xlsx",
    sheet_name="Table_List")

country_list = ["GBR", "HKG", "CHN", "FRA", "USA", "CAN", "MEX", "ARE", "GBL"]

wb = Workbook()
wb.save("2401 GBIC_Tables_29022024.xlsx")

for Isocode in country_list:
    col_list = Table_List["MEV"].loc[Table_List["Country"] == Isocode].tolist()
    writer = pd.ExcelWriter("2401_GBIC_Tables_29022024.xlsx", engine="openpyxl", mode="a", if_sheet_exists='overlay')
    start_row = 6
    start_col = 4
    for col in col_list:
        table = construct_and_populate_tables(Isocode, tzero_date, col)
        table.to_excel(writer, sheet_name=Isocode, startrow=start_row, startcol=start_col, index=True)
        start_col += len(table.columns) + 4
    writer.close()

input_file = r"C:\Users\45363901\PycharmProjects\pythonProject\Automation_GBIC\GBIC_Workings Data\GBIC_Workings\2401_GBIC_Tables_29022024.xlsx"
workbook = openpyxl.load_workbook(input_file)
for sheet_name in workbook.sheetnames:
    sheet = workbook[sheet_name]
    adjust_col_width_and_font_size(sheet)
    format_sheet(sheet)

workbook.save(input_file)





























def format_sheet(sheet):
    # Remove gridlines
    sheet.sheet_view.showGridLines = False

    # Apply grey color to all data cells except column names
    for row in sheet.iter_rows(min_row=2):
        for cell in row:
            if cell.row > 5:
                cell.fill = PatternFill(start_color="FFAFAFAF", end_color="FFAFAFAF", fill_type="solid")

    # Add darker grey to specific rows
    for row in sheet.iter_rows(min_row=2, max_row=5):
        for cell in row:
            cell.fill = PatternFill(start_color="FF808080", end_color="FF808080", fill_type="solid")

    # Rename Q1, Q2, etc. columns to country codes
    country_list = ["GBR", "HKG", "CHN", "FRA", "USA", "CAN", "MEX", "ARE", "GBL"]
    for cell, country in zip(sheet["D"][1:], country_list):
        cell.value = country

    # Add rows for IFRS scenarios
    sheet.insert_rows(1)
    sheet["D1"].value = "IFRS 2024 Scenarios"
    sheet["D2"].value = "IFRS 2023 Scenarios"
    sheet["A1"].value = "Moody's"
    sheet["B1"].value = "Moody's"
    sheet["C1"].value = "Moody's"
    sheet["A2"].value = "Moody's"
    sheet["B2"].value = "Moody's"
    sheet["C2"].value = "Moody's"

    # Set font color and fill for Moody's and IFRS columns
    for col in ["A", "B", "C", "D"]:
        for cell in sheet[col]:
            if cell.value == "Moody's":
                cell.font = Font(color="FF87CEEB")  # Light sky blue
            elif cell.value == "IFRS 2023 Scenarios" or cell.value == "IFRS 2024 Scenarios":
                cell.font = Font(color="FFFF0000")  # Red

    # Apply grey fill to all cells with data
    for row in sheet.iter_rows():
        for cell in row:
            if cell.value is not None:
                cell.fill = PatternFill(start_color="FFAFAFAF", end_color="FFAFAFAF", fill_type="solid")

    # Apply thin white border to separate cells
    thin_border = Border(left=Side(style='thin'), right=Side(style='thin'), top=Side(style='thin'), bottom=Side(style='thin'))
    for row in sheet.iter_rows():
        for cell in row:
            cell.border = thin_border

# Call the function to format the sheet
format_sheet(sheet)







import pandas as pd
from openpyxl import load_workbook, Workbook
from datetime import datetime
from openpyxl.styles import Font, PatternFill, Border, Side

def add_output_columns(sheet):
    df = pd.read_excel(sheet)

    df["GDP YR"] = df.groupby(["ISOCODES"])["GDP"].pct_change(4) * 100
    df["CPI YR"] = df.groupby(["ISOCODES"])["CPI"].pct_change(4) * 100
    df["PH YR"] = df.groupby(["ISOCODES"])["PH"].pct_change(4) * 100
    df["PH DUBAI YR"] = df.groupby(["ISOCODES"])["PH_DUBAI"].pct_change(4) * 100
    df["PCOM YR"] = df.groupby(["ISOCODES"])["PCOM"].pct_change(4) * 100
    df["GDP QoQ"] = df.groupby(["ISOCODES"])["GDP"].pct_change(1) * 100
    df["CPI QoQ"] = df.groupby(["ISOCODES"])["CPI"].pct_change(1) * 100
    df["PH_QoQ"] = df.groupby(["ISOCODES"])["PH"].pct_change(1) * 100
    df["PH_DUBAI_QOQ"] = df.groupby(["ISOCODES"])["PH_DUBAI"].pct_change(1) * 100
    df["PCOM QOQ"] = df.groupby(["ISOCODES"])["PCOM"].pct_change(1) * 100

    return df

input_file = r"C:\Users\45363901\PycharmProjects\pythonProject\Automation_GBIC\GBIC_Workings Data\Input\Data - Copy.xlsx"
workbook = openpyxl.load_workbook(input_file)
sheetNames = workbook.sheetnames
All = list()
for sheet in sheetNames:
    df = add_output_columns(sheet)
    All.append(df)

def construct_and_populate_tables(Isocode, tzero_date, col):
    curr_year = 2024
    columns = ['IFRS9 1Q24 Scenarios', 'IFRS9 1Q24 Scenarios', 'IFRS9 1Q24 Scenarios', 'IFRS9 1Q24 Scenarios', 'IFRS9 4Q23 Scenarios', 'IFRS9 4Q23 Scenarios', 'IFRS9 4Q23 Scenarios', 'IFRS9 4Q23 Scenarios', 'Weighted', 'Moody\'s', 'Moody\'s', 'Moody\'s', 'Moody\'s']
    rows = [['Q1', 'Q2', 'Q3', 'Q4', curr_year, 'Q1', 'Q2', 'Q3', 'Q4', curr_year, 'Q1', 'Q2', 'Q3', 'Q4', curr_year + 1, curr_year + 2, curr_year + 3, '5yr Avg']]
    df_table = pd.DataFrame(columns=columns, index=rows)
    year3_sum = 0
    year4_sum = 0
    col_index = 0

    for frame in All:
        for row in frame.itertuples():
            # For previous year
            if row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year - 1) + "-03-31 00:00:00", "%Y-%m-%d %H:%M:%S"):
                df_table.values[0][0][col_index] = getattr(row, col)
            elif row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year - 1) + "-06-30 00:00:00", "%Y-%m-%d %H:%M:%S"):
                df_table.values[0][1][col_index] = getattr(row, col)
            elif row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year - 1) + "-09-30 00:00:00", "%Y-%m-%d %H:%M:%S"):
                df_table.values[0][2][col_index] = getattr(row, col)
            elif row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year - 1) + "-12-31 00:00:00", "%Y-%m-%d %H:%M:%S"):
                df_table.values[0][3][col_index] = getattr(row, col)

            # For current year
            elif row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year) + "-03-31 00:00:00", "%Y-%m-%d %H:%M:%S"):
                df_table.values[0][5][col_index] = getattr(row, col)
            elif row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year) + "-06-30 00:00:00", "%Y-%m-%d %H:%M:%S"):
                df_table.values[0][6][col_index] = getattr(row, col)
            elif row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year) + "-09-30 00:00:00", "%Y-%m-%d %H:%M:%S"):
                df_table.values[0][7][col_index] = getattr(row, col)
            elif row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year) + "-12-31 00:00:00", "%Y-%m-%d %H:%M:%S"):
                df_table.values[0][8][col_index] = getattr(row, col)

            # For next year
            elif row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 1) + "-03-31 00:00:00", "%Y-%m-%d %H:%M:%S"):
                df_table.values[0][10][col_index] = getattr(row, col)
            elif row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 1) + "-06-30 00:00:00", "%Y-%m-%d %H:%M:%S"):
                df_table.values[0][11][col_index] = getattr(row, col)
            elif row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 1) + "-09-30 00:00:00", "%Y-%m-%d %H:%M:%S"):
                df_table.values[0][12][col_index] = getattr(row, col)
            elif row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 1) + "-12-31 00:00:00", "%Y-%m-%d %H:%M:%S"):
                df_table.values[0][13][col_index] = getattr(row, col)

            # For current year + 2
            elif row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 2) + "-03-31 00:00:00", "%Y-%m-%d %H:%M:%S"):
                year3_sum += getattr(row, col)
            elif row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 2) + "-06-30 00:00:00", "%Y-%m-%d %H:%M:%S"):
                year3_sum += getattr(row, col)
            elif row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 2) + "-09-30 00:00:00", "%Y-%m-%d %H:%M:%S"):
                year3_sum += getattr(row, col)
            elif row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 2) + "-12-31 00:00:00", "%Y-%m-%d %H:%M:%S"):
                year3_sum += getattr(row, col)

            # For current year + 3
            elif row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 3) + "-03-31 00:00:00", "%Y-%m-%d %H:%M:%S"):
                year4_sum += getattr(row, col)
            elif row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 3) + "-06-30 00:00:00", "%Y-%m-%d %H:%M:%S"):
                year4_sum += getattr(row, col)
            elif row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 3) + "-09-30 00:00:00", "%Y-%m-%d %H:%M:%S"):
                year4_sum += getattr(row, col)
            elif row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 3) + "-12-31 00:00:00", "%Y-%m-%d %H:%M:%S"):
                year4_sum += getattr(row, col)

        df_table.values[0][4][col_index] = (df_table.values[0][0][col_index] + df_table.values[0][1][col_index] + df_table.values[0][2][col_index] + df_table.values[0][3][col_index]) / 4
        df_table.values[0][9][col_index] = (df_table.values[0][5][col_index] + df_table.values[0][6][col_index] + df_table.values[0][7][col_index] + df_table.values[0][8][col_index]) / 4
        df_table.values[0][14][col_index] = (df_table.values[0][10][col_index] + df_table.values[0][11][col_index] + df_table.values[0][12][col_index] + df_table.values[0][13][col_index]) / 4
        df_table.values[0][17][col_index] = calculate_5year_avg(frame, Isocode, tzero_date, col)
        df_table.values[0][15][col_index] = year3_sum / 4
        df_table.values[0][16][col_index] = year4_sum / 4
        year3_sum = 0
        year4_sum = 0
        col_index += 1
        if col_index == 8:
            col_index = 1
        calculate_weights(df_table, Isocode)
    return df_table

def format_sheet(sheet):
    # Remove gridlines
    sheet.sheet_view.showGridLines = False

    # Apply grey color to all data cells except column names
    for row in sheet.iter_rows(min_row=2):
        for cell in row:
            if cell.row > 5:
                cell.fill = PatternFill(start_color="FFAFAFAF", end_color="FFAFAFAF", fill_type="solid")

    # Add darker grey to specific rows
    for row in sheet.iter_rows(min_row=2, max_row=5):
        for cell in row:
            cell.fill = PatternFill(start_color="FF808080", end_color="FF808080", fill_type="solid")

    # Rename Q1, Q2, etc. columns to country codes
    country_list = ["GBR", "HKG", "CHN", "FRA", "USA", "CAN", "MEX", "ARE", "GBL"]
    for cell, country in zip(sheet["D"][1:], country_list):
        cell.value = country

    # Add rows for IFRS scenarios
    sheet.insert_rows(1)
    sheet["D1"].value = "IFRS9 1Q24 Scenarios"
    sheet["A1"].value = "IFRS9 1Q24 Scenarios"
    sheet["B1"].value = "IFRS9 1Q24 Scenarios"
    sheet["C1"].value = "IFRS9 1Q24 Scenarios"
    sheet.insert_rows(1)
    sheet["D2"].value = "IFRS9 4Q23 Scenarios"
    sheet["A2"].value = "IFRS9 4Q23 Scenarios"
    sheet["B2"].value = "IFRS9 4Q23 Scenarios"
    sheet["C2"].value = "IFRS9 4Q23 Scenarios"
    sheet.insert_rows(1)
    sheet["A3"].value = "Moody's"
    sheet["B3"].value = "Moody's"
    sheet["C3"].value = "Moody's"
    sheet["D3"].value = "Moody's"

    # Set font color and fill for Moody's and IFRS columns
    for col in ["A", "B", "C", "D"]:
        for cell in sheet[col]:
            if cell.value == "Moody's":
                cell.font = Font(color="FF87CEEB")  # Light sky blue
            elif cell.value == "IFRS9 1Q24 Scenarios" or cell.value == "IFRS9 4Q23 Scenarios":
                cell.font = Font(color="FFFF0000")  # Red

    # Apply grey fill to all cells with data
    for row in sheet.iter_rows():
        for cell in row:
            if cell.value is not None:
                cell.fill = PatternFill(start_color="FFAFAFAF", end_color="FFAFAFAF", fill_type="solid")

    # Apply thin white border to separate cells
    thin_border = Border(left=Side(style='thin'), right=Side(style='thin'), top=Side(style='thin'), bottom=Side(style='thin'))
    for row in sheet.iter_rows():
        for cell in row:
            cell.border = thin_border

# All tables append(df_table)
tzero_date = "2024-03-31"

mapping_file_path = r"C:\Users\45363901\PycharmProjects\pythonProject\Automation_GBIC\GBIC_Workings Data\Input\Mapping_File - Copy.xlsx"
Table_List = pd.read_excel(mapping_file_path, sheet_name="Table_List")

country_list = ["GBR", "HKG", "CHN", "FRA", "USA", "CAN", "MEX", "ARE", "GBL"]

output_file = r"C:\Users\45363901\PycharmProjects\pythonProject\Automation_GBIC\GBIC_Workings Data\GBIC_Workings\24Q1_GBIC_Tables_29022024.xlsx"
wb = Workbook()
wb.save(output_file)

for Isocode in country_list:
    col_list = Table_List["MEV"].loc[Table_List["Country"] == Isocode].tolist()
    writer = pd.ExcelWriter(output_file, engine="openpyxl", mode="a", if_sheet_exists='overlay')
    start_row = 6
    start_col = 4
    for col in col_list:
        table = construct_and_populate_tables(Isocode, tzero_date, col)






curr_year = 2024
  scenario_cols = ['Upside', 'Central', 'Down 1', 'Down 2']
  moody_cols = ['10% UP', 'Central', '10% DN', '4% DN']
  all_cols = scenario_cols * 2 + ['Weighted'] + moody_cols

  columns = all_cols
  rows = ['Q1', 'Q2', 'Q3', 'Q4', f'{curr_year} 1', 'Q1', 'Q2', 'Q3', 'Q4', curr_year, 'Q1', 'Q2', 'Q3', 'Q4', curr_year + 1, curr_year + 2, curr_year + 3, '5yr Avg']
  df_table = pd.DataFrame(columns=columns, index=rows)





def construct_and_populate_tables(Isocode, tzero_date, col):
    curr_year = 2024
    common_columns_1 = ['IFRS9 1Q24 Scenarios'] * 4
    common_columns_2 = ['IFRS9 4Q23 Scenarios'] * 4
    common_columns_3 = ["Moody's"] * 4
    columns = common_columns_1 + common_columns_2 + common_columns_3 + ['10% UP', 'Central', '10% DN', '4% DN']
    rows = ['Q1', 'Q2', 'Q3', 'Q4', str(curr_year) + ' 1', 'Q1', 'Q2', 'Q3', 'Q4', str(curr_year), 'Q1', 'Q2', 'Q3', 'Q4', str(curr_year + 1), str(curr_year + 2), str(curr_year + 3), '5yr Avg']
    df_table = pd.DataFrame(columns=columns, index=rows)
    year3_sum = 0
    year4_sum = 0
    col_index = 0





import pandas as pd
from openpyxl.styles import Alignment

def construct_and_populate_tables(Isocode, tzero_date, col):
    curr_year = 2024
    common_columns_1 = ['IFRS9 1Q24 Scenarios'] * 4
    common_columns_2 = ['IFRS9 4Q23 Scenarios'] * 4
    common_columns_3 = ["Moody's"] * 5
    columns = [''] + common_columns_1 + common_columns_2 + common_columns_3
    rows = ['ARE', 'Upside', 'Central', 'Down 1', 'Down 2', 'Upside', 'Central', 'Down 1', 'Down 2', 'Weighted', '10% UP', 'Central', '10% DN', '4% DN']
    df_table = pd.DataFrame(columns=columns, index=rows)
    year3_sum = 0
    year4_sum = 0
    col_index = 0

    for frame in All:
        for row in frame.itertuples():
            # for previous year
            if (row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year - 1) + "-03-31 00:00:00", "%Y-%m-%d %H:%M:%S")):
                df_table.values[1][col_index] = getattr(row, col)
            if (row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year - 1) + "-06-30 00:00:00", "%Y-%m-%d %H:%M:%S")):
                df_table.values[2][col_index] = getattr(row, col)
            if (row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year - 1) + "-09-30 00:00:00", "%Y-%m-%d %H:%M:%S")):
                df_table.values[3][col_index] = getattr(row, col)
            if (row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year - 1) + "-12-31 00:00:00", "%Y-%m-%d %H:%M:%S")):
                df_table.values[4][col_index] = getattr(row, col)

            # for current year
            if (row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year) + "-03-31 00:00:00", "%Y-%m-%d %H:%M:%S")):
                df_table.values[5][col_index] = getattr(row, col)
            if (row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year) + "-06-30 00:00:00", "%Y-%m-%d %H:%M:%S")):
                df_table.values[6][col_index] = getattr(row, col)
            if (row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year) + "-09-30 00:00:00", "%Y-%m-%d %H:%M:%S")):
                df_table.values[7][col_index] = getattr(row, col)
            if (row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year) + "-12-31 00:00:00", "%Y-%m-%d %H:%M:%S")):
                df_table.values[8][col_index] = getattr(row, col)

            # for next year
            if (row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 1) + "-03-31 00:00:00", "%Y-%m-%d %H:%M:%S")):
                df_table.values[10][col_index] = getattr(row, col)
            if (row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 1) + "-06-30 00:00:00", "%Y-%m-%d %H:%M:%S")):
                df_table.values[11][col_index] = getattr(row, col)
            if (row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 1) + "-09-30 00:00:00", "%Y-%m-%d %H:%M:%S")):
                df_table.values[12][col_index] = getattr(row, col)
            if (row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 1) + "-12-31 00:00:00", "%Y-%m-%d %H:%M:%S")):
                df_table.values[13][col_index] = getattr(row, col)

            # for current year + 2
            if (row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 2) + "-03-31 00:00:00", "%Y-%m-%d %H:%M:%S")):
                year3_sum += getattr(row, col)
            if (row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 2) + "-06-30 00:00:00", "%Y-%m-%d %H:%M:%S")):
                year3_sum += getattr(row, col)
            if (row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 2) + "-09-30 00:00:00", "%Y-%m-%d %H:%M:%S")):
                year3_sum += getattr(row, col)
            if (row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 2) + "-12-31 00:00:00", "%Y-%m-%d %H:%M:%S")):
                year3_sum += getattr(row, col)

            # for current year + 3
            if (row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 3) + "-03-31 00:00:00", "%Y-%m-%d %H:%M:%S")):
                year4_sum += getattr(row, col)
            if (row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 3) + "-06-30 00:00:00", "%Y-%m-%d %H:%M:%S")):
                year4_sum += getattr(row, col)
            if (row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 3) + "-09-30 00:00:00", "%Y-%m-%d %H:%M:%S")):
                year4_sum += getattr(row, col)
            if (row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 3) + "-12-31 00:00:00", "%Y-%m-%d %H:%M:%S")):
                year4_sum += getattr(row, col)

        df_table.values[9][col_index] = (df_table.values[5][col_index] + df_table.values[6][col_index] + df_table.values[7][col_index] + df_table.values[8][col_index]) / 4
        df_table.values[14][col_index] = (df_table.values[10][col_index] + df_table.values[11][col_index] + df_table.values[12][col_index] + df_table.values[13][col_index]) / 4
        df_table.values[17][col_index] = calculate_5year_avg(frame, Isocode, tzero_date, col)
        df_table.values[15][col_index] = year3_sum / 4
        df_table.values[16][col_index] = year4_sum / 4
        year3_sum = 0
        year4_sum = 0
        col_index += 1
        if col_index == 8:
            col_index += 1

    calculate_weights(df_table, Isocode)
    return df_table

def format_sheet(sheet):
    # Remove gridlines
    sheet.sheet_view.showGridLines = False

    # Apply grey color to all data cells except column names
    for row in sheet.iter_rows(min_row=2):
        for cell in row:
            if cell.row > 5:
                cell.fill = PatternFill(start_color="FFAFAFAF", end_color="FFAFAFAF", fill_type="solid")

    # Add darker grey to specific rows
    for row in sheet.iter_rows(min_row=2, max_row=5):
        for cell in row:
            cell.fill = PatternFill(start_color="FF808080", end_color="FF808080", fill_type="solid")

    # Rename Q1, Q2, etc. columns to country codes
    country_list = ["GBR", "HKG", "CHN", "FRA", "USA", "CAN", "MEX", "ARE", "GBL"]
    for cell, country in zip(sheet["D"][1:], country_list):
        cell.value = country

    # Apply grey fill to all cells with data
    for row in sheet.iter_rows():
        for cell in row:
            if cell.value is not None:
                cell.fill = PatternFill(start_color="FFAFAFAF", end_color="FFAFAFAF", fill_type="solid")

    # Apply thin white border to separate cells
    thin_border = Border(left=Side(style='thin'), right=Side(style='thin'), top=Side(style='thin'), bottom=Side(style='thin'))
    for row in sheet.iter_rows():
        for cell in row:
            cell.border = thin_border

    # Merge common columns and align center
    for col in range(1, 14, 4):
        sheet.merge_cells(start_row=1, start_column=col, end_row=1, end_column=col+3)
        sheet.cell(row=1, column=col).alignment = Alignment(horizontal='center')





















import pandas as pd
from openpyxl.styles import Alignment

def construct_and_populate_tables(Isocode, tzero_date, col):
    curr_year = 2024
    common_columns_1 = ['IFRS9 1Q24 Scenarios'] * 4
    common_columns_2 = ['IFRS9 4Q23 Scenarios'] * 4
    common_columns_3 = ["Moody's"] * 5
    columns = [''] + common_columns_1 + common_columns_2 + common_columns_3
    rows = ['ARE', 'Upside', 'Central', 'Down 1', 'Down 2', 'Upside', 'Central', 'Down 1', 'Down 2', 'Weighted', '10% UP', 'Central', '10% DN', '4% DN']
    df_table = pd.DataFrame(columns=columns, index=rows)
    year3_sum = 0
    year4_sum = 0
    col_index = 0

    for frame in All:
        for row in frame.itertuples():
            # for previous year
            if (row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year - 1) + "-03-31 00:00:00", "%Y-%m-%d %H:%M:%S")):
                df_table.values[1][col_index] = getattr(row, col)
            if (row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year - 1) + "-06-30 00:00:00", "%Y-%m-%d %H:%M:%S")):
                df_table.values[2][col_index] = getattr(row, col)
            if (row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year - 1) + "-09-30 00:00:00", "%Y-%m-%d %H:%M:%S")):
                df_table.values[3][col_index] = getattr(row, col)
            if (row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year - 1) + "-12-31 00:00:00", "%Y-%m-%d %H:%M:%S")):
                df_table.values[4][col_index] = getattr(row, col)

            # for current year
            if (row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year) + "-03-31 00:00:00", "%Y-%m-%d %H:%M:%S")):
                df_table.values[5][col_index] = getattr(row, col)
            if (row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year) + "-06-30 00:00:00", "%Y-%m-%d %H:%M:%S")):
                df_table.values[6][col_index] = getattr(row, col)
            if (row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year) + "-09-30 00:00:00", "%Y-%m-%d %H:%M:%S")):
                df_table.values[7][col_index] = getattr(row, col)
            if (row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year) + "-12-31 00:00:00", "%Y-%m-%d %H:%M:%S")):
                df_table.values[8][col_index] = getattr(row, col)

            # for next year
            if (row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 1) + "-03-31 00:00:00", "%Y-%m-%d %H:%M:%S")):
                df_table.values[10][col_index] = getattr(row, col)
            if (row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 1) + "-06-30 00:00:00", "%Y-%m-%d %H:%M:%S")):
                df_table.values[11][col_index] = getattr(row, col)
            if (row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 1) + "-09-30 00:00:00", "%Y-%m-%d %H:%M:%S")):
                df_table.values[12][col_index] = getattr(row, col)
            if (row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 1) + "-12-31 00:00:00", "%Y-%m-%d %H:%M:%S")):
                df_table.values[13][col_index] = getattr(row, col)

            # for current year + 2
            if (row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 2) + "-03-31 00:00:00", "%Y-%m-%d %H:%M:%S")):
                year3_sum += getattr(row, col)
            if (row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 2) + "-06-30 00:00:00", "%Y-%m-%d %H:%M:%S")):
                year3_sum += getattr(row, col)
            if (row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 2) + "-09-30 00:00:00", "%Y-%m-%d %H:%M:%S")):
                year3_sum += getattr(row, col)
            if (row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 2) + "-12-31 00:00:00", "%Y-%m-%d %H:%M:%S")):
                year3_sum += getattr(row, col)

            # for current year + 3
            if (row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 3) + "-03-31 00:00:00", "%Y-%m-%d %H:%M:%S")):
                year4_sum += getattr(row, col)
            if (row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 3) + "-06-30 00:00:00", "%Y-%m-%d %H:%M:%S")):
                year4_sum += getattr(row, col)
            if (row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 3) + "-09-30 00:00:00", "%Y-%m-%d %H:%M:%S")):
                year4_sum += getattr(row, col)
            if (row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 3) + "-12-31 00:00:00", "%Y-%m-%d %H:%M:%S")):
                year4_sum += getattr(row, col)

            col_index += 1

        df_table.values[9][col_index] = (df_table.values[5][col_index] + df_table.values[6][col_index] + df_table.values[7][col_index] + df_table.values[8][col_index]) / 4
        df_table.values[14][col_index] = (df_table.values[10][col_index] + df_table.values[11][col_index] + df_table.values[12][col_index] + df_table.values[13][col_index]) / 4
        df_table.values[17][col_index] = calculate_5year_avg(frame, Isocode, tzero_date, col)
        df_table.values[15][col_index] = year3_sum / 4
        df_table.values[16][col_index] = year4_sum / 4
        year3_sum = 0
        year4_sum = 0
        col_index += 1
        if col_index == 8:
            col_index += 1

    calculate_weights(df_table, Isocode)
    return df_table

def format_sheet(sheet):
    # Remove gridlines
    sheet.sheet_view.showGridLines = False

    # Apply grey color to all data cells except column names
    for row in sheet.iter_rows(min_row=2):
        for cell in row:
            if cell.row > 5:
                cell.fill = PatternFill(start_color="FFAFAFAF", end_color="FFAFAFAF", fill_type="solid")

    # Add darker grey to specific rows
    for row in sheet.iter_rows(min_row=2, max_row=5):
        for cell in row:
            cell.fill = PatternFill(start_color="FF808080", end_color="FF808080", fill_type="solid")

    # Rename Q1, Q2, etc. columns to country codes
    country_list = ["GBR", "HKG", "CHN", "FRA", "USA", "CAN", "MEX", "ARE", "GBL"]
    for cell, country in zip(sheet["D"][1:], country_list):
        cell.value = country

    # Apply grey fill to all cells with data
    for row in sheet.iter_rows():
        for cell in row:
            if cell.value is not None:
                cell.fill = PatternFill(start_color="FFAFAFAF", end_color="FFAFAFAF", fill_type="solid")

    # Apply thin white border to separate cells
    thin_border = Border(left=Side(style='thin'), right=Side(style='thin'), top=Side(style='thin'), bottom=Side(style='thin'))
    for row in sheet.iter_rows():
        for cell in row:
            cell.border = thin_border

    # Merge common columns and align center
    for col in range(1, 14, 4):
        sheet.merge_cells(start_row=1, start_column=col, end_row=1, end_column=col+3)
        sheet.cell(row=1, column=col).alignment = Alignment(horizontal='center')









curr_year = 2024
    common_columns_1 = ['ARE'] + ['IFRS9 1Q24 Scenarios'] * 4 + [''] + ['IFRS9 4Q23 Scenarios'] * 4 + [''] + ["Moody's"] * 3
    common_columns_2 = [''] + ['Upside', 'Central', 'Down 1', 'Down 2'] * 2 + ['Weighted'] + ['10% UP', 'Central', '10% DN', '4% DN 1']
    columns = common_columns_1 + common_columns_2
    rows = ['01', 'Q2', 'Q3', 'Q4', str(curr_year) + ' 1', 'Q1', 'Q2', 'Q3', 'Q4', str(curr_year), 'Q1', 'Q2', 'Q3', 'Q4', str(curr_year + 1), str(curr_year + 2), str(curr_year + 3), '5yr Avg']
    df_table = pd.DataFrame(columns=columns, index=rows)
    year3_sum = 0
    year4_sum = 0
    col_index = 0








import pandas as pd
from datetime import datetime

def construct_and_populate_tables(Isocode, tzero_date, col):
    curr_year = 2024
    columns_1 = ['ARE', 'IFRS9 1Q24 Scenarios', '', '', '', 'IFRS9 4Q23 Scenarios', '', '', '', "Moody's"]
    columns_2 = ['', 'Upside', 'Central', 'Down 1', 'Down 2', 'Upside', 'Central', 'Down 1', 'Down 2', 'Weighted', '10% up', 'Central', '10% DN', '4% DN']
    columns = [(col1, col2) for col1, col2 in zip(columns_1, columns_2)]
    rows = ['01', 'Q2', 'Q3', 'Q4', str(curr_year) + ' 1', 'Q1', 'Q2', 'Q3', 'Q4', str(curr_year), str(curr_year + 1), str(curr_year + 2), str(curr_year + 3), '5yr Avg']

    df_table = pd.DataFrame(index=rows)

    for col1, col2 in columns:
        df_table[col1] = col2

    for frame in All:
        for row in frame.itertuples():
            # Your existing logic here...

        # Your existing logic here...

    calculate_weights(df_table, Isocode)
    return df_table








import pandas as pd
from datetime import datetime

def construct_and_populate_tables(Isocode, tzero_date, col):
    curr_year = 2024
    columns_1 = ['ARE', 'IFRS9 1Q24 Scenarios', '', '', '', 'IFRS9 4Q23 Scenarios', '', '', '', "Moody's"]
    columns_2 = ['', 'Upside', 'Central', 'Down 1', 'Down 2', 'Upside', 'Central', 'Down 1', 'Down 2', 'Weighted', '10% up', 'Central', '10% DN', '4% DN']
    columns = [(col1, col2) for col1, col2 in zip(columns_1, columns_2)]
    rows = ['01', 'Q2', 'Q3', 'Q4', str(curr_year) + ' 1', 'Q1', 'Q2', 'Q3', 'Q4', str(curr_year), str(curr_year + 1), str(curr_year + 2), str(curr_year + 3), '5yr Avg']

    df_table = pd.DataFrame(index=rows)

    for col1, col2 in columns:
        df_table[col1] = col2

    for frame in All:
        for row in frame.itertuples():
            # Your existing logic here...

        # Your existing logic here...

    calculate_weights(df_table, Isocode)
    return df_table


columns_1 = ['ARE', '', '', '', '', 'IFRS9 1Q24 Scenarios', '', '', '', '', 'IFRS9 4Q23 Scenarios', '', '', '', '', "Moody's"]
columns_1 = ['ARE', '', '', '', '', 'IFRS9 1Q24 Scenarios', '', '', '', '', 'IFRS9 4Q23 Scenarios', '', '', '', '', "Moody's"]































































def construct_and_populate_tables(Isocode, tzero_date, col):
    # curr_year = int(input("enter the current year "))
    curr_year = 2024
    column_names = ['IFRS9 1Q24 Scenarios', 'IFRS9 4Q23 Scenarios', 'Moody\'s']
    columns = ['Upside', 'Central', 'Down 1', 'Down 2', 'Upside', 'Central', 'Down 1', 'Down 2', 'Weighted', '10% UP', 'Central', '10% DN', '4% DN']
    rows = ['Q1', 'Q2', 'Q3', 'Q4', str(curr_year - 1), 'Q1', 'Q2', 'Q3', 'Q4', str(curr_year), 'Q1', 'Q2', 'Q3', 'Q4', str(curr_year + 1), str(curr_year + 2), str(curr_year + 3), '5yr Avg']
    df_table = pd.DataFrame(columns=pd.MultiIndex.from_product([column_names, columns]), index=rows)
    year3_sum = 0
    year4_sum = 0
    col_index = 0
    #tzero_date = input("please give the tzero input: ")
    for frame in All:
        for row in frame.itertuples():
            # for previous year
            if row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year - 1) + "-03-31 00:00:00", "%Y-%m-%d %H:%M:%S"):
                df_table.values[0][(column_names[col_index], columns[col_index])] = getattr(row, col)
            if row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year - 1) + "-06-30 00:00:00", "%Y-%m-%d %H:%M:%S"):
                df_table.values[1][(column_names[col_index], columns[col_index + 1])] = getattr(row, col)
            if row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year - 1) + "-09-30 00:00:00", "%Y-%m-%d %H:%M:%S"):
                df_table.values[2][(column_names[col_index], columns[col_index + 2])] = getattr(row, col)
            if row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year - 1) + "-12-31 00:00:00", "%Y-%m-%d %H:%M:%S"):
                df_table.values[3][(column_names[col_index], columns[col_index + 3])] = getattr(row, col)
            # for current year
            if row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year) + "-03-31 00:00:00", "%Y-%m-%d %H:%M:%S"):
                df_table.values[5][(column_names[col_index + 1], columns[col_index])] = getattr(row, col)
            if row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year) + "-06-30 00:00:00", "%Y-%m-%d %H:%M:%S"):
                df_table.values[6][(column_names[col_index + 1], columns[col_index + 1])] = getattr(row, col)
            if row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year) + "-09-30 00:00:00", "%Y-%m-%d %H:%M:%S"):
                df_table.values[7][(column_names[col_index + 1], columns[col_index + 2])] = getattr(row, col)
            if row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year) + "-12-31 00:00:00", "%Y-%m-%d %H:%M:%S"):
                df_table.values[8][(column_names[col_index + 1], columns[col_index + 3])] = getattr(row, col)
            # for next year
            if row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 1) + "-03-31 00:00:00", "%Y-%m-%d %H:%M:%S"):
                df_table.values[10][(column_names[col_index + 2], columns[col_index])] = getattr(row, col)
            if row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 1) + "-06-30 00:000

0:00", "%Y-%m-%d %H:%M:%S"):
                df_table.values[11][(column_names[col_index + 2], columns[col_index + 1])] = getattr(row, col)
            if row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 1) + "-09-30 00:00:00", "%Y-%m-%d %H:%M:%S"):
                df_table.values[12][(column_names[col_index + 2], columns[col_index + 2])] = getattr(row, col)
            if row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 1) + "-12-31 00:00:00", "%Y-%m-%d %H:%M:%S"):
                df_table.values[13][(column_names[col_index + 2], columns[col_index + 3])] = getattr(row, col)
            # for current year + 2
            if row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 2) + "-03-31 00:00:00", "%Y-%m-%d %H:%M:%S"):
                year3_sum += getattr(row, col)
            if row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 2) + "-06-30 00:00:00", "%Y-%m-%d %H:%M:%S"):
                year3_sum += getattr(row, col)
            if row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 2) + "-09-30 00:00:00", "%Y-%m-%d %H:%M:%S"):
                year3_sum += getattr(row, col)
            if row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 2) + "-12-31 00:00:00", "%Y-%m-%d %H:%M:%S"):
                year3_sum += getattr(row, col)
            # for current year + 3
            if row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 3) + "-03-31 00:00:00", "%Y-%m-%d %H:%M:%S"):
                year4_sum += getattr(row, col)
            if row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 3) + "-06-30 00:00:00", "%Y-%m-%d %H:%M:%S"):
                year4_sum += getattr(row, col)

            if row.ISOCODES == Isocode and row.date == datetime.strptime(str(curr_year + 3) + "-09























         import pandas as pd

curr_year = 2024
column_names = [['IFRS9 1Q24 Scenarios'], ['IFRS9 4Q23 Scenarios'], ["Moody's"]]
columns = [['Upside', 'Central', 'Down 1', 'Down 2'], ['Upside', 'Central', 'Down 1', 'Down 2', 'Weighted'], ['10% UP', 'Central', '10% DN', '4% DN']]
rows = ['Q1', 'Q2', 'Q3', 'Q4', str(curr_year - 1), 'Q1', 'Q2', 'Q3', 'Q4', str(curr_year), 'Q1', 'Q2', 'Q3', 'Q4', str(curr_year + 1), str(curr_year + 2), str(curr_year + 3), '5yr Avg']

# Creating DataFrames for each element in column_names
dfs = []
for name, cols in zip(column_names, columns):
    df = pd.DataFrame(columns=pd.MultiIndex.from_product([name, cols]), index=rows)
    dfs.append(df)

# Displaying the DataFrames
df_final = pd.concat(dfs, axis=1)





dfs = [pd.DataFrame(columns=pd.MultiIndex.from_product([name, cols]), index=rows) for name, cols in zip(column_names, columns)]

# Concatenate the DataFrames along columns
df_table = pd.concat(dfs, axis=1)















import openpyxl
from openpyxl.styles import Font, PatternFill, Border, Side

def format_sheet(sheet):
    # Set the colors for column cells and other cells
    grey_fill = PatternFill(start_color="FFAFAFAF", end_color="FFAFAFAF", fill_type="solid")
    red_fill = PatternFill(start_color="FFFF0000", end_color="FFFF0000", fill_type="solid")

    # Set the border style
    thin_border = Border(left=Side(style='thin'), right=Side(style='thin'), top=Side(style='thin'), bottom=Side(style='thin'))

    # Set the cell colors and border
    for row in sheet.iter_rows():
        for cell in row:
            if cell.column_letter in ['D', 'H', 'L', 'P']:  # Assuming columns D, H, L, and P are column headers
                cell.fill = red_fill
            else:
                cell.fill = grey_fill
            cell.border = thin_border

    # Set grid lines color to white
    sheet.sheet_view.showGridLines = False

# Your existing code
for Isocode in country_list:
    col_list = Table_List["MEV"].loc[Table_List["Country"] == Isocode].tolist()
    with pd.ExcelWriter("2401_GBIC_Tables_29022024.xlsx", engine='openpyxl', mode="a", if_sheet_exists='overlay') as writer:
        start_row = 6
        start_col = 4
        for col in col_list:
            table = construct_and_populate_tables(Isocode, tzero_date, col)
            table.to_excel(writer, sheet_name=Isocode, startrow=start_row, startcol=start_col, index=True)
            workbook = writer.book
            worksheet = writer.sheets[Isocode]
            format_sheet(worksheet)
            start_col += len(table.columns) + 4
























from openpyxl.styles import PatternFill, Border

def format_sheet(sheet):
    # Set the colors for column cells and other cells
    grey_fill = PatternFill(start_color="FFAFAFAF", end_color="FFAFAFAF", fill_type="solid")
    red_fill = PatternFill(start_color="FFFF0000", end_color="FFFF0000", fill_type="solid")

    # Set the border style
    thin_border = Border(left=Side(style='thin'), right=Side(style='thin'), top=Side(style='thin'), bottom=Side(style='thin'))

    # Apply formatting to cells
    for row in sheet.iter_rows():
        for cell in row:
            if cell.column_letter in ['D', 'H', 'L', 'P']:  # Assuming columns D, H, L, and P are column headers
                cell.fill = red_fill
            else:
                cell.fill = grey_fill
            cell.border = thin_border

    # Set grid lines color to white
    for row in sheet.iter_rows():
        for cell in row:
            cell.border = thin_border
            cell.style = "Normal"  # Reset any existing styles

    sheet.sheet_view.showGridLines = True  # Enable grid lines
    sheet.sheet_view.tabColor = "FFFFFFFF"  # Set tab color to white













from openpyxl.styles import PatternFill, Border

def format_sheet(sheet):
    # Set the colors for column cells and other cells
    light_grey_fill = PatternFill(start_color="FFD3D3D3", end_color="FFD3D3D3", fill_type="solid")  # Light grey
    red_fill = PatternFill(start_color="FFFF0000", end_color="FFFF0000", fill_type="solid")  # Red

    # Set the border style
    thin_border = Border(left=Side(style='thin'), right=Side(style='thin'), top=Side(style='thin'), bottom=Side(style='thin'))

    # Apply formatting to cells
    for row in sheet.iter_rows():
        for cell in row:
            if cell.column_letter in ['D', 'H', 'L', 'P']:  # Assuming columns D, H, L, and P are column headers
                cell.fill = red_fill
            else:
                cell.fill = light_grey_fill
            cell.border = thin_border

    # Set grid lines color to white
    for row in sheet.iter_rows():
        for cell in row:
            cell.border = thin_border
            cell.style = "Normal"  # Reset any existing styles

    sheet.sheet_view.showGridLines = True  # Enable grid lines
    sheet.sheet_view.tabColor = "FFFFFFFF"  # Set tab color to white














from openpyxl.styles import PatternFill, Border

def format_sheet(sheet):
    # Set the colors for column cells and other cells
    light_grey_fill = PatternFill(start_color="FFD3D3D3", end_color="FFD3D3D3", fill_type="solid")  # Light grey
    red_fill = PatternFill(start_color="FFFF0000", end_color="FFFF0000", fill_type="solid")  # Red

    # Set the border style
    thin_border = Border(left=Side(style='thin'), right=Side(style='thin'), top=Side(style='thin'), bottom=Side(style='thin'))

    # Apply formatting to cells
    for row in sheet.iter_rows():
        for cell in row:
            if cell.column_letter in ['D', 'H', 'L', 'P']:  # Assuming columns D, H, L, and P are column headers
                cell.fill = red_fill
            else:
                cell.fill = light_grey_fill
            cell.border = thin_border

    # Set grid lines color to white
    for row in sheet.iter_rows():
        for cell in row:
            cell.border = thin_border
            cell.style = "Normal"  # Reset any existing styles

    sheet.sheet_view.showGridLines = True  # Enable grid lines
    sheet.sheet_view.tabColor = "FFFFFFFF"  # Set tab color to white
















from openpyxl.styles import Border
from openpyxl.utils import range_boundaries

def format_sheet(sheet):
    # Set the border style with white color
    white_border = Border(left=Side(style='thin', color='FFFFFFFF'),
                          right=Side(style='thin', color='FFFFFFFF'),
                          top=Side(style='thin', color='FFFFFFFF'),
                          bottom=Side(style='thin', color='FFFFFFFF'))

    # Apply white border to all cells
    for row in sheet.iter_rows():
        for cell in row:
            cell.border = white_border

    # Set tab color to white
    sheet.sheet_view.tabColor = "FFFFFFFF"  # Set tab color to white

    # Handle merged cells
    for merged_cell_range in sheet.merged_cells.ranges:
        min_row, min_col, max_row, max_col = range_boundaries(merged_cell_range)
        for row in range(min_row, max_row + 1):
            for col in range(min_col, max_col + 1):
                cell = sheet.cell(row=row, column=col)
                cell.border = white_border

















from openpyxl.styles import Font

def format_sheet(sheet):
    # Define column names and columns
    column_names = [['IFRS9 1Q24 Scenarios'], ['IFRS9 4Q23 Scenarios'], ["Moody's"]]
    columns = [['Upside', 'Central', 'Down 1', 'Down 2'], ['Upside', 'Central', 'Down 1', 'Down 2', 'Weighted'], ['10% UP', 'Central', '10% DN', '4% DN']]

    # Define rows
    curr_year = 2024
    rows = ['Q1', 'Q2', 'Q3', 'Q4', str(curr_year - 1), 'Q1', 'Q2', 'Q3', 'Q4', str(curr_year), 'Q1', 'Q2', 'Q3', 'Q4', str(curr_year + 1), str(curr_year + 2), str(curr_year + 3), '5yr Avg']

    # Apply formatting for column names (white font color)
    font_white = Font(color="FFFFFFFF")
    for i, names in enumerate(column_names):
        for j, name in enumerate(names):
            cell = sheet.cell(row=j+1, column=i+1)
            cell.value = name
            cell.font = font_white

    # Apply formatting for columns (black bold font)
    font_black_bold = Font(color="00000000", bold=True)
    for i, cols in enumerate(columns):
        for j, col in enumerate(cols):
            cell = sheet.cell(row=len(rows)+2, column=j+1+i*len(cols))
            cell.value = col
            cell.font = font_black_bold

    # Apply formatting for rows (black bold font)
    for i, row in enumerate(rows):
        cell = sheet.cell(row=i+2, column=len(column_names)+1)
        cell.value = row
        cell.font = font_black_bold













from openpyxl.styles import Font

def format_sheet(sheet):
    # Define the names to be discovered and formatted with white font color
    names_to_discover = ['IFRS9 1Q24 Scenarios', 'IFRS9 4Q23 Scenarios', "Moody's", 'Upside', 'Central', 'Down 1', 'Down 2', 'Weighted', '10% UP', 'Central', '10% DN', '4% DN']

    # Apply formatting for names with white font color
    font_white = Font(color="FFFFFFFF")
    for name in names_to_discover:
        for row in sheet.iter_rows():
            for cell in row:
                if cell.value == name:
                    cell.font = font_white












from openpyxl.styles import Font, PatternFill
import re

def format_sheet(sheet):
    # Define the names to be discovered and formatted with white font color
    names_to_discover = ['IFRS9 1Q24 Scenarios', 'IFRS9 4Q23 Scenarios', "Moody's", 'Upside', 'Central', 'Down 1', 'Down 2', 'Weighted', '10% UP', 'Central', '10% DN', '4% DN']

    # Define pattern to match numbers with one decimal place
    decimal_pattern = re.compile(r'\b\d+\.\d\b')

    # Apply formatting for names with white font color
    font_white = Font(color="FFFFFFFF")
    for name in names_to_discover:
        for row in sheet.iter_rows():
            for cell in row:
                if cell.value == name:
                    cell.font = font_white

    # Apply lightest grey fill to cells containing numbers with one decimal place
    lightest_grey_fill = PatternFill(start_color="FFDDDDDD", end_color="FFDDDDDD", fill_type="solid")
    for row in sheet.iter_rows():
        for cell in row:
            if isinstance(cell.value, float) and decimal_pattern.match(str(cell.value)):
                cell.fill = lightest_grey_fill











for row in ws.iter_rows():
        for cell in row:
            # Check if the cell contains a numerical value
            if isinstance(cell.value, (int, float)):
                # Round off numerical values to 1 decimal point
                cell.value = round(cell.value, 1)








lightest_grey = 'E0E0E0'

# Iterate through all sheets
for sheet in wb.sheetnames:
    ws = wb[sheet]
    # Iterate through all rows and columns
    for row in ws.iter_rows():
        for cell in row:
            # Check if the cell contains a numerical value
            if isinstance(cell.value, (int, float)):
                # Round off numerical values to 1 decimal point
                cell.value = round(cell.value, 1)
                # Grey out cells with negative numbers
                if cell.value < 0:
                    grey_fill = PatternFill(start_color=lightest_grey, end_color=lightest_grey, fill_type='solid')
                    cell.fill = grey_fill















from openpyxl import load_workbook
from openpyxl.styles import PatternFill

# Load the Excel file
wb = load_workbook('your_excel_file.xlsx')

# Define the lightest grey color
lightest_grey = 'E0E0E0'

# Define the index rows
index_rows = ['Q1', 'Q2', 'Q3', 'Q4']

# Iterate through all sheets
for sheet in wb.sheetnames:
    ws = wb[sheet]
    # Iterate through all rows
    for row in ws.iter_rows():
        # Check if the row index corresponds to the specified index rows
        if row[0].value in index_rows:
            # Iterate through all cells in the row starting from the second cell
            for cell in row[1:]:
                # Check if the cell contains a numerical value
                if isinstance(cell.value, (int, float)):
                    # Round off numerical values to 1 decimal point
                    cell.value = round(cell.value, 1)
                    # Grey out cells with negative numbers
                    if cell.value < 0:
                        grey_fill = PatternFill(start_color=lightest_grey, end_color=lightest_grey, fill_type='solid')
                        cell.fill = grey_fill

# Save the modified Excel file
wb.save('rounded_and_greyed_excel_file.xlsx')



















from openpyxl import load_workbook
from openpyxl.styles import PatternFill
import numpy as np

# Load the Excel file
wb = load_workbook('your_excel_file.xlsx')

# Define the lightest grey color
lightest_grey = 'E0E0E0'

# Define the index rows
index_rows = ['Q1', 'Q2', 'Q3', 'Q4']

# Iterate through all sheets
for sheet in wb.sheetnames:
    ws = wb[sheet]
    # Iterate through the rows
    for row in ws.iter_rows():
        # Check if the row index corresponds to the specified index rows
        if row[0].value in index_rows:
            # Iterate through all cells in the row
            for cell in row:
                # Check if the cell contains a numeric value
                if isinstance(cell.value, (int, float)):
                    # Round off numerical values to 1 decimal point
                    cell.value = round(cell.value, 1)
            # Apply lightest grey color to all cells in the row
            for cell in row:
                grey_fill = PatternFill(start_color=lightest_grey, end_color=lightest_grey, fill_type='solid')
                cell.fill = grey_fill

# Save the modified Excel file
wb.save('rounded_and_greyed_excel_file.xlsx')


















from openpyxl import load_workbook
from openpyxl.styles import PatternFill
import numpy as np

# Load the Excel file
wb = load_workbook('your_excel_file.xlsx')

# Define the lightest grey color
lightest_grey = 'E0E0E0'

# Define the index rows
index_rows = ['Q1', 'Q2', 'Q3', 'Q4']

# Iterate through all sheets
for sheet in wb.sheetnames:
    ws = wb[sheet]
    # Iterate through the rows
    for row in ws.iter_rows():
        # Check if the row index corresponds to the specified index rows
        if row[0].value in index_rows:
            # Iterate through all cells in the row
            for cell in row:
                # Check if the cell contains a numeric value
                if isinstance(cell.value, (int, float)) and not np.isnan(cell.value):
                    # Apply light grey fill to the cell
                    grey_fill = PatternFill(start_color=lightest_grey, end_color=lightest_grey, fill_type='solid')
                    cell.fill = grey_fill

# Save the modified Excel file
wb.save('greyed_excel_file.xlsx')













from openpyxl import load_workbook
from openpyxl.styles import PatternFill, Font
import numpy as np

# Load the Excel file
wb = load_workbook('your_excel_file.xlsx')

# Define the sheet name font color and background colors
white_font_color = 'FFFFFFFF'
red_fill_color = 'FF0000'

# Iterate through all sheets
for sheet_name in wb.sheetnames:
    ws = wb[sheet_name]
    # Iterate through all cells in the sheet
    for row in ws.iter_rows():
        for cell in row:
            # Find the cell with value 'IFRS 1Q24 Scenarios'
            if cell.value == 'IFRS 1Q24 Scenarios':
                # Get the cell position
                cell_position = cell.coordinate
                # Write the sheet name in the cell to its left with white font color
                left_cell = ws[cell.column_letter + str(cell.row)]
                left_cell.value = sheet_name
                left_cell.font = Font(color=white_font_color)
                # Set the background color of the cell just below 'IFRS 1Q24 Scenarios' to red
                below_cell = ws[cell.column_letter + str(cell.row + 1)]
                below_cell.fill = PatternFill(start_color=red_fill_color, end_color=red_fill_color, fill_type='solid')

# Save the modified Excel file
wb.save('modified_excel_file.xlsx')















from openpyxl import load_workbook
from openpyxl.styles import Font

# Load the Excel file
wb = load_workbook('your_excel_file.xlsx')

# Iterate through all sheets
for sheet_name in wb.sheetnames:
    ws = wb[sheet_name]
    # Iterate through all cells in the sheet
    for row in ws.iter_rows():
        for cell in row:
            # Find the cell with value 'IFRS9 4Q23 Scenarios'
            if cell.value == 'IFRS9 4Q23 Scenarios':
                # Iterate through cells below 'IFRS9 4Q23 Scenarios' in the same column
                for row_below in ws.iter_rows(min_row=cell.row + 1, min_col=cell.column, max_col=cell.column):
                    for cell_below in row_below:
                        # Check if the cell contains a numeric value
                        if isinstance(cell_below.value, (int, float)):
                            # Set font to italic
                            cell_below.font = Font(italic=True)
                # Exit the loop as we found the target cell
                break
        # Exit the outer loop as we found the target cell
        else:
            continue
        break

# Save the modified Excel file
wb.save('modified_excel_file.xlsx')




























from openpyxl import load_workbook
from openpyxl.styles import Border, Side
from openpyxl.utils import get_column_letter
from statistics import mean

# Load the Excel file
wb = load_workbook('your_excel_file.xlsx')
ws = wb.active

# Find the cell with value '5yr Avg'
for row in ws.iter_rows():
    for cell in row:
        if cell.value == '5yr Avg':
            start_row = cell.row + 5
            # Create a box starting 5 rows below '5yr Avg'
            for i in range(start_row, start_row + 5):
                for j in range(5):
                    ws.cell(row=i, column=j+1).border = Border(left=Side(border_style='thin'),
                                                                right=Side(border_style='thin'),
                                                                top=Side(border_style='thin'),
                                                                bottom=Side(border_style='thin'))

            # Write 'Min' in the first cell after 5 rows
            ws.cell(row=start_row, column=6).value = 'Min'
            # Calculate and write the minimum of E7 to H20
            min_value = min(ws[get_column_letter(col) + str(row)].value for row in range(7, 21) for col in range(5, 9))
            ws.cell(row=start_row, column=7).value = min_value

            # Write 'LT' in the cell next to 'Min'
            ws.cell(row=start_row + 1, column=6).value = 'LT'
            # Calculate and write the average of F22 and F23
            avg_value = mean([ws['F22'].value, ws['F23'].value])
            ws.cell(row=start_row + 1, column=7).value = avg_value

            # Write 'Max' in the cell next to 'LT'
            ws.cell(row=start_row + 2, column=6).value = 'Max'
            # Calculate and write the maximum of E7 to H20
            max_value = max(ws[get_column_letter(col) + str(row)].value for row in range(7, 21) for col in range(5, 9))
            ws.cell(row=start_row + 2, column=7).value = max_value

            # Apply border to the box
            for i in range(5):
                ws.cell(row=start_row + i, column=6).border = Border(left=Side(border_style='thin'))

# Save the modified Excel file
wb.save('modified_excel_file.xlsx')

















from openpyxl import load_workbook
from openpyxl.styles import PatternFill
from openpyxl.utils import get_column_letter

# Load the Excel file
wb = load_workbook('your_excel_file.xlsx')
ws = wb.active

# Find the cell with value 'Moody's'
for row in ws.iter_rows():
    for cell in row:
        if cell.value == "Moody's":
            col = cell.column
            # Apply grey color to cells in that column from row 2 to row 38
            for i in range(2, 39):
                ws[get_column_letter(col) + str(i)].fill = PatternFill(start_color="E0E0E0", end_color="E0E0E0", fill_type="solid")
                # Set the width of the cell to half of the actual cell width
                ws.column_dimensions[get_column_letter(col)].width = ws.column_dimensions[get_column_letter(col)].width / 2
            # Exit the loop after finding 'Moody's'
            break
    # Exit the loop after finding 'Moody's'
    else:
        continue
    break

# Save the modified Excel file
wb.save('modified_excel_file.xlsx')











from openpyxl import load_workbook
from openpyxl.styles import Alignment

# Load the Excel file
wb = load_workbook('your_excel_file.xlsx')
ws = wb.active

# Iterate through all cells in the sheet
for row in ws.iter_rows():
    for cell in row:
        # Check if the cell contains a numerical value (integer or float)
        if isinstance(cell.value, (int, float)):
            # Set alignment to center for numerical values
            cell.alignment = Alignment(horizontal='center')

# Save the modified Excel file
wb.save('modified_excel_file.xlsx')










from openpyxl import load_workbook
from openpyxl.styles import Font

# Load the Excel file
wb = load_workbook('your_excel_file.xlsx')
ws = wb.active

# Iterate through all cells in the sheet
for row_index, row in enumerate(ws.iter_rows(), start=1):
    for cell in row:
        # Check if the cell is below the "IFRS9 4Q23 Scenarios" cell
        if cell.value == "IFRS9 4Q23 Scenarios":
            start_index = row_index + 1
            for i in range(start_index, start_index + 5):
                for col_index in range(1, ws.max_column + 1):
                    # Check if the cell contains a numerical value (integer or float)
                    if isinstance(ws.cell(row=i, column=col_index).value, (int, float)):
                        # Set font style to italic for numerical values below "IFRS9 4Q23 Scenarios" cell
                        ws.cell(row=i, column=col_index).font = Font(italic=True)

# Save the modified Excel file
wb.save('modified_excel_file.xlsx')



























from openpyxl import load_workbook
from openpyxl.styles import Border, Side
from openpyxl.utils import get_column_letter
from statistics import mean

# Load the Excel file
wb = load_workbook('your_excel_file.xlsx')
ws = wb.active

# Iterate through all cells in the sheet
for row in ws.iter_rows():
    for cell in row:
        if cell.value == '5yr Avg':
            start_row = cell.row + 5
            # Create a box starting 5 rows below '5yr Avg'
            for i in range(start_row, start_row + 5):
                for j in range(5):
                    ws.cell(row=i, column=j+1).border = Border(left=Side(border_style='thin'),
                                                                right=Side(border_style='thin'),
                                                                top=Side(border_style='thin'),
                                                                bottom=Side(border_style='thin'))

                # Write 'Min' in the first cell after 5 rows
                ws.cell(row=i, column=6).value = 'Min'
                # Calculate and write the minimum of E7 to H20
                min_value = min(ws[get_column_letter(col) + str(row)].value for row in range(7, 21) for col in range(5, 9))
                ws.cell(row=i, column=7).value = min_value

                # Write 'LT' in the cell next to 'Min'
                ws.cell(row=i, column=8).value = 'LT'
                # Calculate and write the average of F22 and F23
                avg_value = mean([ws['F22'].value, ws['F23'].value])
                ws.cell(row=i, column=9).value = avg_value

                # Write 'Max' in the cell next to 'LT'
                ws.cell(row=i, column=10).value = 'Max'
                # Calculate and write the maximum of E7 to H20
                max_value = max(ws[get_column_letter(col) + str(row)].value for row in range(7, 21) for col in range(5, 9))
                ws.cell(row=i, column=11).value = max_value

# Save the modified Excel file
wb.save('modified_excel_file.xlsx')












from openpyxl import load_workbook
from openpyxl.styles import Border, Side
from openpyxl.utils import get_column_letter
from statistics import mean

# Load the Excel file
wb = load_workbook('your_excel_file.xlsx')
sheet = wb.active

# Iterate through all cells in the sheet
for row in sheet.iter_rows():
    for cell in row:
        if cell.value == '5yr Avg':
            start_row = cell.row + 5
            # Create a box starting 5 rows below '5yr Avg'
            for i in range(start_row, start_row + 5):
                for j in range(5):
                    sheet.cell(row=i, column=j+1).border = Border(left=Side(border_style='thin'),
                                                                   right=Side(border_style='thin'),
                                                                   top=Side(border_style='thin'),
                                                                   bottom=Side(border_style='thin'))

                # Write 'Min' in the first cell after 5 rows
                sheet.cell(row=i, column=6).value = 'Min'
                # Calculate and write the minimum of E7 to H20
                min_value = min(sheet[get_column_letter(col) + str(row)].value for row in range(7, 21) for col in range(5, 9))
                sheet.cell(row=i, column=7).value = min_value

                # Write 'LT' in the cell next to 'Min'
                sheet.cell(row=i, column=8).value = 'LT'
                # Calculate and write the average of F22 and F23
                avg_value = mean([sheet['F22'].value, sheet['F23'].value])
                sheet.cell(row=i, column=9).value = avg_value

                # Write 'Max' in the cell next to 'LT'
                sheet.cell(row=i, column=10).value = 'Max'
                # Calculate and write the maximum of E7 to H20
                max_value = max(sheet[get_column_letter(col) + str(row)].value for row in range(7, 21) for col in range(5, 9))
                sheet.cell(row=i, column=11).value = max_value

# Save the modified Excel file
wb.save('modified_excel_file.xlsx')














from openpyxl import load_workbook
from openpyxl.styles import Border, Side
from openpyxl.utils import get_column_letter
from statistics import mean

# Load the Excel file
wb = load_workbook('your_excel_file.xlsx')
sheet = wb.active

# Iterate through all cells in the sheet
for row in sheet.iter_rows():
    for cell in row:
        if cell.value == '5yr Avg':
            start_row = cell.row + 5
            # Create a box starting 5 rows below '5yr Avg'
            for i in range(start_row, start_row + 5):
                for j in range(5):
                    sheet.cell(row=i, column=j+1).border = Border(left=Side(border_style='thin'),
                                                                   right=Side(border_style='thin'),
                                                                   top=Side(border_style='thin'),
                                                                   bottom=Side(border_style='thin'))

            # Write 'Min' in the first cell after 5 rows
            sheet.cell(row=start_row, column=6).value = 'Min'
            # Calculate and write the minimum of E7 to H20
            min_value = min(sheet[get_column_letter(col) + str(row)].value for row in range(7, 21) for col in range(5, 9))
            sheet.cell(row=start_row, column=7).value = min_value

            # Write 'LT' in the cell next to 'Min'
            sheet.cell(row=start_row + 1, column=6).value = 'LT'
            # Calculate and write the average of F22 and F23
            avg_value = mean([sheet['F22'].value, sheet['F23'].value])
            sheet.cell(row=start_row + 1, column=7).value = avg_value

            # Write 'Max' in the cell next to 'LT'
            sheet.cell(row=start_row + 2, column=6).value = 'Max'
            # Calculate and write the maximum of E7 to H20
            max_value = max(sheet[get_column_letter(col) + str(row)].value for row in range(7, 21) for col in range(5, 9))
            sheet.cell(row=start_row + 2, column=7).value = max_value

# Save the modified Excel file
wb.save('modified_excel_file.xlsx')
























from openpyxl import load_workbook
from openpyxl.styles import Border, Side
from openpyxl.utils import get_column_letter
from statistics import mean

# Load the Excel file
wb = load_workbook('your_excel_file.xlsx')
sheet = wb.active

# Iterate through all cells in the first row to find the column number of '5yr Avg'
for cell in sheet[1]:
    if cell.value == '5yr Avg':
        avg_column = cell.column

# Iterate through all cells in the sheet
for row in sheet.iter_rows():
    for cell in row:
        if cell.value == '5yr Avg':
            start_row = cell.row + 5
            # Create a box starting 5 rows below '5yr Avg'
            for i in range(start_row, start_row + 5):
                for j in range(5):
                    sheet.cell(row=i, column=j+1).border = Border(left=Side(border_style='thin'),
                                                                   right=Side(border_style='thin'),
                                                                   top=Side(border_style='thin'),
                                                                   bottom=Side(border_style='thin'))

            # Write 'Min' in the first cell after 5 rows
            sheet.cell(row=start_row, column=avg_column + 1).value = 'Min'
            # Calculate and write the minimum of E7 to H20
            min_value = min(sheet[get_column_letter(avg_column + col) + str(row)].value for row in range(7, 21) for col in range(4))
            sheet.cell(row=start_row, column=avg_column + 2).value = min_value

            # Write 'LT' in the cell next to 'Min'
            sheet.cell(row=start_row + 1, column=avg_column + 1).value = 'LT'
            # Calculate and write the average of F22 and F23
            avg_value = mean([sheet[get_column_letter(avg_column + 5) + '22'].value, sheet[get_column_letter(avg_column + 5) + '23'].value])
            sheet.cell(row=start_row + 1, column=avg_column + 2).value = avg_value

            # Write 'Max' in the cell next to 'LT'
            sheet.cell(row=start_row + 2, column=avg_column + 1).value = 'Max'
            # Calculate and write the maximum of E7 to H20
            max_value = max(sheet[get_column_letter(avg_column + col) + str(row)].value for row in range(7, 21) for col in range(4))
            sheet.cell(row=start_row + 2, column=avg_column + 2).value = max_value

# Save the modified Excel file
wb.save('modified_excel_file.xlsx')

















from openpyxl import load_workbook
from openpyxl.styles import Border, Side
from openpyxl.utils import get_column_letter
from statistics import mean

# Load the Excel file
wb = load_workbook('your_excel_file.xlsx')
sheet = wb.active

# Iterate through all occurrences of '5yr Avg'
for row in sheet.iter_rows():
    for cell in row:
        if cell.value == '5yr Avg':
            # Find the row index for 'IFRS 1Q24 Scenarios'
            ifrs_row_index = None
            for r in sheet.iter_rows(min_row=cell.row, max_row=cell.row + 10):
                for c in r:
                    if c.value == 'IFRS 1Q24 Scenarios':
                        ifrs_row_index = c.row
                        break
                if ifrs_row_index is not None:
                    break
            # Define the range for min and max calculations
            min_range = sheet[f'A{ifrs_row_index + 1}:Z2025']
            max_range = sheet[f'A{ifrs_row_index + 1}:Z2025']
            # Calculate min and max values
            min_value = min(cell.value for row in min_range for cell in row if isinstance(cell.value, (int, float)))
            max_value = max(cell.value for row in max_range for cell in row if isinstance(cell.value, (int, float)))
            # Write min and max values to the corresponding cells
            sheet[f'A{ifrs_row_index + 5}'].value = 'Min'
            sheet[f'B{ifrs_row_index + 5}'].value = min_value
            sheet[f'A{ifrs_row_index + 6}'].value = 'Max'
            sheet[f'B{ifrs_row_index + 6}'].value = max_value








from openpyxl import load_workbook
from openpyxl.utils import column_index_from_string

# Load the Excel file
wb = load_workbook('your_excel_file.xlsx')
sheet = wb.active

# Iterate through all occurrences of '5yr Avg'
for row in sheet.iter_rows():
    for cell in row:
        if cell.value == '5yr Avg':
            # Get the row index for '5yr Avg'
            avg_row_index = cell.row

            # Find the row index for 'IFRS 1Q24 Scenarios' and row index of 2025
            ifrs_row_index = None
            row_2025_index = None
            for r in sheet.iter_rows(min_row=avg_row_index):
                for c in r:
                    if c.value == 'IFRS 1Q24 Scenarios':
                        ifrs_row_index = c.row
                    if c.value == 2025:
                        row_2025_index = c.row
                        break
                if ifrs_row_index is not None and row_2025_index is not None:
                    break

            # Define the range for min and max calculations
            min_range = sheet[f'A{ifrs_row_index + 1}:Z{row_2025_index - 1}']
            max_range = sheet[f'A{ifrs_row_index + 1}:Z{row_2025_index - 1}']

            # Calculate min and max values
            min_value = min(cell.value for r in min_range for cell in r if isinstance(cell.value, (int, float)))
            max_value = max(cell.value for r in max_range for cell in r if isinstance(cell.value, (int, float)))

            # Write min and max values to the corresponding cells
            sheet[f'A{row_2025_index + 1}'].value = 'Min'
            sheet[f'B{row_2025_index + 1}'].value = min_value
            sheet[f'A{row_2025_index + 2}'].value = 'Max'
            sheet[f'B{row_2025_index + 2}'].value = max_value

# Save the modified Excel file
wb.save('modified_excel_file.xlsx')


from openpyxl import load_workbook

# Load the Excel file
wb = load_workbook('your_excel_file.xlsx')
sheet = wb.active

# Iterate through all occurrences of '5yr Avg'
for row in sheet.iter_rows():
    for cell in row:
        if cell.value == '5yr Avg':
            # Get the row index for '5yr Avg'
            avg_row_index = cell.row

            # Find the row index for 'IFRS 1Q24 Scenarios' and the row indices containing '2025'
            ifrs_row_index = None
            row_2025_indices = []
            for r in sheet.iter_rows(min_row=avg_row_index):
                for c in r:
                    if c.value == 'IFRS 1Q24 Scenarios':
                        ifrs_row_index = c.row
                    if c.value == 2025:
                        row_2025_indices.append(c.row)
                if ifrs_row_index is not None and row_2025_indices:
                    break

            # Check if 'IFRS 1Q24 Scenarios' and '2025' rows were found
            if ifrs_row_index is not None and row_2025_indices:
                # Calculate min and max values for each column
                min_values = []
                max_values = []
                for col in range(1, sheet.max_column + 1):
                    # Skip columns before 'IFRS 1Q24 Scenarios'
                    if col < cell.column:
                        continue
                    # Skip columns after '2025'
                    if col > row_2025_indices[0]:
                        break
                    # Calculate min and max values for the current column
                    column_values = [cell.value for cell in sheet.iter_rows(min_row=ifrs_row_index + 1, max_row=row_2025_indices[0] - 1, min_col=col, max_col=col)]
                    column_values = [value for value in column_values if isinstance(value, (int, float))]
                    min_values.append(min(column_values) if column_values else None)
                    max_values.append(max(column_values) if column_values else None)

                # Write min and max values to the corresponding cells
                min_row = max(row_2025_indices) + 1
                max_row = max(row_2025_indices) + 2
                for i, (min_val, max_val) in enumerate(zip(min_values, max_values), start=1):
                    sheet.cell(row=min_row, column=i).value = min_val
                    sheet.cell(row=max_row, column=i).value = max_val

# Save the modified Excel file
wb.save('modified_excel_file.xlsx')

























from openpyxl.utils import get_column_letter
import numpy as np

# Iterate through all rows in the sheet
for row in sheet.iter_rows():
    for cell in row:
        if cell.value == '5yr Avg':
            # Define start_row as the row index of the '5yr Avg' cell
            start_row = cell.row

            # Find the maximum row index containing data (2025)
            max_row_index = max((row_index for row_index, _ in enumerate(sheet.iter_rows(), start=1)), default=1)

            # Find the column index of the 'IFRS9 1Q24 Scenarios' column
            ifrs_column_index = None
            for col in sheet.iter_cols():
                if col[0].value == 'IFRS9 1Q24 Scenarios':
                    ifrs_column_index = col[0].column
                    break

            # Find the min and max values in the specified range
            data_range = sheet.iter_rows(min_row=1, max_row=start_row, min_col=ifrs_column_index, max_col=ifrs_column_index)
            data_values = [cell.value for row in data_range for cell in row if isinstance(cell.value, (int, float))]
            min_value = min(data_values) if data_values else None
            max_value = max(data_values) if data_values else None

            # Write the min and max values below the '5yr Avg' cell
            sheet.cell(row=start_row + 1, column=cell.column).value = 'Min'
            sheet.cell(row=start_row + 1, column=cell.column + 1).value = min_value
            sheet.cell(row=start_row + 2, column=cell.column).value = 'Max'
            sheet.cell(row=start_row + 2, column=cell.column + 1).value = max_value










from openpyxl.utils import get_column_letter
import numpy as np

# Iterate through all rows in the sheet
for row in sheet.iter_rows():
    for cell in row:
        if cell.value == '5yr Avg':
            # Define start_row as the row index of the '5yr Avg' cell
            start_row = cell.row

            # Find the maximum row index containing data (2025)
            max_row_index = max((row_index for row_index, row in enumerate(sheet.iter_rows(), start=1) if '2025' in str(row)), default=1)

            # Find the column index of the 'IFRS9 1Q24 Scenarios' column
            ifrs_column_index = None
            for col in sheet.iter_cols():
                if col[0].value == 'IFRS9 1Q24 Scenarios':
                    ifrs_column_index = col[0].column
                    break

            # Find the min and max values in the specified range
            data_range = sheet.iter_rows(min_row=1, max_row=max_row_index, min_col=ifrs_column_index, max_col=ifrs_column_index)
            data_values = [cell.value for row in data_range for cell in row if isinstance(cell.value, (int, float))]
            min_value = min(data_values) if data_values else None
            max_value = max(data_values) if data_values else None

            # Find the row index of 'IFRS9 1Q24 Scenarios'
            ifrs_row_index = None
            for row_index, row in enumerate(sheet.iter_rows(), start=1):
                for col_index, cell in enumerate(row, start=1):
                    if cell.value == 'IFRS9 1Q24 Scenarios':
                        ifrs_row_index = row_index
                        break
                if ifrs_row_index:
                    break

            # Find the 'Central' column
            central_column_index = None
            for col_index, cell in enumerate(sheet[ifrs_row_index], start=1):
                if cell.value == 'Central':
                    central_column_index = col_index
                    break

            # Find the LT (Average) value
            if central_column_index:
                central_data_values = [cell.value for cell in sheet.iter_rows(min_row=ifrs_row_index + 1, max_row=max_row_index, min_col=central_column_index, max_col=central_column_index)][0]
                lt_value = np.mean(central_data_values)
            else:
                lt_value = None

            # Write the min, max, and LT values below the '5yr Avg' cell
            sheet.cell(row=start_row + 1, column=cell.column).value = 'Min'
            sheet.cell(row=start_row + 1, column=cell.column + 1).value = min_value
            sheet.cell(row=start_row + 2, column=cell.column).value = 'Max'
            sheet.cell(row=start_row + 2, column=cell.column + 1).value = max_value
            sheet.cell(row=start_row + 3, column=cell.column).value = 'LT'
            sheet.cell(row=start_row + 3, column=cell.column + 1).value = lt_value




















from openpyxl.utils import get_column_letter
import numpy as np

for row in sheet.iter_rows():
    for cell in row:
        if cell.value == '5yr Avg':
            start_row = cell.row + 5
            ifrs_row_index = None
            for r_idx, row_data in enumerate(sheet.iter_rows(), start=1):
                for c_idx, cell_data in enumerate(row_data, start=1):
                    if cell_data.value == 'IFRS9 1Q24 Scenarios':
                        ifrs_row_index = r_idx
                        break
                if ifrs_row_index:
                    break

            # Finding the max value
            max_value_range = sheet.iter_rows(min_row=ifrs_row_index + 2, max_row=start_row - 2, min_col=cell.column, max_col=cell.column)
            max_values = [cell.value for row in max_value_range for cell in row if isinstance(cell.value, (int, float))]
            max_value = max(max_values) if max_values else None

            # Finding the min value
            min_value_range = sheet.iter_rows(min_row=ifrs_row_index + 2, max_row=start_row - 2, min_col=cell.column, max_col=cell.column)
            min_values = [cell.value for row in min_value_range for cell in row if isinstance(cell.value, (int, float))]
            min_value = min(min_values) if min_values else None

            # Finding the avg value
            avg_value_range = sheet.iter_rows(min_row=ifrs_row_index + 2, max_row=start_row - 2, min_col=cell.column + 1, max_col=cell.column + 1)
            avg_values = [cell.value for row in avg_value_range for cell in row if isinstance(cell.value, (int, float))]
            avg_value = np.mean(avg_values) if avg_values else None

            sheet.cell(row=start_row, column=cell.column).value = 'Min'
            sheet.cell(row=start_row, column=cell.column + 1).value = min_value

            sheet.cell(row=start_row + 1, column=cell.column).value = 'LT'
            sheet.cell(row=start_row + 1, column=cell.column + 1).value = avg_value

            sheet.cell(row=start_row + 2, column=cell.column).value = 'Max'
            sheet.cell(row=start_row + 2, column=cell.column + 1).value = max_value
